diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.hpp b/./ComputationEngine.hpp
index 4166df6..68d656c 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.hpp
+++ b/./ComputationEngine.hpp
@@ -18,6 +18,7 @@
 #include "DistributedComputation.hpp"
 #include "FileDescription.hpp"
 #include <vector>
+#include <cstdlib>
 
 //////////////////////////////////////////////////////////////////////
 // struct SharedInfo
@@ -37,6 +38,7 @@ struct SharedInfo
     bool use_nonsmooth;
     bool use_loss;
     RealT gamma;
+    RealT sigma;
     RealT log_base;
 //    std::vector<int> evidence_cpd_id;
     RealT evidence_data_scale;
@@ -76,7 +78,10 @@ enum ProcessingType
     COMPUTE_GRADIENT_SE,
     CHECK_ZEROS_IN_DATA,
     COMPUTE_HV,
-    PREDICT
+    PREDICT,
+    SAMPLE,
+    TEST_ENERGIES,
+    REVI,
 };
 
 struct NonSharedInfo
@@ -125,6 +130,9 @@ public:
     void ComputeGammaMLEFunctionAndGradient(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared, bool need_gradient);
     void ComputeHessianVectorProduct(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
     void Predict(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+    void Sample(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+    void RunREVI(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+    void TestEnergies(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
     void CheckZerosInData(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
     void ComputeGammaMLEScalingFactor(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
     void ComputeFunctionAndGradientSE(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared, bool need_gradient);
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.ipp b/./ComputationEngine.ipp
index 742d4c0..6903662 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.ipp
+++ b/./ComputationEngine.ipp
@@ -89,6 +89,15 @@ void ComputationEngine<RealT>::DoComputation(std::vector<RealT> &result,
         case PREDICT:
             Predict(result, shared, nonshared);
             break;
+        case SAMPLE:
+            Sample(result, shared, nonshared);
+            break;
+        case REVI:
+            RunREVI(result, shared, nonshared);
+            break;
+        case TEST_ENERGIES:
+            TestEnergies(result,shared,nonshared);
+            break;
         default: 
             Assert(false, "Unknown command type.");
             break;
@@ -1043,7 +1052,7 @@ void ComputationEngine<RealT>::ComputeFunctionAndGradientSE(std::vector<RealT> &
                 }
 
                 int index_k = parameter_manager.GetLogicalIndex(
-                    inference_engine.GetLogScoreEvidence(0, i, j, dataset_id));
+                    inference_engine.GetLogScoreEvidence(0, i, j, dataset_id)); // i: seq, j: pr or unpaired, ds=0
                 int index_theta = parameter_manager.GetLogicalIndex(
                     inference_engine.GetLogScoreEvidence(1, i, j, dataset_id));
 
@@ -1210,6 +1219,268 @@ void ComputationEngine<RealT>::ComputeHessianVectorProduct(std::vector<RealT> &r
     
     result = (result - result2) / (RealT(2) * EPSILON);
 }
+//////////////////////////////////////////////////////////////////////
+// ComputationEngine::TestEnergies()
+//
+// Print energies for a single sequence.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationEngine<RealT>::TestEnergies(std::vector<RealT> &result, 
+                                       const SharedInfo<RealT> &shared,
+                                       const NonSharedInfo &nonshared)
+{
+    result.clear();
+
+    // load sequence, with constraints if necessary
+    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
+    inference_engine.LoadSequence(sstruct);
+    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
+
+    // load parameters
+    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
+    inference_engine.LoadValues(w * shared.log_base);
+
+    inference_engine.UpdateEvidenceStructures();
+
+    // perform inference
+    SStruct *solution;
+
+    inference_engine.ComputeViterbi();
+
+    if (options.GetBoolValue("use_evidence")){
+        inference_engine.GetViterbiFeaturesESS();
+    }
+    else{
+            inference_engine.GetViterbiFeatures();
+    }
+
+    std::cout << "Viterbi score for \"" << descriptions[nonshared.index].input_filename << "\": " 
+            << inference_engine.GetViterbiScore() << std::endl;
+
+    solution = new SStruct(sstruct);
+    solution->SetMapping(inference_engine.PredictPairingsViterbi());
+
+    WriteProgressMessage("");
+    solution->WriteParens(std::cout);
+
+    delete solution;
+}
+
+//////////////////////////////////////////////////////////////////////
+// ComputationEngine::REVI()
+//
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationEngine<RealT>::RunREVI(std::vector<RealT> &result, 
+                                       const SharedInfo<RealT> &shared,
+                                       const NonSharedInfo &nonshared)
+{
+    result.clear();
+
+
+    // perform inference (repurposing chem mapping potentials as pairwise potentials)
+
+    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
+    inference_engine.LoadSequence(sstruct);
+    inference_engine.InitializeREVIVec();
+
+    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
+    // load parameters
+
+    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
+    inference_engine.LoadValues(w * shared.log_base);
+
+    int L = sstruct.GetLength();
+    int n_samples = 1000;
+    int n_iters = 100;
+    double last_loss_0 = 100000000;
+    double last_loss_1 = 100000000;
+    double last_loss_2 = 100000000;
+    double step_size = 0.1;
+
+    RealT sigma = shared.sigma;
+
+    for (int k=1; k<=n_iters; k++){
+
+    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
+    inference_engine.LoadValues(w * shared.log_base);
+
+    inference_engine.ComputeInsideESS();
+
+    std::vector<RealT> unp_i(L,0.0);
+    std::vector<RealT> pr_i(L,0.0);
+
+    std::vector<std::vector<RealT> > p_j_unp_given_i_unp;
+    std::vector<std::vector<RealT> > p_j_paired_given_i_paired;
+
+    for (int i=0; i< L; i++)
+    {    
+        std::vector<RealT> vec(L,0.0);
+        p_j_unp_given_i_unp.push_back(vec);
+        p_j_paired_given_i_paired.push_back(vec);
+    }
+
+    for (int sample_ind = 0; sample_ind < n_samples; sample_ind++)
+    { 
+
+    int seed = rand();
+    inference_engine.InitRand(seed);
+    std::vector<int> map = inference_engine.PredictPairingsStochasticTracebackESS();
+
+    // count occurences from samples
+    for (int i=0; i< L; i++)
+        {
+            if (map[i+1] == 0){
+                unp_i[i] += 1;
+
+                for (int j=0; j<L; j++){
+                    if (map[j+1] == 0)
+                    {
+                        p_j_unp_given_i_unp[i][j] += 1;
+                    }
+                }
+        }
+        else{ // base is paired
+            pr_i[i] += 1;
+             for (int j=0; j<L; j++){
+                        if (map[j+1] != 0)
+                        {
+                            p_j_paired_given_i_paired[i][j] += 1;
+                        }
+                    }   
+        }
+    }
+
+}
+    // normalize probability counts for p_unpaired vector
+
+    for (int i=0; i< L; i++)
+        {
+            if (unp_i[i] > 0){
+
+                for (int j=0; j<L; j++){
+                    p_j_unp_given_i_unp[i][j] /= unp_i[i]; 
+                }
+            }
+            unp_i[i] /= n_samples;
+    }
+
+    // normalize probability counts for p_paired vector
+    for (int i=0; i< L; i++)
+        {
+            if (pr_i[i] > 0){
+
+                for (int j=0; j<L; j++){
+                    p_j_paired_given_i_paired[i][j] /= pr_i[i]; 
+                }
+            }
+            pr_i[i] /= n_samples;
+    }
+
+    std::vector<RealT> error = inference_engine.GetREVIError(unp_i);
+    std::vector<std::vector< double> > currREVIvec_up = inference_engine.GetREVIvec_up();
+    std::vector<std::vector< double> > currREVIvec_pr = inference_engine.GetREVIvec_pr();
+
+    std::vector<RealT> update_unp(L,0.0);
+    std::vector<RealT> update_pr(L,0.0);
+
+    // get p_i, p_i_given_j
+    // write gradient
+
+    double curr_loss = 0.0;
+
+    // get gradient for unpaired potentials
+    for (int j=0; j< L; j++){
+
+     for (int i=0; i< L; i++)
+        {    
+        update_unp[j] += sigma*step_size*error[i]*unp_i[i]*(unp_i[j] - p_j_unp_given_i_unp[i][j]);
+        update_pr[j] += sigma*step_size*error[i]*pr_i[i]*(pr_i[j] - p_j_paired_given_i_paired[i][j]);
+
+            }
+        update_unp[j] += -2*step_size*currREVIvec_up[0][j];
+        update_pr[j] += -2*step_size*currREVIvec_pr[0][j]; //UPDATE to be curr REVI vec for paired
+
+        }
+
+    for (int i=0; i< L; i++)
+        {   
+        curr_loss += pow(currREVIvec_up[0][i],2) + sigma*pow(error[i],2) + pow(currREVIvec_pr[0][i],2); // UPDATE to be curr REVI vec for paired
+        }     
+
+
+    if ((abs(last_loss_2 - curr_loss) < 0.1) || k==n_iters){
+        // We're done, sample and print structures one more time
+
+    SStruct *solution;
+
+    if (options.GetStringValue("output_bpseq_destination") != "")
+    {
+        solution = new SStruct(sstruct);
+        //solution->SetMapping(inference_engine.PredictPairingsViterbi());
+
+        const std::string filename = MakeOutputFilename(descriptions[nonshared.index].input_filename,
+                                                        options.GetStringValue("output_bpseq_destination"),
+                                                        options.GetRealValue("gamma") < 0,
+                                                        shared.gamma);
+        std::ofstream outfile(filename.c_str());
+        if (outfile.fail()) Error("Unable to open output bpseq file '%s' for writing.", filename.c_str());
+        solution->WriteBPPSEQ(outfile, inference_engine.GetREVIvec_up());
+        outfile.close();
+        delete solution;
+    }
+
+    if (options.GetStringValue("output_posteriors_destination") != "")
+    {
+        const std::string filename = MakeOutputFilename(descriptions[nonshared.index].input_filename,
+                                                        options.GetStringValue("output_posteriors_destination"),
+                                                        options.GetRealValue("gamma") < 0,
+                                                        shared.gamma);
+
+        inference_engine.ComputeOutsideESS();
+        inference_engine.ComputePosteriorESS();
+
+        RealT *posterior = inference_engine.GetPosterior(options.GetRealValue("output_posteriors_cutoff"));
+        SparseMatrix<RealT> sparse(posterior, sstruct.GetLength()+1, RealT(0));
+        delete [] posterior;
+        std::ofstream outfile(filename.c_str());
+        if (outfile.fail()) Error("Unable to open output posteriors file '%s' for writing.", filename.c_str());
+        sparse.PrintSparseBPSEQ(outfile, sstruct.GetSequences()[0]);
+        outfile.close();
+    }
+
+        for (int sample_ind = 0; sample_ind < 100; sample_ind++)
+            { 
+            solution = new SStruct(sstruct);
+            int seed = rand();
+            inference_engine.InitRand(seed);
+
+            solution->SetMapping(inference_engine.PredictPairingsStochasticTracebackESS());
+            solution->WriteParensOnly(std::cout);
+            delete solution;
+            }
+
+        break;
+    } else {
+        // continue
+        std::cerr << k << " " << curr_loss << std::endl;
+        std::cerr << "p_i " << unp_i << std::endl; 
+        std::cerr << "err " << error << std::endl;
+        last_loss_2 = last_loss_1;
+        last_loss_1 = last_loss_0;
+        last_loss_0 = curr_loss;
+
+        step_size /= 2;
+
+        inference_engine.UpdateREVIVec(update_unp, update_pr);
+    
+    }
+
+
+}
+}
 
 //////////////////////////////////////////////////////////////////////
 // ComputationEngine::Predict()
@@ -1244,6 +1515,8 @@ void ComputationEngine<RealT>::Predict(std::vector<RealT> &result,
         // Basically, add a ComputeViterbiESS and then call it to support this.
 
         inference_engine.ComputeViterbi();
+        inference_engine.ComputeViterbiFeatureCounts();
+
         if (options.GetBoolValue("partition_function_only"))
         {
             std::cout << "Viterbi score for \"" << descriptions[nonshared.index].input_filename << "\": " 
@@ -1344,6 +1617,66 @@ void ComputationEngine<RealT>::Predict(std::vector<RealT> &result,
     
     delete solution;
 }
+//////////////////////////////////////////////////////////////////////
+// ComputationEngine::Sample()
+//
+// Sample structures from predicted ensemble.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationEngine<RealT>::Sample(std::vector<RealT> &result, 
+                                       const SharedInfo<RealT> &shared,
+                                       const NonSharedInfo &nonshared)
+{
+    result.clear();
+    
+    // load sequence, with constraints if necessary
+    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
+    inference_engine.LoadSequence(sstruct);
+    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
+
+    // load parameters
+    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
+    inference_engine.LoadValues(w * shared.log_base);
+
+    inference_engine.UpdateEvidenceStructures();
+
+    // perform inference
+    SStruct *solution;
+
+    int N = options.GetIntValue("nsamples");
+
+    //inference_engine.ComputePosterior(); // do we need this
+
+    if (options.GetBoolValue("use_evidence"))
+    {
+        inference_engine.ComputeInsideESS();
+
+    for (int sample_ind = 0; sample_ind < N; sample_ind++) { 
+
+    solution = new SStruct(sstruct);
+    inference_engine.InitRand(sample_ind);
+
+    solution->SetMapping(inference_engine.PredictPairingsStochasticTracebackESS());
+    solution->WriteParensOnly(std::cout);
+    delete solution;
+    }
+
+    } else {
+        inference_engine.ComputeInside();
+    
+    for (int sample_ind = 0; sample_ind < N; sample_ind++) { 
+
+    solution = new SStruct(sstruct);
+    inference_engine.InitRand(sample_ind);
+
+    solution->SetMapping(inference_engine.PredictPairingsStochasticTraceback());
+    solution->WriteParensOnly(std::cout);
+    delete solution;
+    }
+    }
+
+}
 
 //////////////////////////////////////////////////////////////////////
 // ComputationEngine::MakeOutputFilename()
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.hpp b/./ComputationWrapper.hpp
index 1fe451b..13862ef 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.hpp
+++ b/./ComputationWrapper.hpp
@@ -52,6 +52,8 @@ public:
     RealT ComputeSolutionNormBound(const std::vector<int> &units, const std::vector<RealT> &C, RealT log_base);
     RealT ComputeGradientNormBound(const std::vector<int> &units, const std::vector<RealT> &C, RealT log_base);
     void Predict(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
+    void Sample(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
+    void RunREVI(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base, RealT sigma);
     RealT ComputeLoss(const std::vector<int> &units, const std::vector<RealT> &w, RealT log_base);
     RealT ComputeFunction(const std::vector<int> &units, const std::vector<RealT> &w, bool toggle_use_nonsmooth, bool toggle_use_loss, RealT log_base, RealT hyperparam_data);
     std::vector<RealT> ComputeGradient(const std::vector<int> &units, const std::vector<RealT> &w, bool toggle_use_nonsmooth, bool toggle_use_loss, RealT log_base, RealT hyperparam_data);
@@ -68,6 +70,7 @@ public:
     
     // for debugging
     void SanityCheckGradient(const std::vector<int> &units, const std::vector<RealT> &w);
+    void TestEnergies(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
 
     // getters
     const Options &GetOptions() const { return computation_engine.GetOptions(); }
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.ipp b/./ComputationWrapper.ipp
index 4a1fa43..f6d803b 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.ipp
+++ b/./ComputationWrapper.ipp
@@ -888,6 +888,118 @@ void ComputationWrapper<RealT>::Predict(const std::vector<int> &units,
     computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
 }
 
+//////////////////////////////////////////////////////////////////////
+// ComputationWrapper::Sample()
+//
+// Run sampling algorithm on each of the work units.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationWrapper<RealT>::Sample(const std::vector<int> &units,
+                                        const std::vector<RealT> &w,
+                                        RealT gamma,
+                                        RealT log_base)
+{
+    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
+    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
+
+    if (GetOptions().GetBoolValue("verbose_output"))
+    {
+        std::cerr << "Performing predictions with gamma=" << double(gamma) << "..." << std::endl;
+    }
+        
+    std::vector<RealT> ret;
+
+    shared_info.command = SAMPLE;
+    for (size_t i = 0; i < w.size(); i++)
+    {
+        shared_info.w[i] = w[i];
+    }
+    shared_info.gamma = gamma;
+    shared_info.log_base = log_base;
+    
+    nonshared_info.resize(units.size());
+    for (size_t i = 0; i < units.size(); i++)
+    {
+        nonshared_info[i].index = units[i];
+    }
+    
+    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
+}
+//////////////////////////////////////////////////////////////////////
+// ComputationWrapper::RunREVI()
+//
+// Run REVI on each of the work units.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationWrapper<RealT>::RunREVI(const std::vector<int> &units,
+                                        const std::vector<RealT> &w,
+                                        RealT gamma,
+                                        RealT log_base,
+                                        RealT sigma)
+{
+    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
+    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
+
+    if (GetOptions().GetBoolValue("verbose_output"))
+    {
+        std::cerr << "Performing predictions with gamma=" << double(gamma) << "..." << std::endl;
+    }
+        
+    std::vector<RealT> ret;
+
+    shared_info.command = REVI;
+    for (size_t i = 0; i < w.size(); i++)
+    {
+        shared_info.w[i] = w[i];
+    }
+    shared_info.gamma = gamma;
+    shared_info.log_base = log_base;
+    shared_info.sigma = sigma;
+    
+    nonshared_info.resize(units.size());
+    for (size_t i = 0; i < units.size(); i++)
+    {
+        nonshared_info[i].index = units[i];
+    }
+    
+    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
+}
+//////////////////////////////////////////////////////////////////////
+// ComputationWrapper::TestEnergies()
+//
+// Run energy test.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationWrapper<RealT>::TestEnergies(const std::vector<int> &units,
+                                        const std::vector<RealT> &w,
+                                        RealT gamma,
+                                        RealT log_base)
+{
+    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
+    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
+
+        
+    std::vector<RealT> ret;
+
+    shared_info.command = TEST_ENERGIES;
+    for (size_t i = 0; i < w.size(); i++)
+    {
+        shared_info.w[i] = w[i];
+    }
+    shared_info.gamma = gamma;
+    shared_info.log_base = log_base;
+    
+    nonshared_info.resize(units.size());
+    for (size_t i = 0; i < units.size(); i++)
+    {
+        nonshared_info[i].index = units[i];
+    }
+    
+    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
+}
 //////////////////////////////////////////////////////////////////////
 // ComputationWrapper::SanityCheckGradient()
 //
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Config.hpp b/./Config.hpp
index ea7a70a..775bccf 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Config.hpp
+++ b/./Config.hpp
@@ -179,6 +179,9 @@ const double MM_SMOOTHING = 1.0;
 #define PARAMS_EXTERNAL_LENGTH                     1
 #define PARAMS_EVIDENCE                            1  
 
+// Compile for using REVI or not
+#define USE_REVI									1
+
 /*
 #define PARAMS_BASE_PAIR                           1
 #define PARAMS_BASE_PAIR_DIST                      0
@@ -210,7 +213,7 @@ const double MM_SMOOTHING = 1.0;
 // (F) Miscellaneous model constants
 //////////////////////////////////////////////////////////////////////
 
-const int C_MIN_HAIRPIN_LENGTH = 0;
+const int C_MIN_HAIRPIN_LENGTH = 3;
 const int C_MAX_SINGLE_LENGTH = 30;
 
 const int D_MAX_HAIRPIN_LENGTH = 30;
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.cpp b/./Contrafold.cpp
index 992cf78..b574b23 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.cpp
+++ b/./Contrafold.cpp
@@ -17,6 +17,8 @@
 
 // constants
 const double GAMMA_DEFAULT = 6;
+const double KAPPA_DEFAULT = 1.0;
+const double SIGMA_DEFAULT = 1.0;
 const double REGULARIZATION_DEFAULT = 0;
 const int TRAIN_MAX_ITER_DEFAULT = 1000;
 const double HYPERPARAM_DATA_DEFAULT = 1;
@@ -30,12 +32,21 @@ void MakeFileDescriptions(const Options &options, const std::vector<std::string>
 template<class RealT>
 void RunGradientSanityCheck(const Options &options, const std::vector<FileDescription> &descriptions);
 
+template<class RealT>
+void RunEnergyTest(const Options &options, const std::vector<FileDescription> &descriptions);
+
 template<class RealT>
 void RunTrainingMode(const Options &options, const std::vector<FileDescription> &descriptions);
 
 template<class RealT>
 void RunPredictionMode(const Options &options, const std::vector<FileDescription> &descriptions);
 
+template<class RealT>
+void RunSampleMode(const Options &options, const std::vector<FileDescription> &descriptions);
+
+template<class RealT>
+void RunREVIMode(const Options &options, const std::vector<FileDescription> &descriptions);
+
 // default parameters
 #include "Defaults.ipp"
 
@@ -70,10 +81,20 @@ int main(int argc, char **argv)
     {
         RunGradientSanityCheck<double>(options, descriptions);
     }
+    else if (options.GetBoolValue("test_energies"))
+    {
+        RunEnergyTest<double>(options, descriptions);
+    }
     else if (options.GetStringValue("training_mode") != "")
     {
         RunTrainingMode<double>(options, descriptions);
     }
+    else if (options.GetBoolValue("run_sample_mode")){
+        RunSampleMode<double>(options, descriptions);
+    }
+    else if (options.GetBoolValue("run_revi_mode")){
+        RunREVIMode<double>(options, descriptions);
+    }
     else
     {
         RunPredictionMode<float>(options, descriptions);
@@ -93,7 +114,7 @@ int main(int argc, char **argv)
 void Usage(const Options &options)
 {
     std::cerr << std::endl
-              << "Usage: contrafold [predict|train|em-train] [OPTION]... INFILE(s)" << std::endl 
+              << "Usage: contrafold [predict|sample|train|em-train] [OPTION]... INFILE(s)" << std::endl 
               << std::endl
               << "       where [OPTION]...   is a list of zero or more optional arguments" << std::endl
               << "             INFILE(s)     is the name of the input BPSEQ, plain text, or FASTA file(s)" << std::endl 
@@ -122,9 +143,17 @@ void Usage(const Options &options)
               << "                           write posterior pairing probabilities to file or directory" << std::endl
               << "  --partition              compute the partition function or Viterbi score only" << std::endl
               << std::endl
+              << "Additional arguments for 'sample' mode:" <<std::endl
+              << "  --nsamples N             number of samples (default 100)" << std::endl
+              << "  --kappa k                weight to place on chemical mapping data (default 1.0)" << std::endl
+              << std::endl
+              << "Additional arguments for 'revi' mode:" <<std::endl
+              << "  --sigma S                weight to place on data vs. energy model" << std::endl
+              << std::endl
               << "Additional arguments for training (many input files may be specified):" << std::endl
               << "  --examplefile            read list of input files from provided text file (instead of as arguments)" << std::endl
               << "  --sanity                 perform gradient sanity check" << std::endl
+              << "  --test_energies          print energies.  Requires sequence and constraint string" << std::endl
               << "  --holdout F              use fraction F of training data for holdout cross-validation" << std::endl
               << "  --regularize C           perform BFGS training, using a single regularization coefficient C" << std::endl
               << "  --maxiter N              for single regularization coefficient the max number of iterations" << std::endl
@@ -168,6 +197,8 @@ void ParseArguments(int argc,
 {
     // register default options
     options.SetStringValue("training_mode", "");
+    options.SetBoolValue("run_sample_mode",false);
+    options.SetBoolValue("run_revi_mode",false);
 
     options.SetBoolValue("verbose_output", false);
     options.SetRealValue("log_base", 1.0);
@@ -179,6 +210,8 @@ void ParseArguments(int argc,
     options.SetBoolValue("centroid_estimator", false);
     options.SetBoolValue("use_evidence", false);
     options.SetRealValue("gamma", GAMMA_DEFAULT);
+    options.SetRealValue("kappa", KAPPA_DEFAULT);
+    options.SetRealValue("sigma", KAPPA_DEFAULT);
     options.SetStringValue("output_parens_destination", "");
     options.SetStringValue("output_bpseq_destination", "");
     options.SetRealValue("output_posteriors_cutoff", 0);
@@ -186,6 +219,7 @@ void ParseArguments(int argc,
     options.SetBoolValue("partition_function_only", false);
 
     options.SetBoolValue("gradient_sanity_check", false);
+    options.SetBoolValue("test_energies", false);
     options.SetRealValue("holdout_ratio", 0);
     options.SetRealValue("regularization_coefficient", REGULARIZATION_DEFAULT);
 
@@ -198,6 +232,7 @@ void ParseArguments(int argc,
     options.SetRealValue("s0", 0.0001);
     options.SetRealValue("s1", 0);
     options.SetRealValue("hyperparam_data",HYPERPARAM_DATA_DEFAULT);
+    options.SetIntValue("nsamples",100);
 
     // check for sufficient arguments
     if (argc < 2) Usage(options);
@@ -216,9 +251,17 @@ void ParseArguments(int argc,
     {
         options.SetStringValue("training_mode", "em-sgd");
     }
+    else if (!strcmp(argv[1], "sample"))
+    {
+        options.SetBoolValue("run_sample_mode",true);
+    }
+    else if (!strcmp(argv[1], "revi"))
+    {
+        options.SetBoolValue("run_revi_mode",true);
+    }
     else if (strcmp(argv[1], "predict"))
     {
-        Error("CONTRAfold must be run in either 'predict' or 'train' mode.");
+        Error("CONTRAfold must be run in either 'predict', 'train', or 'sample' mode.");
     }
 
     // go through remaining arguments
@@ -281,6 +324,22 @@ void ParseArguments(int argc,
                     Error("Unable to parse value after --gamma.");
                 options.SetRealValue("gamma", value);
             }
+            else if (!strcmp(argv[argno], "--kappa"))
+            {
+                if (argno == argc - 1) Error("Must specify chemical mapping reweighting parameter KAPPA after --kappa.");
+                double value;
+                if (!ConvertToNumber(argv[++argno], value))
+                    Error("Unable to parse value after --kappa.");
+                options.SetRealValue("kappa", value);
+            }
+            else if (!strcmp(argv[argno], "--sigma"))
+            {
+                if (argno == argc - 1) Error("Must specify data reweighting parameter SIGMA after --sigma.");
+                double value;
+                if (!ConvertToNumber(argv[++argno], value))
+                    Error("Unable to parse value after --sigma.");
+                options.SetRealValue("sigma", value);
+            }
             else if (!strcmp(argv[argno], "--parens"))
             {
                 if (argno == argc - 1) Error("Must specify output file or directory name after --parens.");
@@ -316,6 +375,10 @@ void ParseArguments(int argc,
             {
                 options.SetBoolValue("gradient_sanity_check", true);
             }
+            else if (!strcmp(argv[argno], "--test_energies"))
+            {
+                options.SetBoolValue("test_energies", true);
+            }
             else if (!strcmp(argv[argno], "--holdout"))
             {
                 if (argno == argc - 1) Error("Must specify holdout ratio F after --holdout.");
@@ -346,6 +409,16 @@ void ParseArguments(int argc,
                     Error("Max number of iterations should not be negative.");
                 options.SetIntValue("train_max_iter", value);
             }
+            else if (!strcmp(argv[argno], "--nsamples"))
+            {
+                if (argno == argc - 1) Error("Must specify number of samples after --nsamples.");
+                int value;
+                if (!ConvertToNumber(argv[++argno], value))
+                    Error("Unable to parse max number of iterations after --nsamples.");
+                if (value < 0)
+                    Error("Number of samples should not be negative.");
+                options.SetIntValue("nsamples", value);
+            }
             else if (!strcmp(argv[argno], "--hyperparam_data"))
             {
                 if (argno == argc - 1) Error("Must specify a value after --hyperparam_data.");
@@ -537,6 +610,83 @@ void MakeFileDescriptions(const Options &options,
     std::sort(descriptions.begin(), descriptions.end());
 
 }
+/////////////////////////////////////////////////////////////////
+// RunEnergyTest()
+//
+// Print energies for test sequence.
+/////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void RunEnergyTest(const Options &options,
+                            const std::vector<FileDescription> &descriptions)
+{
+    // The architecture of the code is somewhat complicated here, so
+    // here's a quick explanation:
+    // 
+    //    ParameterManager: associates each parameter of the model
+    //                      with a name and manages hyperparameter
+    //                      groups
+    //                     
+    //    InferenceEngine: performs application-specific
+    //                     (loss-augmented) inference
+    //
+    //    ComputationEngine: makes all necessary calls to dynamic
+    //                       programming routines for processing
+    //                       individual sequences and interfaces with
+    //                       distributed computation module
+    //
+    //    ComputationWrapper: provides a high-level interface for
+    //                        performing computations on groups of
+    //                        sequences
+    //
+    //    OuterOptimizationWrapper / InnerOptimizationWrapper:
+    //                        interface between computation routines
+    //                        and optimization routines
+    
+   ParameterManager<RealT> parameter_manager;
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),
+        options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+    inference_engine.RegisterParameters(parameter_manager);
+    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+    ComputationWrapper<RealT> computation_wrapper(computation_engine);
+    
+    // decide whether I'm a compute node or master node
+    if (computation_engine.IsComputeNode())
+    {
+        computation_engine.RunAsComputeNode();
+        return;
+    }
+
+    const std::string output_parens_destination = options.GetStringValue("output_parens_destination");
+    const std::string output_bpseq_destination = options.GetStringValue("output_bpseq_destination");
+    const std::string output_posteriors_destination = options.GetStringValue("output_posteriors_destination");
+
+    // load parameters
+    std::vector<RealT> w;
+
+    if (options.GetStringValue("parameter_filename") != "")
+    {
+        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
+    }
+    else
+    {
+#if PROFILE
+        w = GetDefaultProfileValues<RealT>();
+#else
+        if (options.GetBoolValue("allow_noncomplementary"))
+            w = GetDefaultNoncomplementaryValues<RealT>();
+        else
+            w = GetDefaultComplementaryValues<RealT>();
+#endif
+    }
+
+    
+        // create output directories for output files, if needed
+
+    computation_wrapper.TestEnergies(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"));
+    
+    computation_engine.StopComputeNodes();
+}
 
 /////////////////////////////////////////////////////////////////
 // RunGradientSanityCheck()
@@ -572,7 +722,8 @@ void RunGradientSanityCheck(const Options &options,
     //                        and optimization routines
     
     ParameterManager<RealT> parameter_manager;
-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),
+        options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
     inference_engine.RegisterParameters(parameter_manager);
     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
     ComputationWrapper<RealT> computation_wrapper(computation_engine);
@@ -614,7 +765,7 @@ void RunTrainingMode(const Options &options,
                      const std::vector<FileDescription> &descriptions)
 {
     ParameterManager<RealT> parameter_manager;
-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
     inference_engine.RegisterParameters(parameter_manager);
     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
     ComputationWrapper<RealT> computation_wrapper(computation_engine);
@@ -708,7 +859,7 @@ void RunPredictionMode(const Options &options,
                        const std::vector<FileDescription> &descriptions)
 {
     ParameterManager<RealT> parameter_manager;
-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
     inference_engine.RegisterParameters(parameter_manager);
     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
     ComputationWrapper<RealT> computation_wrapper(computation_engine);
@@ -793,3 +944,102 @@ void RunPredictionMode(const Options &options,
     }
     computation_engine.StopComputeNodes();
 }
+
+/////////////////////////////////////////////////////////////////
+// RunSampleMode()
+//
+// Run CONTRAfold in sample mode.
+/////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void RunSampleMode(const Options &options,
+                       const std::vector<FileDescription> &descriptions)
+{
+    ParameterManager<RealT> parameter_manager;
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+    inference_engine.RegisterParameters(parameter_manager);
+    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+    ComputationWrapper<RealT> computation_wrapper(computation_engine);
+    
+    // decide whether I'm a compute node or master node
+    if (computation_engine.IsComputeNode())
+    {
+        computation_engine.RunAsComputeNode();
+        return;
+    }
+
+    // const std::string output_parens_destination = options.GetStringValue("output_parens_destination");
+    // const std::string output_bpseq_destination = options.GetStringValue("output_bpseq_destination");
+    // const std::string output_posteriors_destination = options.GetStringValue("output_posteriors_destination");
+
+    // load parameters
+    std::vector<RealT> w;
+
+    if (options.GetStringValue("parameter_filename") != "")
+    {
+        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
+    }
+    else
+    {
+#if PROFILE
+        w = GetDefaultProfileValues<RealT>();
+#else
+        if (options.GetBoolValue("allow_noncomplementary"))
+            w = GetDefaultNoncomplementaryValues<RealT>();
+        else
+            w = GetDefaultComplementaryValues<RealT>();
+#endif
+    }
+
+        
+    computation_wrapper.Sample(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"));
+    
+    computation_engine.StopComputeNodes();
+}
+
+/////////////////////////////////////////////////////////////////
+// RunREVIMode()
+//
+// Run REVI.
+/////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void RunREVIMode(const Options &options,
+                       const std::vector<FileDescription> &descriptions)
+{
+    ParameterManager<RealT> parameter_manager;
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+    inference_engine.RegisterParameters(parameter_manager);
+    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+    ComputationWrapper<RealT> computation_wrapper(computation_engine);
+    
+    // decide whether I'm a compute node or master node
+    if (computation_engine.IsComputeNode())
+    {
+        computation_engine.RunAsComputeNode();
+        return;
+    }
+
+    // load parameters
+    std::vector<RealT> w;
+
+    if (options.GetStringValue("parameter_filename") != "")
+    {
+        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
+    }
+    else
+    {
+#if PROFILE
+        w = GetDefaultProfileValues<RealT>();
+#else
+        if (options.GetBoolValue("allow_noncomplementary"))
+            w = GetDefaultNoncomplementaryValues<RealT>();
+        else
+            w = GetDefaultComplementaryValues<RealT>();
+#endif
+    }
+
+    computation_wrapper.RunREVI(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"), options.GetRealValue("sigma"));
+    
+    computation_engine.StopComputeNodes();
+}
\ No newline at end of file
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.o b/./Contrafold.o
index 00a11ca..3f458d0 100644
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.o and b/./Contrafold.o differ
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.hpp b/./InferenceEngine.hpp
index 4818ec2..1f0295d 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.hpp
+++ b/./InferenceEngine.hpp
@@ -13,6 +13,7 @@
 #include "ParameterManager.hpp"
 #include "Utilities.hpp"
 #include "LogSpace.hpp"
+#include "rand.h"
 
 //////////////////////////////////////////////////////////////////////
 // class InferenceEngine
@@ -23,12 +24,14 @@ class InferenceEngine
 {
     static const double DATA_LOW_THRESH = 1e-7;  // used for the data so that log is not -Inf
 
+    const double kappa;
     const bool allow_noncomplementary;
     unsigned char char_mapping[256];
     int is_complementary[M+1][M+1];
     bool cache_initialized;
     ParameterManager<RealT> *parameter_manager;
-    
+    Die* die;
+
     int num_data_sources;
     // dimensions
     int L, SIZE;
@@ -307,7 +310,7 @@ class InferenceEngine
 public:
 
     // constructor and destructor
-    InferenceEngine(bool allow_noncomplementary, const int num_data_sources);
+    InferenceEngine(bool allow_noncomplementary, const int num_data_sources, const double kappa);
     ~InferenceEngine();
 
     // register params with the parameter manager
@@ -331,6 +334,9 @@ public:
     std::vector<int> PredictPairingsViterbi() const;
     std::vector<RealT> ComputeViterbiFeatureCounts();
 
+    void GetViterbiFeatures();
+    void GetViterbiFeaturesESS();
+
     // MEA inference
     void ComputeInside();
     RealT ComputeLogPartitionCoefficient() const;
@@ -340,6 +346,11 @@ public:
     std::vector<int> PredictPairingsPosterior(const RealT gamma) const;
     std::vector<int> PredictPairingsPosteriorCentroid(const RealT gamma) const;
     RealT *GetPosterior(const RealT posterior_cutoff) const;
+
+    // stoch traceback
+    void InitRand(unsigned int seed);
+    std::vector<int> PredictPairingsStochasticTraceback() const;
+    std::vector<int> PredictPairingsStochasticTracebackESS() const;
     
     // EM inference
     void ComputeInsideESS();
@@ -349,6 +360,13 @@ public:
     RealT ComputeLogPartitionCoefficientESS() const;
     std::vector<RealT> ComputeESS();    
 
+    //REVI
+    void UpdateREVIVec(std::vector<RealT> perturb_unpaired, std::vector<RealT> perturb_paired);
+    void InitializeREVIVec();
+    std::vector<RealT> GetREVIError(std::vector<RealT> p_i);
+    std::vector<std::vector<double> > GetREVIvec_up();
+    std::vector<std::vector<double> > GetREVIvec_pr();
+
     // Learning Evidence CPD
     RealT ComputeGammaMLESum(std::vector<int> ev_cpd_id, bool ignorePairing, bool usePosterior, int which_data);
     std::vector<RealT> ComputeGammaMLESS(std::vector<int> ev_cpd_id, bool ignoreZeros, bool useMLE, int which_data);
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.ipp b/./InferenceEngine.ipp
index def37bb..a32fb22 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.ipp
+++ b/./InferenceEngine.ipp
@@ -42,7 +42,7 @@ RealT InferenceEngine<RealT>::ScoreUnpairedPositionEvidence(int i) const
 {
    RealT sum = 0;
    for (int n = 0; n < num_data_sources; n++)
-       sum = sum + score_unpaired_position[n][i-1];
+       sum = sum + kappa*score_unpaired_position[n][i-1]; // FLAG: put scalar here
    return sum;
 }
 #else
@@ -59,7 +59,7 @@ RealT InferenceEngine<RealT>::ScorePairedPositionEvidence(int i) const
 {
    RealT sum = 0;
    for (int n = 0; n < num_data_sources; n++)
-       sum = sum + score_paired_position[n][i-1];
+       sum = sum + kappa*score_paired_position[n][i-1]; // FLAG: put scalar here
    return sum;
 }
 #else
@@ -307,11 +307,12 @@ bool InferenceEngine<RealT>::IsComplementary(int i, int j) const
 //////////////////////////////////////////////////////////////////////
 
 template<class RealT>
-InferenceEngine<RealT>::InferenceEngine(bool allow_noncomplementary, const int num_data_sources) :
+InferenceEngine<RealT>::InferenceEngine(bool allow_noncomplementary, const int num_data_sources, const double kappa) :
     allow_noncomplementary(allow_noncomplementary),
     cache_initialized(false),
     parameter_manager(NULL),
     num_data_sources(num_data_sources),
+    kappa(kappa),
     L(0),
     SIZE(0)
 #if PROFILE
@@ -946,6 +947,79 @@ double InferenceEngine<RealT>::LogGammaProb(RealT data, int which_data, int isUn
     return (k-1)*log(data) - data/theta - lgamma(k) - k*log(theta);
 }
 
+template<class RealT>
+void InferenceEngine<RealT>::UpdateREVIVec(std::vector<RealT> perturb_unpaired, std::vector<RealT> perturb_paired)
+{
+    int which_data = 0; // update if we ever want to do more than one
+
+    for (int i = 0; i < L; i++)
+    {
+        score_unpaired_position[which_data][i] += perturb_unpaired[i];
+        //score_paired_position[which_data][i] += perturb_paired[i];
+    }
+
+    std::cerr << "u_v " << score_unpaired_position[0] << std::endl;
+    std::cerr << "p_v " << score_paired_position[0] << std::endl;
+
+}
+
+template<class RealT>
+std::vector<std::vector<double> > InferenceEngine<RealT>::GetREVIvec_up()
+{
+    return score_unpaired_position;
+}
+
+template<class RealT>
+std::vector<std::vector<double> > InferenceEngine<RealT>::GetREVIvec_pr()
+{
+    return score_paired_position;
+}
+
+template<class RealT>
+std::vector<RealT> InferenceEngine<RealT>::GetREVIError(std::vector<RealT> p_i)
+{
+    int which_data = 0;
+    std::vector<RealT> error;
+
+     for (int i = 0; i < L; i++)
+     {
+
+        // analytical posterior
+    //     RealT pos_paired = 0;
+    //     // get paired posterior
+    //     for (int l = 1; l <= L; l++)
+    //     {
+    //             int offset1 = i <= l ? i : l;
+    //             int offset2 = i > l ? i : l;
+    //             if (i != l)
+    //                 pos_paired += posterior[offset[offset1]+offset2];
+    //     }
+    //     // if (i==1){
+    //     //     std::cerr << "pos_paired " << pos_paired << std::endl;
+    //     // }
+
+    // HWS: reintroduce when using reactivities instead of probabilities
+
+    // RealT k_pr = exp(log_score_evidence[which_data][0][s[i+1]][0].first);
+    // RealT theta_pr = exp(log_score_evidence[which_data][1][s[i+1]][0].first);
+    // RealT k_unp = exp(log_score_evidence[which_data][0][s[i+1]][1].first);
+    // RealT theta_unp = exp(log_score_evidence[which_data][1][s[i+1]][1].first);
+
+        // predict reactivity under this model
+        //RealT rhat = k_pr*theta_pr*(1-p_i[i]) + k_unp*theta_unp*p_i[i];
+        //score_unpaired_position_raw: where raw reacitivty data is stored
+
+        // fitting to raw diff in p(unp values)
+        RealT err = (p_i[i] - score_unpaired_position_raw[which_data][i]);
+
+        error.push_back(err);
+}
+    std::cerr << "sc_up_p_raw " << score_unpaired_position_raw[which_data] << std::endl;
+    return error;
+    
+}
+
+  
 
 //////////////////////////////////////////////////////////////////////
 // InferenceEngine::LoadSequence()
@@ -966,7 +1040,6 @@ void InferenceEngine<RealT>::LoadSequence(const SStruct &sstruct)
     SIZE2 = (L+1)*(L+1);
 #endif
 
-    
     // allocate memory
     s.resize(L+1);
 #if PROFILE
@@ -1120,8 +1193,23 @@ void InferenceEngine<RealT>::LoadSequence(const SStruct &sstruct)
     score_paired_position = 1-sstruct.GetPairedPotentials();  // probability of paired = 1 - probability of unpaired (NOTE: currently PairedPotentials returns the probability of unpaired, so need the "1-" in front
 #endif
 
+
 }
 
+template<class RealT>
+void InferenceEngine<RealT>::InitializeREVIVec()
+{    
+    score_unpaired_position[0].clear();
+    score_paired_position[0].clear();
+    for (int i = 0; i < num_data_sources; i++)
+    {
+        for (int j = 0; j < L; j++)
+    {
+    score_unpaired_position[i].push_back(RealT(0));
+    score_paired_position[i].push_back(RealT(0));
+    }
+}
+}
 
 template<class RealT>
 void InferenceEngine<RealT>::UpdateEvidenceStructures()
@@ -1148,6 +1236,7 @@ void InferenceEngine<RealT>::UpdateEvidenceStructures(int which_data)
     }
 }
 
+
 //////////////////////////////////////////////////////////////////////
 // InferenceEngine::InitializeCache()
 //
@@ -3929,9 +4018,8 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
 {
     std::queue<triple<int *,int,int> > traceback_queue;
     traceback_queue.push(make_triple(&F5t[0], 0, L));
-
     ClearCounts();
-    
+
     while (!traceback_queue.empty())
     {
         triple<int *,int,int> t = traceback_queue.front();
@@ -3947,6 +4035,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
         
         switch (traceback.first)
         {
+
 #if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
             case TB_FN_HAIRPIN: 
                 CountHairpin(i,j,RealT(1));
@@ -3956,6 +4045,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
                 const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
                 CountSingle(i,j,p,q,RealT(1));
+
                 traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
             }
             break;
@@ -3965,6 +4055,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 CountJunctionA(i,j,RealT(1));
                 CountMultiPaired(RealT(1));
                 CountMultiBase(RealT(1));
+
                 traceback_queue.push(make_triple(&FM1t[0], i, k));
                 traceback_queue.push(make_triple(&FMt[0], k, j));
             }
@@ -3973,6 +4064,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
             {
                 CountBasePair(i+1,j,RealT(1));
                 CountHelixStacking(i,j+1,RealT(1));
+
                 traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
             }
             break;
@@ -4001,9 +4093,11 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
             }
             break;
+
 #else
             case TB_FC_HAIRPIN: 
                 CountHairpin(i,j,RealT(1));
+
                 break;
             case TB_FC_SINGLE: 
             {
@@ -4018,6 +4112,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 else
                 {
                     CountSingle(i,j,p,q,RealT(1));
+
                 }
                 
                 traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
@@ -4029,6 +4124,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 CountJunctionA(i,j,RealT(1));
                 CountMultiPaired(RealT(1));
                 CountMultiBase(RealT(1));
+
                 traceback_queue.push(make_triple(&FM1t[0], i, k));
                 traceback_queue.push(make_triple(&FMt[0], k, j));
             }
@@ -4039,12 +4135,14 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 CountJunctionA(j,i,RealT(1));
                 CountMultiPaired(RealT(1));
                 CountBasePair(i+1,j,RealT(1));
+
                 traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
             }
             break;
             case TB_FM1_UNPAIRED:
             {
                 CountMultiUnpaired(i+1,RealT(1));
+
                 traceback_queue.push(make_triple(&FM1t[0], i+1, j));
             }
             break;
@@ -4058,6 +4156,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
             case TB_FM_UNPAIRED:
             {
                 CountMultiUnpaired(j,RealT(1));
+
                 traceback_queue.push(make_triple(&FMt[0], i, j-1));
             }
             break;
@@ -4068,25 +4167,706 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 break;
             case TB_F5_UNPAIRED:
                 CountExternalUnpaired(j,RealT(1));
+
+                traceback_queue.push(make_triple(&F5t[0], 0, j-1));
+                break;
+            case TB_F5_BIFURCATION:
+            {
+                const int k = traceback.second;
+                CountExternalPaired(RealT(1));
+                CountBasePair(k+1,j,RealT(1));
+                CountJunctionA(j,k,RealT(1));
+                traceback_queue.push(make_triple(&F5t[0], 0, k));
+                traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
+
+
+            }
+            break;
+            default:
+                Assert(false, "Bad traceback.");
+        }
+    }
+
+    FinalizeCounts();
+    return GetCounts();
+}
+
+//////////////////////////////////////////////////////////////////////
+// InferenceEngine::GetViterbiFeatures()
+// 
+// Use feature counts from Viterbi decoding.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void InferenceEngine<RealT>::GetViterbiFeatures()
+{
+    std::queue<triple<int *,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(&F5t[0], 0, L));
+
+    std::vector<triple<int, int, int> > multiloops;
+    ClearCounts();
+
+    std::map<int, RealT> eos_cb_map;
+    for (int k = -1; k <= L; k++){
+        eos_cb_map[k] = 0;
+    }
+
+    while (!traceback_queue.empty())
+    {
+        triple<int *,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int *V = t.first;
+        const int i = t.second;
+        const int j = t.third;
+        
+        std::pair<int,int> traceback = DecodeTraceback (V == &F5t[0] ? V[j] : V[offset[i]+j]);
+        
+        //std::cout << (V == FCt ? "FC " : V == FMt ? "FM " : V == FM1t ? "FM1 " : "F5 ");
+        //std::cout << i << " " << j << ": " << traceback.first << " " << traceback.second << std::endl;
+        
+        switch (traceback.first)
+        {
+
+    // HWS: we're not using these params
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case TB_FN_HAIRPIN: 
+                CountHairpin(i,j,RealT(1));
+                break;
+            case TB_FN_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                CountSingle(i,j,p,q,RealT(1));
+
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FN_BIFURCATION:
+            {
+                const int k = traceback.second;
+                CountJunctionA(i,j,RealT(1));
+                CountMultiPaired(RealT(1));
+                CountMultiBase(RealT(1));
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FE_STACKING: 
+            {
+                CountBasePair(i+1,j,RealT(1));
+                CountHelixStacking(i,j+1,RealT(1));
+
+                traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
+            }
+            break;
+            case TB_FE_FN: 
+            {
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_FN:
+            {
+                CountIsolated(RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_HELIX:
+            {
+                const int m = traceback.second;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i+m-1, j-m+1));
+            }
+            break;
+            case TB_FC_FE:
+            {
+                const int m = D_MAX_HELIX_LENGTH;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
+            }
+            break;
+
+    //HWS: our param sections start here
+#else
+            case TB_FC_HAIRPIN: 
+                //CountHairpin(i,j,RealT(1));
+                //////////////////////////////////////////////////////////////////////
+                // InferenceEngine::ScoreHairpin()
+                // InferenceEngine::CountHairpin()
+                //
+                // Returns the score for a hairpin spanning positions i to j.
+                //
+                // In an RNA structure, this would look like
+                //
+                //                           ...
+                //                       /         \. 
+                //                   x[i+2]       x[j-1]
+                //                      |            |
+                //                   x[i+1]        x[j]
+                // position i -------->  o          o  <----- position j
+                //                      x[i] -- x[j+1]
+                //                        |        |
+                //                     x[i-1] -- x[j+2]
+                //
+                //////////////////////////////////////////////////////////////////////
+
+                //HWS: subtracting off 1 to get zero-indexing for eos_cb
+
+                //std::cerr << "Hairpin " << i-1 << " " << ScoreHairpin(i,j) << std::endl;
+                eos_cb_map[i-1] += ScoreHairpin(i,j);
+
+                break;
+            case TB_FC_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+
+                if (p == i && q == j)
+                {
+                    // CountBasePair(i+1,j,RealT(1));
+                    // CountHelixStacking(i,j+1,RealT(1));
+
+                //HWS: subtracting off 1 (from i+1) to get zero-indexing for eos_cb
+
+
+                //std::cerr << "BasePair " << i << " " << ScoreBasePair(i+1,j) << std::endl;
+                eos_cb_map[i] += ScoreBasePair(i+1,j);
+
+
+                // ScoreHelixStacking(i,j): score for a helix stacking pair of the form:
+                //
+                //       |         |
+                //    s[i+1] == s[j-1]
+                //       |         |
+                //     s[i] ==== s[j]
+                //       |         |
+                //HWS: subtracting off 1 (from i) to get zero-indexing for eos_cb
+
+                //std::cerr << "HelixStacking " << i-1 << " " << ScoreHelixStacking(i,j+1) << std::endl;
+                eos_cb_map[i-1] += ScoreHelixStacking(i,j+1);
+
+                }
+                else
+                {
+                    //CountSingle(i,j,p,q,RealT(1));
+                    //here we need to break this down because they sum a bunch of things to make ScoreSingle
+                    // here we need to subtract off the second base pair from ScoreSingle
+                // std::cerr << "Single " << i-1 << " " << ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q) << std::endl;
+                // std::cerr << "ScoreBasePair " << p << " " << ScoreBasePair(p+1,q) << std::endl;
+
+                eos_cb_map[i-1] += ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q);
+                eos_cb_map[p] += ScoreBasePair(p+1, q);
+
+                }
+                
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FC_BIFURCATION:
+            {
+                const int k = traceback.second;
+                // CountJunctionA(i,j,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountMultiBase(RealT(1));
+
+                // This is where we first recognize we're in a new multiloop. Store the things at i
+                multiloops.push_back(make_triple(i,j,0));
+                // std::cerr << "New multiloop! " << i << ":" << j << std::endl;
+
+                // std::cerr << "FCBifurc:JunctionA " << i << " " << ScoreJunctionA(i,j) << std::endl;
+                // std::cerr << "FCBifurc:MultiPaired " << i << " " << ScoreMultiPaired() << std::endl;
+                // std::cerr << "FCBifurc:MultiBase " << i << " " << ScoreMultiBase() << std::endl;
+
+                eos_cb_map[i] += ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+#endif
+            case TB_FM1_PAIRED:
+            {
+                // CountJunctionA(j,i,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountBasePair(i+1,j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i < multiloops[ind].second){
+                        if (i - multiloops[ind].first < min_dist){
+                            min_dist = i - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+
+                // These all go in the multiloop ind
+                //std::cerr << "Paired:JunctionA " << curr_multiloop_ind << " " << ScoreJunctionA(j,i) << std::endl;
+                //std::cerr << "Paired:MultiPaired " << curr_multiloop_ind << " " << ScoreMultiPaired() << std::endl;
+                
+                eos_cb_map[curr_multiloop_ind] += ScoreJunctionA(j,i) + ScoreMultiPaired();
+
+                //This just goes with the next base pair
+                //std::cerr << "Paired:BasePair " << i << " " << ScoreBasePair(i+1, j) << std::endl;
+                eos_cb_map[i] += ScoreBasePair(i+1, j);
+
+                traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
+            }
+            break;
+            case TB_FM1_UNPAIRED:
+            {
+                // CountMultiUnpaired(i+1,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i+1 < multiloops[ind].second){
+                        if (i+1 - multiloops[ind].first < min_dist){
+                            min_dist = i+1 - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(i+1) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpaired(i+1);
+
+                traceback_queue.push(make_triple(&FM1t[0], i+1, j));
+            }
+            break;
+            case TB_FM_BIFURCATION:
+            {
+                const int k = traceback.second;
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FM_UNPAIRED:
+            {
+                // CountMultiUnpaired(j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < j < multiloops[ind].second){
+                        if (j - multiloops[ind].first < min_dist){
+                            min_dist = j - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(j) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpaired(j);
+
+                traceback_queue.push(make_triple(&FMt[0], i, j-1));
+            }
+            break;
+            case TB_FM_FM1: 
+                traceback_queue.push(make_triple(&FM1t[0], i, j));
+                break;
+            case TB_F5_ZERO:
+                break;
+            case TB_F5_UNPAIRED:
+                CountExternalUnpaired(j,RealT(1));
+
+                // HWS: a score for unpaired things in the external loop, dump into the -1 eos_cb
+
+                //std::cerr << "ExternalUnpaired -1 " << ScoreExternalUnpaired(j) << std::endl;
+                eos_cb_map[-1] += ScoreExternalUnpaired(j);
+
+                traceback_queue.push(make_triple(&F5t[0], 0, j-1));
+                break;
+            case TB_F5_BIFURCATION:
+            {
+                const int k = traceback.second;
+                // CountExternalPaired(RealT(1));
+                // CountBasePair(k+1,j,RealT(1));
+                // CountJunctionA(j,k,RealT(1));
+                traceback_queue.push(make_triple(&F5t[0], 0, k));
+                traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
+
+                //HWS: this is base pairs facing external loop. Hard-coding to print -1 as thinking these 
+                //should get summed in to the -1 "external loop " eos_cb category
+                
+                //std::cerr << "F5Bifurc:ExternalPaired -1 " << ScoreExternalPaired() << std::endl;
+                //std::cerr << "F5Bifurc:JunctionA -1 " << ScoreJunctionA(j,k) << std::endl;
+                eos_cb_map[-1] += ScoreExternalPaired()+ScoreJunctionA(j,k);
+
+                // HWS: another base pair, print (k+1) - 1 to zero-index
+                //std::cerr << "F5Bifurc:BasePair " << k << " " << ScoreBasePair(k+1, j) << std::endl;
+                eos_cb_map[k] += ScoreBasePair(k+1, j);
+
+            }
+            break;
+            default:
+                Assert(false, "Bad traceback.");
+        }
+    }
+    RealT local_sum = 0;
+    std::cerr << "EOS_CB: ";
+    for (std::pair<int, RealT> element : eos_cb_map) {
+        if (element.first == -1 || element.second != 0){
+        std::cerr << element.first << ", " << element.second << ", ";
+        local_sum += element.second;
+    }
+    }
+    std::cerr << std::endl;
+    std::cerr << "local sum " << local_sum << std::endl;
+
+}
+
+//////////////////////////////////////////////////////////////////////
+// InferenceEngine::GetViterbiFeaturesESS()
+// 
+// Use feature counts from Viterbi decoding, using evidence-based energies.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void InferenceEngine<RealT>::GetViterbiFeaturesESS()
+{
+    std::queue<triple<int *,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(&F5t[0], 0, L));
+
+    std::vector<triple<int, int, int> > multiloops;
+    ClearCounts();
+
+    std::map<int, RealT> eos_cb_map;
+    for (int k = -1; k <= L; k++){
+        eos_cb_map[k] = 0;
+    }
+
+    while (!traceback_queue.empty())
+    {
+        triple<int *,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int *V = t.first;
+        const int i = t.second;
+        const int j = t.third;
+        
+        std::pair<int,int> traceback = DecodeTraceback (V == &F5t[0] ? V[j] : V[offset[i]+j]);
+        
+        //std::cout << (V == FCt ? "FC " : V == FMt ? "FM " : V == FM1t ? "FM1 " : "F5 ");
+        //std::cout << i << " " << j << ": " << traceback.first << " " << traceback.second << std::endl;
+        
+        switch (traceback.first)
+        {
+
+    // HWS: we're not using these params
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case TB_FN_HAIRPIN: 
+                CountHairpin(i,j,RealT(1));
+                break;
+            case TB_FN_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                CountSingle(i,j,p,q,RealT(1));
+
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FN_BIFURCATION:
+            {
+                const int k = traceback.second;
+                CountJunctionA(i,j,RealT(1));
+                CountMultiPaired(RealT(1));
+                CountMultiBase(RealT(1));
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FE_STACKING: 
+            {
+                CountBasePair(i+1,j,RealT(1));
+                CountHelixStacking(i,j+1,RealT(1));
+
+                traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
+            }
+            break;
+            case TB_FE_FN: 
+            {
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_FN:
+            {
+                CountIsolated(RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_HELIX:
+            {
+                const int m = traceback.second;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i+m-1, j-m+1));
+            }
+            break;
+            case TB_FC_FE:
+            {
+                const int m = D_MAX_HELIX_LENGTH;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
+            }
+            break;
+
+    //HWS: our param sections start here
+#else
+            case TB_FC_HAIRPIN: 
+                //CountHairpin(i,j,RealT(1));
+                //////////////////////////////////////////////////////////////////////
+                // InferenceEngine::ScoreHairpin()
+                // InferenceEngine::CountHairpin()
+                //
+                // Returns the score for a hairpin spanning positions i to j.
+                //
+                // In an RNA structure, this would look like
+                //
+                //                           ...
+                //                       /         \. 
+                //                   x[i+2]       x[j-1]
+                //                      |            |
+                //                   x[i+1]        x[j]
+                // position i -------->  o          o  <----- position j
+                //                      x[i] -- x[j+1]
+                //                        |        |
+                //                     x[i-1] -- x[j+2]
+                //
+                //////////////////////////////////////////////////////////////////////
+
+                //HWS: subtracting off 1 to get zero-indexing for eos_cb
+
+                //std::cerr << "Hairpin " << i-1 << " " << ScoreHairpin(i,j) << std::endl;
+                eos_cb_map[i-1] += ScoreHairpinEvidence(i,j);
+
+                break;
+            case TB_FC_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+
+                if (p == i && q == j)
+                {
+                    // CountBasePair(i+1,j,RealT(1));
+                    // CountHelixStacking(i,j+1,RealT(1));
+
+                //HWS: subtracting off 1 (from i+1) to get zero-indexing for eos_cb
+
+
+                //std::cerr << "BasePair " << i << " " << ScoreBasePair(i+1,j) << std::endl;
+                eos_cb_map[i] += ScoreBasePairEvidence(i+1,j);
+
+
+                // ScoreHelixStacking(i,j): score for a helix stacking pair of the form:
+                //
+                //       |         |
+                //    s[i+1] == s[j-1]
+                //       |         |
+                //     s[i] ==== s[j]
+                //       |         |
+                //HWS: subtracting off 1 (from i) to get zero-indexing for eos_cb
+
+                //std::cerr << "HelixStacking " << i-1 << " " << ScoreHelixStacking(i,j+1) << std::endl;
+                eos_cb_map[i-1] += ScoreHelixStacking(i,j+1);
+
+                }
+                else
+                {
+                    //CountSingle(i,j,p,q,RealT(1));
+                    //here we need to break this down because they sum a bunch of things to make ScoreSingle
+                    // here we need to subtract off the second base pair from ScoreSingle
+                // std::cerr << "Single " << i-1 << " " << ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q) << std::endl;
+                // std::cerr << "ScoreBasePair " << p << " " << ScoreBasePair(p+1,q) << std::endl;
+
+                eos_cb_map[i-1] += ScoreSingleEvidence(i,j,p,q)-ScoreBasePairEvidence(p+1,q);
+                eos_cb_map[p] += ScoreBasePairEvidence(p+1, q);
+
+                }
+                
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FC_BIFURCATION:
+            {
+                const int k = traceback.second;
+                // CountJunctionA(i,j,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountMultiBase(RealT(1));
+
+                // This is where we first recognize we're in a new multiloop. Store the things at i
+                multiloops.push_back(make_triple(i,j,0));
+                // std::cerr << "New multiloop! " << i << ":" << j << std::endl;
+
+                // std::cerr << "FCBifurc:JunctionA " << i << " " << ScoreJunctionA(i,j) << std::endl;
+                // std::cerr << "FCBifurc:MultiPaired " << i << " " << ScoreMultiPaired() << std::endl;
+                // std::cerr << "FCBifurc:MultiBase " << i << " " << ScoreMultiBase() << std::endl;
+
+                eos_cb_map[i] += ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+#endif
+            case TB_FM1_PAIRED:
+            {
+                // CountJunctionA(j,i,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountBasePair(i+1,j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i < multiloops[ind].second){
+                        if (i - multiloops[ind].first < min_dist){
+                            min_dist = i - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+
+                // These all go in the multiloop ind
+                //std::cerr << "Paired:JunctionA " << curr_multiloop_ind << " " << ScoreJunctionA(j,i) << std::endl;
+                //std::cerr << "Paired:MultiPaired " << curr_multiloop_ind << " " << ScoreMultiPaired() << std::endl;
+                
+                eos_cb_map[curr_multiloop_ind] += ScoreJunctionA(j,i) + ScoreMultiPaired();
+
+                //This just goes with the next base pair
+                //std::cerr << "Paired:BasePair " << i << " " << ScoreBasePair(i+1, j) << std::endl;
+                eos_cb_map[i] += ScoreBasePairEvidence(i+1, j);
+
+                traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
+            }
+            break;
+            case TB_FM1_UNPAIRED:
+            {
+                // CountMultiUnpaired(i+1,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i+1 < multiloops[ind].second){
+                        if (i+1 - multiloops[ind].first < min_dist){
+                            min_dist = i+1 - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(i+1) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpairedEvidence(i+1);
+
+                traceback_queue.push(make_triple(&FM1t[0], i+1, j));
+            }
+            break;
+            case TB_FM_BIFURCATION:
+            {
+                const int k = traceback.second;
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FM_UNPAIRED:
+            {
+                // CountMultiUnpaired(j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < j < multiloops[ind].second){
+                        if (j - multiloops[ind].first < min_dist){
+                            min_dist = j - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(j) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpairedEvidence(j);
+
+                traceback_queue.push(make_triple(&FMt[0], i, j-1));
+            }
+            break;
+            case TB_FM_FM1: 
+                traceback_queue.push(make_triple(&FM1t[0], i, j));
+                break;
+            case TB_F5_ZERO:
+                break;
+            case TB_F5_UNPAIRED:
+                CountExternalUnpaired(j,RealT(1));
+
+                // HWS: a score for unpaired things in the external loop, dump into the -1 eos_cb
+
+                //std::cerr << "ExternalUnpaired -1 " << ScoreExternalUnpaired(j) << std::endl;
+                eos_cb_map[-1] += ScoreExternalUnpairedEvidence(j);
+
                 traceback_queue.push(make_triple(&F5t[0], 0, j-1));
                 break;
             case TB_F5_BIFURCATION:
             {
                 const int k = traceback.second;
-                CountExternalPaired(RealT(1));
-                CountBasePair(k+1,j,RealT(1));
-                CountJunctionA(j,k,RealT(1));
+                // CountExternalPaired(RealT(1));
+                // CountBasePair(k+1,j,RealT(1));
+                // CountJunctionA(j,k,RealT(1));
                 traceback_queue.push(make_triple(&F5t[0], 0, k));
                 traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
+
+                //HWS: this is base pairs facing external loop. Hard-coding to print -1 as thinking these 
+                //should get summed in to the -1 "external loop " eos_cb category
+                
+                //std::cerr << "F5Bifurc:ExternalPaired -1 " << ScoreExternalPaired() << std::endl;
+                //std::cerr << "F5Bifurc:JunctionA -1 " << ScoreJunctionA(j,k) << std::endl;
+                eos_cb_map[-1] += ScoreExternalPaired()+ScoreJunctionA(j,k); //TODO: ScoreExternalPairedEvidence
+ 
+                // HWS: another base pair, print (k+1) - 1 to zero-index
+                //std::cerr << "F5Bifurc:BasePair " << k << " " << ScoreBasePair(k+1, j) << std::endl;
+                eos_cb_map[k] += ScoreBasePairEvidence(k+1, j);
+
             }
             break;
             default:
                 Assert(false, "Bad traceback.");
         }
     }
+    RealT local_sum = 0;
+    std::cerr << "EOS_CB: ";
+    for (std::pair<int, RealT> element : eos_cb_map) {
+        if (element.first == -1 || element.second != 0){
+        std::cerr << element.first << ", " << element.second << ", ";
+        local_sum += element.second;
+    }
+    }
+    std::cerr << std::endl;
+    std::cerr << "local sum " << local_sum << std::endl;
 
-    FinalizeCounts();
-    return GetCounts();
 }
 
 //////////////////////////////////////////////////////////////////////
@@ -5938,7 +6718,6 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
     //double starting_time = GetSystemTime();
 
     const RealT Z = ComputeLogPartitionCoefficientESS();
-
     
     for (int i = L; i >= 0; i--)
     {
@@ -5992,7 +6771,7 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
                 
                 if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
                     CountHairpinEvidence(i,j,Fast_Exp(outside + ScoreHairpinEvidence(i,j)));
-                
+
                 // compute SUM (i<=p<p+2<=q<=j, p-i+j-q>0 : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
                 
 #if !FAST_SINGLE_BRANCH_LOOPS
@@ -6128,8 +6907,12 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
                 // compute ScoreHairpin(i,j)
                 
                 if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
+                {
                     CountHairpinEvidence(i,j,Fast_Exp(outside + ScoreHairpinEvidence(i,j)));
-                
+                                  //  std::cerr << ScoreHairpinEvidence(i,j) << std::endl; HWS
+
+                }
+
                 // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
                 
 #if !FAST_SINGLE_BRANCH_LOOPS
@@ -7716,8 +8499,8 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeGammaMLESS(std::vector<int> ev
     RealT sum1 = 0;
     RealT sum2 = 0;
     int N = 0;
-    int i = ev_cpd_id[0];
-    int j = ev_cpd_id[1];
+    int i = ev_cpd_id[0]; // nucleotide type
+    int j = ev_cpd_id[1]; // paired or unpaired
 
     double score_up = 0;
 
@@ -7911,3 +8694,497 @@ int InferenceEngine<RealT>::AreZerosInSeq(int id_base, int which_data)
     return areZeros;
 }
 
+template<class RealT>
+void InferenceEngine<RealT>::InitRand(unsigned int seed)
+{
+    if (die) delete die;
+    die = new Die(seed);
+}
+
+// stochastic traceback algorithm
+template<class RealT>
+std::vector<int> InferenceEngine<RealT>::PredictPairingsStochasticTraceback() const
+{
+    enum { ST_FC, ST_F5, ST_FM, ST_FM1, ST_FE, ST_FN };
+
+    std::vector<int> solution(L+1,SStruct::UNPAIRED);
+    solution[0] = SStruct::UNKNOWN;
+
+    std::queue<triple<int,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(int(ST_F5), 0, L));
+
+    while (!traceback_queue.empty())
+    {
+        triple<int,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int i = t.second;
+        const int j = t.third;
+        int L2 = L; // ed to remove max bp dist
+
+        switch (t.first)
+        {
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case ST_FC:
+                break;
+            case ST_FE:
+                break;
+            case ST_FN:
+                break;
+#else
+            case ST_FC:
+            {
+                if (0 < i && j < L2 && allow_paired[offset[i]+j+1]) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+                
+                    // compute ScoreHairpin(i,j)
+                    if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
+                        roulette.add(EncodeTraceback(TB_FC_HAIRPIN,0), ScoreHairpin(i,j));
+                
+                    // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
+                    for (int p = i; p <= std::min(i+C_MAX_SINGLE_LENGTH,j); p++)
+                    {
+                        if (p > i && !allow_unpaired_position[p]) break;
+                        int q_min = std::max(p+2,p-i+j-C_MAX_SINGLE_LENGTH);
+                        for (int q = j; q >= q_min; q--)
+                        {
+                            if (q < j && !allow_unpaired_position[q+1]) break;
+                            if (!allow_paired[offset[p+1]+q]) continue;
+
+                            if (p == i && q == j)
+                            {
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                             ScoreBasePair(i+1,j) + ScoreHelixStacking(i,j+1) +
+                                             FCi[offset[p+1]+q-1]);
+                            }
+                            else
+                            {
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                             ScoreSingle(i,j,p,q) + FCi[offset[p+1]+q-1]);
+                            }
+                        }
+                    }
+
+                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j] + ScoreJunctionA(i,j) + a + c)
+                    for (int k=i+1; k < j; k++)
+                    {
+                        RealT FM2i = FM1i[offset[i]+k] + FMi[offset[k]+j];
+                        RealT val = FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+                        roulette.add(EncodeTraceback(TB_FC_BIFURCATION, k), val);
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FC_HAIRPIN: 
+                            break;
+                        case TB_FC_SINGLE: 
+                        {
+                            const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                            const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                            solution[p+1] = q;
+                            solution[q] = p+1;
+                            traceback_queue.push(make_triple(int(ST_FC), p+1, q-1));
+                        }
+                        break;
+                        case TB_FC_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                            traceback_queue.push(make_triple(int(ST_FM), k, j));
+                        }
+                        break;
+                    }
+                } //else { Assert(!, "unreachable"); }
+            } 
+            break;
+#endif
+
+            case ST_FM:
+                if (0 < i && i+2 <= j && j < L2) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j]) 
+                    for (int k=i+1; k < j; k++)
+                    {
+                        RealT FM2i = FM1i[offset[i]+k] + FMi[offset[k]+j];
+                        roulette.add(EncodeTraceback(TB_FM_BIFURCATION, k), FM2i);
+                    }
+
+                    // compute FM[i,j-1] + b
+                    if (allow_unpaired_position[j])
+                    {
+                        roulette.add(EncodeTraceback(TB_FM_UNPAIRED,0),
+                                     FMi[offset[i]+j-1] + ScoreMultiUnpaired(j));
+                    }
+
+                    // compute FM1[i,j]
+                    roulette.add(EncodeTraceback(TB_FM_FM1,0), FM1i[offset[i]+j]);
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FM_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                            traceback_queue.push(make_triple(int(ST_FM), k, j));
+                        }
+                        break;
+                        case TB_FM_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM), i, j-1));
+                        }
+                        break;
+                        case TB_FM_FM1: 
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM1), i, j));
+                        }
+                        break;
+                    }
+                
+                } //else { Assert(!, "unreachable"); }
+                break;
+
+            case ST_FM1:
+                if (0 < i && i+2 <= j && j < L2) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
+                    if (allow_paired[offset[i+1]+j])
+                    {
+                        RealT value = FCi[offset[i+1]+j-1] + ScoreJunctionA(j,i) +
+                            ScoreMultiPaired() + ScoreBasePair(i+1,j);
+                        roulette.add(EncodeTraceback(TB_FM1_PAIRED, 0), value);
+                    }
+                
+                    // compute FM1[i+1,j] + b
+                    if (allow_unpaired_position[i+1])
+                    {
+                        roulette.add(EncodeTraceback(TB_FM1_UNPAIRED,0),
+                                     FM1i[offset[i+1]+j] + ScoreMultiUnpaired(i+1));
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FM1_PAIRED:
+                        {
+                            solution[i+1] = j;
+                            solution[j] = i+1;
+                            traceback_queue.push(make_triple(int(ST_FC), i+1, j-1));
+                        }
+                        break;
+                        case TB_FM1_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM1), i+1, j));
+                        }
+                        break;
+                    }
+                } //else { Assert(!, "unreachable"); }
+                break;
+
+            case ST_F5:
+                if (j!=0)
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute F5[j-1] + ScoreExternalUnpaired()
+                    if (allow_unpaired_position[j])
+                    {
+                        roulette.add(EncodeTraceback(TB_F5_UNPAIRED,0),
+                                     F5i[j-1] + ScoreExternalUnpaired(j));
+                    }
+        
+                    // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
+                    int l = 0; // ed remove max bp dist
+                    for (int k = l; k < j; k++)
+                    {
+                        if (allow_paired[offset[k+1]+j])
+                        {
+                            RealT value = F5i[k] + FCi[offset[k+1]+j-1] + ScoreExternalPaired() +
+                                ScoreBasePair(k+1,j) + ScoreJunctionA(j,k);
+                            roulette.add(EncodeTraceback(TB_F5_BIFURCATION,k), value);
+                        }      
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_F5_ZERO:
+                            break;
+                        case TB_F5_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_F5), 0, j-1));
+                        }
+                        break;
+                        case TB_F5_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            solution[k+1] = j;
+                            solution[j] = k+1;
+                            traceback_queue.push(make_triple(int(ST_F5), 0, k));
+                            traceback_queue.push(make_triple(int(ST_FC), k+1, j-1));
+                        }
+                        break;
+                    }
+                }
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    return solution;
+}
+
+// stochastic traceback algorithm with chemical mapping data
+template<class RealT>
+std::vector<int> InferenceEngine<RealT>::PredictPairingsStochasticTracebackESS() const
+{
+    enum { ST_FC, ST_F5, ST_FM, ST_FM1, ST_FE, ST_FN };
+
+    std::vector<int> solution(L+1,SStruct::UNPAIRED);
+    solution[0] = SStruct::UNKNOWN;
+
+    std::queue<triple<int,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(int(ST_F5), 0, L));
+
+    while (!traceback_queue.empty())
+    {
+        triple<int,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int i = t.second;
+        const int j = t.third;
+        int L2 = L; // ed to remove max bp dist
+
+        switch (t.first)
+        {
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case ST_FC:
+                break;
+            case ST_FE:
+                break;
+            case ST_FN:
+                break;
+#else
+            case ST_FC:
+            {
+                if (0 < i && j < L2 && allow_paired[offset[i]+j+1]) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+                
+                    // compute ScoreHairpin(i,j)
+                    if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
+                        roulette.add(EncodeTraceback(TB_FC_HAIRPIN,0), ScoreHairpinEvidence(i,j));
+                
+                    // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
+                    for (int p = i; p <= std::min(i+C_MAX_SINGLE_LENGTH,j); p++)
+                    {
+                        if (p > i && !allow_unpaired_position[p]) break;
+                        int q_min = std::max(p+2,p-i+j-C_MAX_SINGLE_LENGTH);
+                        for (int q = j; q >= q_min; q--)
+                        {
+                            if (q < j && !allow_unpaired_position[q+1]) break;
+                            if (!allow_paired[offset[p+1]+q]) continue;
+
+                            if (p == i && q == j)
+                            {
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                             ScoreBasePairEvidence(i+1,j) + ScoreHelixStacking(i,j+1) +
+                                             FCi_ess[offset[p+1]+q-1]);
+                            }
+                            else
+                            {
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                             ScoreSingleEvidence(i,j,p,q) + FCi_ess[offset[p+1]+q-1]);
+                            }
+                        }
+                    }
+
+                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j] + ScoreJunctionA(i,j) + a + c)
+                    for (int k=i+1; k < j; k++)
+                    {
+                        RealT FM2i = FM1i_ess[offset[i]+k] + FMi_ess[offset[k]+j];
+                        RealT val = FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+                        roulette.add(EncodeTraceback(TB_FC_BIFURCATION, k), val);
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FC_HAIRPIN: 
+                            break;
+                        case TB_FC_SINGLE: 
+                        {
+                            const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                            const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                            solution[p+1] = q;
+                            solution[q] = p+1;
+                            traceback_queue.push(make_triple(int(ST_FC), p+1, q-1));
+                        }
+                        break;
+                        case TB_FC_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                            traceback_queue.push(make_triple(int(ST_FM), k, j));
+                        }
+                        break;
+                    }
+                } //else { Assert(!, "unreachable"); }
+            } 
+            break;
+#endif
+
+            case ST_FM:
+                if (0 < i && i+2 <= j && j < L2) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j]) 
+                    for (int k=i+1; k < j; k++)
+                    {
+                        RealT FM2i = FM1i_ess[offset[i]+k] + FMi_ess[offset[k]+j];
+                        roulette.add(EncodeTraceback(TB_FM_BIFURCATION, k), FM2i);
+                    }
+
+                    // compute FM[i,j-1] + b
+                    if (allow_unpaired_position[j])
+                    {
+                        roulette.add(EncodeTraceback(TB_FM_UNPAIRED,0),
+                                     FMi_ess[offset[i]+j-1] + ScoreMultiUnpairedEvidence(j));
+                    }
+
+                    // compute FM1[i,j]
+                    roulette.add(EncodeTraceback(TB_FM_FM1,0), FM1i_ess[offset[i]+j]);
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FM_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                            traceback_queue.push(make_triple(int(ST_FM), k, j));
+                        }
+                        break;
+                        case TB_FM_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM), i, j-1));
+                        }
+                        break;
+                        case TB_FM_FM1: 
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM1), i, j));
+                        }
+                        break;
+                    }
+                
+                } //else { Assert(!, "unreachable"); }
+                break;
+
+            case ST_FM1:
+                if (0 < i && i+2 <= j && j < L2) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
+                    if (allow_paired[offset[i+1]+j])
+                    {
+                        RealT value = FCi_ess[offset[i+1]+j-1] + ScoreJunctionA(j,i) +
+                            ScoreMultiPaired() + ScoreBasePairEvidence(i+1,j);
+                        roulette.add(EncodeTraceback(TB_FM1_PAIRED, 0), value);
+                    }
+                
+                    // compute FM1[i+1,j] + b
+                    if (allow_unpaired_position[i+1])
+                    {
+                        roulette.add(EncodeTraceback(TB_FM1_UNPAIRED,0),
+                                     FM1i_ess[offset[i+1]+j] + ScoreMultiUnpaired(i+1));
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FM1_PAIRED:
+                        {
+                            solution[i+1] = j;
+                            solution[j] = i+1;
+                            traceback_queue.push(make_triple(int(ST_FC), i+1, j-1));
+                        }
+                        break;
+                        case TB_FM1_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM1), i+1, j));
+                        }
+                        break;
+                    }
+                } //else { Assert(!, "unreachable"); }
+                break;
+
+            case ST_F5:
+                if (j!=0)
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute F5[j-1] + ScoreExternalUnpaired()
+                    if (allow_unpaired_position[j])
+                    {
+                        roulette.add(EncodeTraceback(TB_F5_UNPAIRED,0),
+                                     F5i_ess[j-1] + ScoreExternalUnpairedEvidence(j));
+                    }
+        
+                    // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
+                    int l = 0; // ed remove max bp dist
+                    for (int k = l; k < j; k++)
+                    {
+                        if (allow_paired[offset[k+1]+j])
+                        {
+                            RealT value = F5i_ess[k] + FCi_ess[offset[k+1]+j-1] + ScoreExternalPaired() +
+                                ScoreBasePairEvidence(k+1,j) + ScoreJunctionA(j,k);
+                            roulette.add(EncodeTraceback(TB_F5_BIFURCATION,k), value);
+                        }      
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_F5_ZERO:
+                            break;
+                        case TB_F5_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_F5), 0, j-1));
+                        }
+                        break;
+                        case TB_F5_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            solution[k+1] = j;
+                            solution[j] = k+1;
+                            traceback_queue.push(make_triple(int(ST_F5), 0, k));
+                            traceback_queue.push(make_triple(int(ST_FC), k+1, j-1));
+                        }
+                        break;
+                    }
+                }
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    return solution;
+}
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.cpp b/./SStruct.cpp
index 77e7edc..14619ef 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.cpp
+++ b/./SStruct.cpp
@@ -804,6 +804,22 @@ void SStruct::WriteBPSEQ(std::ostream &outfile, const int seq) const
         outfile << i << ' ' << sequences[seq][i] << ' ' << mapping[i] << std::endl;
 }
 
+//////////////////////////////////////////////////////////////////////
+// SStruct::WriteBPPSEQ()
+//
+// Write sequence in BPPSEQ format.  The BPSEQ format can only handle
+// single sequences, so it will only print out the sequence "seq".
+//////////////////////////////////////////////////////////////////////
+
+void SStruct::WriteBPPSEQ(std::ostream &outfile, std::vector<std::vector<double> > potential, const int seq)
+{
+    if (seq < 0 || seq >= int(sequences.size())) Error("Reference to invalid sequence.");
+    Assert(sequences[seq].length() == mapping.size(), "Inconsistent lengths.");
+    
+    for (size_t i = 1; i < mapping.size(); i++)
+        outfile << i << ' ' << sequences[seq][i] << " e1 " << potential[seq][i-1] << std::endl;
+}
+
 //////////////////////////////////////////////////////////////////////
 // SStruct::WriteParens()
 //
@@ -828,6 +844,29 @@ void SStruct::WriteParens(std::ostream &outfile) const
     outfile << ConvertMappingToParens(mapping).substr(1) << std::endl;
 }
 
+//////////////////////////////////////////////////////////////////////
+// SStruct::WriteParensOnly()
+//
+// Write sequence in parenthesized format.  This routine assumes that
+// the structure does not contain pseudoknots.  All sequences are
+// printed.
+//////////////////////////////////////////////////////////////////////
+
+void SStruct::WriteParensOnly(std::ostream &outfile) const
+{
+    if (ContainsPseudoknots()) Error("Cannot write structure containing pseudoknots using parenthesized format.");
+    
+    // print sequences
+    // for (size_t k = 0; k < sequences.size(); k++)
+    // {
+    //     outfile << ">" << names[k] << std::endl;
+    //     outfile << sequences[k].substr(1) << std::endl;
+    // }
+
+    // print structure
+    //outfile << ">structure" << std::endl;
+    outfile << ConvertMappingToParens(mapping).substr(1) << std::endl;
+}
 //////////////////////////////////////////////////////////////////////
 // SStruct::ComputePercentIdentity()
 //
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.hpp b/./SStruct.hpp
index 969b761..f2fa204 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.hpp
+++ b/./SStruct.hpp
@@ -16,6 +16,7 @@
 #include <vector>
 #include <string>
 #include <sstream>
+#include "Config.hpp"
 #include "Utilities.hpp"
 
 //////////////////////////////////////////////////////////////////////
@@ -87,6 +88,9 @@ public:
     // output in various formats
     void WriteBPSEQ(std::ostream &outfile, const int seq = 0) const;
     void WriteParens(std::ostream &outfile) const;
+    void WriteParensOnly(std::ostream &outfile) const;
+    void WriteBPPSEQ(std::ostream &outfile, std::vector<std::vector<double> > potential, const int seq = 0);
+
 
     // compute alignment percent identity
     double ComputePercentIdentity() const;
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.o b/./SStruct.o
index 1063744..bd04391 100644
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.o and b/./SStruct.o differ
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ScorePrediction.o b/./ScorePrediction.o
index 3d04098..14c63e8 100644
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/ScorePrediction.o and b/./ScorePrediction.o differ
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Utilities.hpp b/./Utilities.hpp
index 7a6708d..af7ed86 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Utilities.hpp
+++ b/./Utilities.hpp
@@ -12,6 +12,7 @@
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
+#include <list>
 #include <climits>
 #include <fstream>
 #include <iomanip>
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/contrafold b/./contrafold
index d833057..c530cc9 100755
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/contrafold and b/./contrafold differ
diff --git a/./contrafold.params.basic b/./contrafold.params.basic
new file mode 100644
index 0000000..b00904b
--- /dev/null
+++ b/./contrafold.params.basic
@@ -0,0 +1,708 @@
+base_pair_AA 0.0
+base_pair_AC 0.0
+base_pair_AG 0.0
+base_pair_AU 1.0
+base_pair_CC 0.0
+base_pair_CG 1.0
+base_pair_CU 0.0
+base_pair_GG 0.0
+base_pair_GU 0.0
+base_pair_UU 0.0
+terminal_mismatch_AAAA 0.0
+terminal_mismatch_AAAC 0.0
+terminal_mismatch_AAAG 0.0
+terminal_mismatch_AAAU 0.0
+terminal_mismatch_AACA 0.0
+terminal_mismatch_AACC 0.0
+terminal_mismatch_AACG 0.0
+terminal_mismatch_AACU 0.0
+terminal_mismatch_AAGA 0.0
+terminal_mismatch_AAGC 0.0
+terminal_mismatch_AAGG 0.0
+terminal_mismatch_AAGU 0.0
+terminal_mismatch_AAUA 0.0
+terminal_mismatch_AAUC 0.0
+terminal_mismatch_AAUG 0.0
+terminal_mismatch_AAUU 0.0
+terminal_mismatch_ACAA 0.0
+terminal_mismatch_ACAC 0.0
+terminal_mismatch_ACAG 0.0
+terminal_mismatch_ACAU 0.0
+terminal_mismatch_ACCA 0.0
+terminal_mismatch_ACCC 0.0
+terminal_mismatch_ACCG 0.0
+terminal_mismatch_ACCU 0.0
+terminal_mismatch_ACGA 0.0
+terminal_mismatch_ACGC 0.0
+terminal_mismatch_ACGG 0.0
+terminal_mismatch_ACGU 0.0
+terminal_mismatch_ACUA 0.0
+terminal_mismatch_ACUC 0.0
+terminal_mismatch_ACUG 0.0
+terminal_mismatch_ACUU 0.0
+terminal_mismatch_AGAA 0.0
+terminal_mismatch_AGAC 0.0
+terminal_mismatch_AGAG 0.0
+terminal_mismatch_AGAU 0.0
+terminal_mismatch_AGCA 0.0
+terminal_mismatch_AGCC 0.0
+terminal_mismatch_AGCG 0.0
+terminal_mismatch_AGCU 0.0
+terminal_mismatch_AGGA 0.0
+terminal_mismatch_AGGC 0.0
+terminal_mismatch_AGGG 0.0
+terminal_mismatch_AGGU 0.0
+terminal_mismatch_AGUA 0.0
+terminal_mismatch_AGUC 0.0
+terminal_mismatch_AGUG 0.0
+terminal_mismatch_AGUU 0.0
+terminal_mismatch_AUAA 0.0
+terminal_mismatch_AUAC 0.0
+terminal_mismatch_AUAG 0.0
+terminal_mismatch_AUAU 0.0
+terminal_mismatch_AUCA 0.0
+terminal_mismatch_AUCC 0.0
+terminal_mismatch_AUCG 0.0
+terminal_mismatch_AUCU 0.0
+terminal_mismatch_AUGA 0.0
+terminal_mismatch_AUGC 0.0
+terminal_mismatch_AUGG 0.0
+terminal_mismatch_AUGU 0.0
+terminal_mismatch_AUUA 0.0
+terminal_mismatch_AUUC 0.0
+terminal_mismatch_AUUG 0.0
+terminal_mismatch_AUUU 0.0
+terminal_mismatch_CAAA 0.0
+terminal_mismatch_CAAC 0.0
+terminal_mismatch_CAAG 0.0
+terminal_mismatch_CAAU 0.0
+terminal_mismatch_CACA 0.0
+terminal_mismatch_CACC 0.0
+terminal_mismatch_CACG 0.0
+terminal_mismatch_CACU 0.0
+terminal_mismatch_CAGA 0.0
+terminal_mismatch_CAGC 0.0
+terminal_mismatch_CAGG 0.0
+terminal_mismatch_CAGU 0.0
+terminal_mismatch_CAUA 0.0
+terminal_mismatch_CAUC 0.0
+terminal_mismatch_CAUG 0.0
+terminal_mismatch_CAUU 0.0
+terminal_mismatch_CCAA 0.0
+terminal_mismatch_CCAC 0.0
+terminal_mismatch_CCAG 0.0
+terminal_mismatch_CCAU 0.0
+terminal_mismatch_CCCA 0.0
+terminal_mismatch_CCCC 0.0
+terminal_mismatch_CCCG 0.0
+terminal_mismatch_CCCU 0.0
+terminal_mismatch_CCGA 0.0
+terminal_mismatch_CCGC 0.0
+terminal_mismatch_CCGG 0.0
+terminal_mismatch_CCGU 0.0
+terminal_mismatch_CCUA 0.0
+terminal_mismatch_CCUC 0.0
+terminal_mismatch_CCUG 0.0
+terminal_mismatch_CCUU 0.0
+terminal_mismatch_CGAA 0.0
+terminal_mismatch_CGAC 0.0
+terminal_mismatch_CGAG 0.0
+terminal_mismatch_CGAU 0.0
+terminal_mismatch_CGCA 0.0
+terminal_mismatch_CGCC 0.0
+terminal_mismatch_CGCG 0.0
+terminal_mismatch_CGCU 0.0
+terminal_mismatch_CGGA 0.0
+terminal_mismatch_CGGC 0.0
+terminal_mismatch_CGGG 0.0
+terminal_mismatch_CGGU 0.0
+terminal_mismatch_CGUA 0.0
+terminal_mismatch_CGUC 0.0
+terminal_mismatch_CGUG 0.0
+terminal_mismatch_CGUU 0.0
+terminal_mismatch_CUAA 0.0
+terminal_mismatch_CUAC 0.0
+terminal_mismatch_CUAG 0.0
+terminal_mismatch_CUAU 0.0
+terminal_mismatch_CUCA 0.0
+terminal_mismatch_CUCC 0.0
+terminal_mismatch_CUCG 0.0
+terminal_mismatch_CUCU 0.0
+terminal_mismatch_CUGA 0.0
+terminal_mismatch_CUGC 0.0
+terminal_mismatch_CUGG 0.0
+terminal_mismatch_CUGU 0.0
+terminal_mismatch_CUUA 0.0
+terminal_mismatch_CUUC 0.0
+terminal_mismatch_CUUG 0.0
+terminal_mismatch_CUUU 0.0
+terminal_mismatch_GAAA 0.0
+terminal_mismatch_GAAC 0.0
+terminal_mismatch_GAAG 0.0
+terminal_mismatch_GAAU 0.0
+terminal_mismatch_GACA 0.0
+terminal_mismatch_GACC 0.0
+terminal_mismatch_GACG 0.0
+terminal_mismatch_GACU 0.0
+terminal_mismatch_GAGA 0.0
+terminal_mismatch_GAGC 0.0
+terminal_mismatch_GAGG 0.0
+terminal_mismatch_GAGU 0.0
+terminal_mismatch_GAUA 0.0
+terminal_mismatch_GAUC 0.0
+terminal_mismatch_GAUG 0.0
+terminal_mismatch_GAUU 0.0
+terminal_mismatch_GCAA 0.0
+terminal_mismatch_GCAC 0.0
+terminal_mismatch_GCAG 0.0
+terminal_mismatch_GCAU 0.0
+terminal_mismatch_GCCA 0.0
+terminal_mismatch_GCCC 0.0
+terminal_mismatch_GCCG 0.0
+terminal_mismatch_GCCU 0.0
+terminal_mismatch_GCGA 0.0
+terminal_mismatch_GCGC 0.0
+terminal_mismatch_GCGG 0.0
+terminal_mismatch_GCGU 0.0
+terminal_mismatch_GCUA 0.0
+terminal_mismatch_GCUC 0.0
+terminal_mismatch_GCUG 0.0
+terminal_mismatch_GCUU 0.0
+terminal_mismatch_GGAA 0.0
+terminal_mismatch_GGAC 0.0
+terminal_mismatch_GGAG 0.0
+terminal_mismatch_GGAU 0.0
+terminal_mismatch_GGCA 0.0
+terminal_mismatch_GGCC 0.0
+terminal_mismatch_GGCG 0.0
+terminal_mismatch_GGCU 0.0
+terminal_mismatch_GGGA 0.0
+terminal_mismatch_GGGC 0.0
+terminal_mismatch_GGGG 0.0
+terminal_mismatch_GGGU 0.0
+terminal_mismatch_GGUA 0.0
+terminal_mismatch_GGUC 0.0
+terminal_mismatch_GGUG 0.0
+terminal_mismatch_GGUU 0.0
+terminal_mismatch_GUAA 0.0
+terminal_mismatch_GUAC 0.0
+terminal_mismatch_GUAG 0.0
+terminal_mismatch_GUAU 0.0
+terminal_mismatch_GUCA 0.0
+terminal_mismatch_GUCC 0.0
+terminal_mismatch_GUCG 0.0
+terminal_mismatch_GUCU 0.0
+terminal_mismatch_GUGA 0.0
+terminal_mismatch_GUGC 0.0
+terminal_mismatch_GUGG 0.0
+terminal_mismatch_GUGU 0.0
+terminal_mismatch_GUUA 0.0
+terminal_mismatch_GUUC 0.0
+terminal_mismatch_GUUG 0.0
+terminal_mismatch_GUUU 0.0
+terminal_mismatch_UAAA 0.0
+terminal_mismatch_UAAC 0.0
+terminal_mismatch_UAAG 0.0
+terminal_mismatch_UAAU 0.0
+terminal_mismatch_UACA 0.0
+terminal_mismatch_UACC 0.0
+terminal_mismatch_UACG 0.0
+terminal_mismatch_UACU 0.0
+terminal_mismatch_UAGA 0.0
+terminal_mismatch_UAGC 0.0
+terminal_mismatch_UAGG 0.0
+terminal_mismatch_UAGU 0.0
+terminal_mismatch_UAUA 0.0
+terminal_mismatch_UAUC 0.0
+terminal_mismatch_UAUG 0.0
+terminal_mismatch_UAUU 0.0
+terminal_mismatch_UCAA 0.0
+terminal_mismatch_UCAC 0.0
+terminal_mismatch_UCAG 0.0
+terminal_mismatch_UCAU 0.0
+terminal_mismatch_UCCA 0.0
+terminal_mismatch_UCCC 0.0
+terminal_mismatch_UCCG 0.0
+terminal_mismatch_UCCU 0.0
+terminal_mismatch_UCGA 0.0
+terminal_mismatch_UCGC 0.0
+terminal_mismatch_UCGG 0.0
+terminal_mismatch_UCGU 0.0
+terminal_mismatch_UCUA 0.0
+terminal_mismatch_UCUC 0.0
+terminal_mismatch_UCUG 0.0
+terminal_mismatch_UCUU 0.0
+terminal_mismatch_UGAA 0.0
+terminal_mismatch_UGAC 0.0
+terminal_mismatch_UGAG 0.0
+terminal_mismatch_UGAU 0.0
+terminal_mismatch_UGCA 0.0
+terminal_mismatch_UGCC 0.0
+terminal_mismatch_UGCG 0.0
+terminal_mismatch_UGCU 0.0
+terminal_mismatch_UGGA 0.0
+terminal_mismatch_UGGC 0.0
+terminal_mismatch_UGGG 0.0
+terminal_mismatch_UGGU 0.0
+terminal_mismatch_UGUA 0.0
+terminal_mismatch_UGUC 0.0
+terminal_mismatch_UGUG 0.0
+terminal_mismatch_UGUU 0.0
+terminal_mismatch_UUAA 0.0
+terminal_mismatch_UUAC 0.0
+terminal_mismatch_UUAG 0.0
+terminal_mismatch_UUAU 0.0
+terminal_mismatch_UUCA 0.0
+terminal_mismatch_UUCC 0.0
+terminal_mismatch_UUCG 0.0
+terminal_mismatch_UUCU 0.0
+terminal_mismatch_UUGA 0.0
+terminal_mismatch_UUGC 0.0
+terminal_mismatch_UUGG 0.0
+terminal_mismatch_UUGU 0.0
+terminal_mismatch_UUUA 0.0
+terminal_mismatch_UUUC 0.0
+terminal_mismatch_UUUG 0.0
+terminal_mismatch_UUUU 0.0
+hairpin_length_at_least_0 0.0
+hairpin_length_at_least_1 0.0
+hairpin_length_at_least_2 0.0
+hairpin_length_at_least_3 0.0
+hairpin_length_at_least_4 0.0
+hairpin_length_at_least_5 0.0
+hairpin_length_at_least_6 0.0
+hairpin_length_at_least_7 0.0
+hairpin_length_at_least_8 0.0
+hairpin_length_at_least_9 0.0
+hairpin_length_at_least_10 0.0
+hairpin_length_at_least_11 0.0
+hairpin_length_at_least_12 0.0
+hairpin_length_at_least_13 0.0
+hairpin_length_at_least_14 0.0
+hairpin_length_at_least_15 0.0
+hairpin_length_at_least_16 0.0
+hairpin_length_at_least_17 0.0
+hairpin_length_at_least_18 0.0
+hairpin_length_at_least_19 0.0
+hairpin_length_at_least_20 0.0
+hairpin_length_at_least_21 0.0
+hairpin_length_at_least_22 0.0
+hairpin_length_at_least_23 0.0
+hairpin_length_at_least_24 0.0
+hairpin_length_at_least_25 0.0
+hairpin_length_at_least_26 0.0
+hairpin_length_at_least_27 0.0
+hairpin_length_at_least_28 0.0
+hairpin_length_at_least_29 0.0
+hairpin_length_at_least_30 0.0
+internal_explicit_1_1 0.0
+internal_explicit_1_2 0.0
+internal_explicit_1_3 0.0
+internal_explicit_1_4 0.0
+internal_explicit_2_2 0.0
+internal_explicit_2_3 0.0
+internal_explicit_2_4 0.0
+internal_explicit_3_3 0.0
+internal_explicit_3_4 0.0
+internal_explicit_4_4 0.0
+bulge_length_at_least_1 0.0
+bulge_length_at_least_2 0.0
+bulge_length_at_least_3 0.0
+bulge_length_at_least_4 0.0
+bulge_length_at_least_5 0.0
+bulge_length_at_least_6 0.0
+bulge_length_at_least_7 0.0
+bulge_length_at_least_8 0.0
+bulge_length_at_least_9 0.0
+bulge_length_at_least_10 0.0
+bulge_length_at_least_11 0.0
+bulge_length_at_least_12 0.0
+bulge_length_at_least_13 0.0
+bulge_length_at_least_14 0.0
+bulge_length_at_least_15 0.0
+bulge_length_at_least_16 0.0
+bulge_length_at_least_17 0.0
+bulge_length_at_least_18 0.0
+bulge_length_at_least_19 0.0
+bulge_length_at_least_20 0.0
+bulge_length_at_least_21 0.0
+bulge_length_at_least_22 0.0
+bulge_length_at_least_23 0.0
+bulge_length_at_least_24 0.0
+bulge_length_at_least_25 0.0
+bulge_length_at_least_26 0.0
+bulge_length_at_least_27 0.0
+bulge_length_at_least_28 0.0
+bulge_length_at_least_29 0.0
+bulge_length_at_least_30 0.0
+internal_length_at_least_2 0.0
+internal_length_at_least_3 0.0
+internal_length_at_least_4 0.0
+internal_length_at_least_5 0.0
+internal_length_at_least_6 0.0
+internal_length_at_least_7 0.0
+internal_length_at_least_8 0.0
+internal_length_at_least_9 0.0
+internal_length_at_least_10 0.0
+internal_length_at_least_11 0.0
+internal_length_at_least_12 0.0
+internal_length_at_least_13 0.0
+internal_length_at_least_14 0.0
+internal_length_at_least_15 0.0
+internal_length_at_least_16 0.0
+internal_length_at_least_17 0.0
+internal_length_at_least_18 0.0
+internal_length_at_least_19 0.0
+internal_length_at_least_20 0.0
+internal_length_at_least_21 0.0
+internal_length_at_least_22 0.0
+internal_length_at_least_23 0.0
+internal_length_at_least_24 0.0
+internal_length_at_least_25 0.0
+internal_length_at_least_26 0.0
+internal_length_at_least_27 0.0
+internal_length_at_least_28 0.0
+internal_length_at_least_29 0.0
+internal_length_at_least_30 0.0
+internal_symmetric_length_at_least_1 0.0
+internal_symmetric_length_at_least_2 0.0
+internal_symmetric_length_at_least_3 0.0
+internal_symmetric_length_at_least_4 0.0
+internal_symmetric_length_at_least_5 0.0
+internal_symmetric_length_at_least_6 0.0
+internal_symmetric_length_at_least_7 0.0
+internal_symmetric_length_at_least_8 0.0
+internal_symmetric_length_at_least_9 0.0
+internal_symmetric_length_at_least_10 0.0
+internal_symmetric_length_at_least_11 0.0
+internal_symmetric_length_at_least_12 0.0
+internal_symmetric_length_at_least_13 0.0
+internal_symmetric_length_at_least_14 0.0
+internal_symmetric_length_at_least_15 0.0
+internal_asymmetry_at_least_1 0.0
+internal_asymmetry_at_least_2 0.0
+internal_asymmetry_at_least_3 0.0
+internal_asymmetry_at_least_4 0.0
+internal_asymmetry_at_least_5 0.0
+internal_asymmetry_at_least_6 0.0
+internal_asymmetry_at_least_7 0.0
+internal_asymmetry_at_least_8 0.0
+internal_asymmetry_at_least_9 0.0
+internal_asymmetry_at_least_10 0.0
+internal_asymmetry_at_least_11 0.0
+internal_asymmetry_at_least_12 0.0
+internal_asymmetry_at_least_13 0.0
+internal_asymmetry_at_least_14 0.0
+internal_asymmetry_at_least_15 0.0
+internal_asymmetry_at_least_16 0.0
+internal_asymmetry_at_least_17 0.0
+internal_asymmetry_at_least_18 0.0
+internal_asymmetry_at_least_19 0.0
+internal_asymmetry_at_least_20 0.0
+internal_asymmetry_at_least_21 0.0
+internal_asymmetry_at_least_22 0.0
+internal_asymmetry_at_least_23 0.0
+internal_asymmetry_at_least_24 0.0
+internal_asymmetry_at_least_25 0.0
+internal_asymmetry_at_least_26 0.0
+internal_asymmetry_at_least_27 0.0
+internal_asymmetry_at_least_28 0.0
+bulge_0x1_nucleotides_A 0.0
+bulge_0x1_nucleotides_C 0.0
+bulge_0x1_nucleotides_G 0.0
+bulge_0x1_nucleotides_U 0.0
+internal_1x1_nucleotides_AA 0.0
+internal_1x1_nucleotides_AC 0.0
+internal_1x1_nucleotides_AG 0.0
+internal_1x1_nucleotides_AU 0.0
+internal_1x1_nucleotides_CC 0.0
+internal_1x1_nucleotides_CG 0.0
+internal_1x1_nucleotides_CU 0.0
+internal_1x1_nucleotides_GG 0.0
+internal_1x1_nucleotides_GU 0.0
+internal_1x1_nucleotides_UU 0.0
+helix_stacking_AAAA 0.0
+helix_stacking_AAAC 0.0
+helix_stacking_AAAG 0.0
+helix_stacking_AAAU 0.0
+helix_stacking_AACA 0.0
+helix_stacking_AACC 0.0
+helix_stacking_AACG 0.0
+helix_stacking_AACU 0.0
+helix_stacking_AAGA 0.0
+helix_stacking_AAGC 0.0
+helix_stacking_AAGG 0.0
+helix_stacking_AAGU 0.0
+helix_stacking_AAUA 0.0
+helix_stacking_AAUC 0.0
+helix_stacking_AAUG 0.0
+helix_stacking_AAUU 0.0
+helix_stacking_ACAC 0.0
+helix_stacking_ACAG 0.0
+helix_stacking_ACAU 0.0
+helix_stacking_ACCA 0.0
+helix_stacking_ACCC 0.0
+helix_stacking_ACCG 0.0
+helix_stacking_ACCU 0.0
+helix_stacking_ACGA 0.0
+helix_stacking_ACGC 0.0
+helix_stacking_ACGG 0.0
+helix_stacking_ACGU 0.0
+helix_stacking_ACUA 0.0
+helix_stacking_ACUC 0.0
+helix_stacking_ACUG 0.0
+helix_stacking_ACUU 0.0
+helix_stacking_AGAC 0.0
+helix_stacking_AGAG 0.0
+helix_stacking_AGAU 0.0
+helix_stacking_AGCC 0.0
+helix_stacking_AGCG 0.0
+helix_stacking_AGCU 0.0
+helix_stacking_AGGA 0.0
+helix_stacking_AGGC 0.0
+helix_stacking_AGGG 0.0
+helix_stacking_AGGU 0.0
+helix_stacking_AGUA 0.0
+helix_stacking_AGUC 0.0
+helix_stacking_AGUG 0.0
+helix_stacking_AGUU 0.0
+helix_stacking_AUAC 0.0
+helix_stacking_AUAG 0.0
+helix_stacking_AUAU 0.0
+helix_stacking_AUCC 0.0
+helix_stacking_AUCG 0.0
+helix_stacking_AUCU 0.0
+helix_stacking_AUGC 0.0
+helix_stacking_AUGG 0.0
+helix_stacking_AUGU 0.0
+helix_stacking_AUUA 0.0
+helix_stacking_AUUC 0.0
+helix_stacking_AUUG 0.0
+helix_stacking_AUUU 0.0
+helix_stacking_CAAC 0.0
+helix_stacking_CAAG 0.0
+helix_stacking_CAAU 0.0
+helix_stacking_CACC 0.0
+helix_stacking_CACG 0.0
+helix_stacking_CACU 0.0
+helix_stacking_CAGC 0.0
+helix_stacking_CAGG 0.0
+helix_stacking_CAGU 0.0
+helix_stacking_CAUC 0.0
+helix_stacking_CAUG 0.0
+helix_stacking_CAUU 0.0
+helix_stacking_CCAG 0.0
+helix_stacking_CCAU 0.0
+helix_stacking_CCCC 0.0
+helix_stacking_CCCG 0.0
+helix_stacking_CCCU 0.0
+helix_stacking_CCGC 0.0
+helix_stacking_CCGG 0.0
+helix_stacking_CCGU 0.0
+helix_stacking_CCUC 0.0
+helix_stacking_CCUG 0.0
+helix_stacking_CCUU 0.0
+helix_stacking_CGAG 0.0
+helix_stacking_CGAU 0.0
+helix_stacking_CGCG 0.0
+helix_stacking_CGCU 0.0
+helix_stacking_CGGC 0.0
+helix_stacking_CGGG 0.0
+helix_stacking_CGGU 0.0
+helix_stacking_CGUC 0.0
+helix_stacking_CGUG 0.0
+helix_stacking_CGUU 0.0
+helix_stacking_CUAG 0.0
+helix_stacking_CUAU 0.0
+helix_stacking_CUCG 0.0
+helix_stacking_CUCU 0.0
+helix_stacking_CUGG 0.0
+helix_stacking_CUGU 0.0
+helix_stacking_CUUC 0.0
+helix_stacking_CUUG 0.0
+helix_stacking_CUUU 0.0
+helix_stacking_GAAG 0.0
+helix_stacking_GAAU 0.0
+helix_stacking_GACG 0.0
+helix_stacking_GACU 0.0
+helix_stacking_GAGG 0.0
+helix_stacking_GAGU 0.0
+helix_stacking_GAUG 0.0
+helix_stacking_GAUU 0.0
+helix_stacking_GCAU 0.0
+helix_stacking_GCCG 0.0
+helix_stacking_GCCU 0.0
+helix_stacking_GCGG 0.0
+helix_stacking_GCGU 0.0
+helix_stacking_GCUG 0.0
+helix_stacking_GCUU 0.0
+helix_stacking_GGAU 0.0
+helix_stacking_GGCU 0.0
+helix_stacking_GGGG 0.0
+helix_stacking_GGGU 0.0
+helix_stacking_GGUG 0.0
+helix_stacking_GGUU 0.0
+helix_stacking_GUAU 0.0
+helix_stacking_GUCU 0.0
+helix_stacking_GUGU 0.0
+helix_stacking_GUUG 0.0
+helix_stacking_GUUU 0.0
+helix_stacking_UAAU 0.0
+helix_stacking_UACU 0.0
+helix_stacking_UAGU 0.0
+helix_stacking_UAUU 0.0
+helix_stacking_UCCU 0.0
+helix_stacking_UCGU 0.0
+helix_stacking_UCUU 0.0
+helix_stacking_UGGU 0.0
+helix_stacking_UGUU 0.0
+helix_stacking_UUUU 0.0
+helix_closing_AA 0.0
+helix_closing_AC 0.0
+helix_closing_AG 0.0
+helix_closing_AU 0.0
+helix_closing_CA 0.0
+helix_closing_CC 0.0
+helix_closing_CG 0.0
+helix_closing_CU 0.0
+helix_closing_GA 0.0
+helix_closing_GC 0.0
+helix_closing_GG 0.0
+helix_closing_GU 0.0
+helix_closing_UA 0.0
+helix_closing_UC 0.0
+helix_closing_UG 0.0
+helix_closing_UU 0.0
+multi_base 0.0
+multi_unpaired 0.0
+multi_paired 0.0
+dangle_left_AAA 0.0
+dangle_left_AAC 0.0
+dangle_left_AAG 0.0
+dangle_left_AAU 0.0
+dangle_left_ACA 0.0
+dangle_left_ACC 0.0
+dangle_left_ACG 0.0
+dangle_left_ACU 0.0
+dangle_left_AGA 0.0
+dangle_left_AGC 0.0
+dangle_left_AGG 0.0
+dangle_left_AGU 0.0
+dangle_left_AUA 0.0
+dangle_left_AUC 0.0
+dangle_left_AUG 0.0
+dangle_left_AUU 0.0
+dangle_left_CAA 0.0
+dangle_left_CAC 0.0
+dangle_left_CAG 0.0
+dangle_left_CAU 0.0
+dangle_left_CCA 0.0
+dangle_left_CCC 0.0
+dangle_left_CCG 0.0
+dangle_left_CCU 0.0
+dangle_left_CGA 0.0
+dangle_left_CGC 0.0
+dangle_left_CGG 0.0
+dangle_left_CGU 0.0
+dangle_left_CUA 0.0
+dangle_left_CUC 0.0
+dangle_left_CUG 0.0
+dangle_left_CUU 0.0
+dangle_left_GAA 0.0
+dangle_left_GAC 0.0
+dangle_left_GAG 0.0
+dangle_left_GAU 0.0
+dangle_left_GCA 0.0
+dangle_left_GCC 0.0
+dangle_left_GCG 0.0
+dangle_left_GCU 0.0
+dangle_left_GGA 0.0
+dangle_left_GGC 0.0
+dangle_left_GGG 0.0
+dangle_left_GGU 0.0
+dangle_left_GUA 0.0
+dangle_left_GUC 0.0
+dangle_left_GUG 0.0
+dangle_left_GUU 0.0
+dangle_left_UAA 0.0
+dangle_left_UAC 0.0
+dangle_left_UAG 0.0
+dangle_left_UAU 0.0
+dangle_left_UCA 0.0
+dangle_left_UCC 0.0
+dangle_left_UCG 0.0
+dangle_left_UCU 0.0
+dangle_left_UGA 0.0
+dangle_left_UGC 0.0
+dangle_left_UGG 0.0
+dangle_left_UGU 0.0
+dangle_left_UUA 0.0
+dangle_left_UUC 0.0
+dangle_left_UUG 0.0
+dangle_left_UUU 0.0
+dangle_right_AAA 0.0
+dangle_right_AAC 0.0
+dangle_right_AAG 0.0
+dangle_right_AAU 0.0
+dangle_right_ACA 0.0
+dangle_right_ACC 0.0
+dangle_right_ACG 0.0
+dangle_right_ACU 0.0
+dangle_right_AGA 0.0
+dangle_right_AGC 0.0
+dangle_right_AGG 0.0
+dangle_right_AGU 0.0
+dangle_right_AUA 0.0
+dangle_right_AUC 0.0
+dangle_right_AUG 0.0
+dangle_right_AUU 0.0
+dangle_right_CAA 0.0
+dangle_right_CAC 0.0
+dangle_right_CAG 0.0
+dangle_right_CAU 0.0
+dangle_right_CCA 0.0
+dangle_right_CCC 0.0
+dangle_right_CCG 0.0
+dangle_right_CCU 0.0
+dangle_right_CGA 0.0
+dangle_right_CGC 0.0
+dangle_right_CGG 0.0
+dangle_right_CGU 0.0
+dangle_right_CUA 0.0
+dangle_right_CUC 0.0
+dangle_right_CUG 0.0
+dangle_right_CUU 0.0
+dangle_right_GAA 0.0
+dangle_right_GAC 0.0
+dangle_right_GAG 0.0
+dangle_right_GAU 0.0
+dangle_right_GCA 0.0
+dangle_right_GCC 0.0
+dangle_right_GCG 0.0
+dangle_right_GCU 0.0
+dangle_right_GGA 0.0
+dangle_right_GGC 0.0
+dangle_right_GGG 0.0
+dangle_right_GGU 0.0
+dangle_right_GUA 0.0
+dangle_right_GUC 0.0
+dangle_right_GUG 0.0
+dangle_right_GUU 0.0
+dangle_right_UAA 0.0
+dangle_right_UAC 0.0
+dangle_right_UAG 0.0
+dangle_right_UAU 0.0
+dangle_right_UCA 0.0
+dangle_right_UCC 0.0
+dangle_right_UCG 0.0
+dangle_right_UCU 0.0
+dangle_right_UGA 0.0
+dangle_right_UGC 0.0
+dangle_right_UGG 0.0
+dangle_right_UGU 0.0
+dangle_right_UUA 0.0
+dangle_right_UUC 0.0
+dangle_right_UUG 0.0
+dangle_right_UUU 0.0
+external_unpaired 0.0
+external_paired 0.0
diff --git a/./hhr.seq b/./hhr.seq
new file mode 100644
index 0000000..a0d1ffb
--- /dev/null
+++ b/./hhr.seq
@@ -0,0 +1 @@
+ACGCUGUCUGUACUUGUAUCAGUACACUGACGAGUCCCUAAAGGACGAAACAGCGC
diff --git a/./out b/./out
new file mode 100644
index 0000000..c6814eb
--- /dev/null
+++ b/./out
@@ -0,0 +1,1000 @@
+.((((((.(((((......)))))...))).))).......(.......).....
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.........................(((....(((.......)))....)))...
+((((((((......((..(((....))))).))...............)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))........((((.....))))...)))))).
+((((((.(((.((.(........)((......))......)).)).).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+......(((.(....)..)))..................................
+.((....((((((......)))))).......((((.....))))......))..
+.......((((((......)))))).......((((.....))))..........
+((((((.((((((......)))))).......(((.......)))...)))))).
+((((((.(((.((........(......)...........)).)))..)))))).
+((((((.......(..........).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+(((((((((((((......))))))..)))).((((.....))))......))).
+........................(((....))).....................
+.(((((.((((((......))))))....(..(((.......))))..)))))..
+((((...((((((......)))))).......((((.....)))).....)))).
+(((((..(((((........)))))((....))(((.....))).....))))).
+(((((((((((((......))))))..))...(((.......)))....))))).
+(((((((......(((......))).....))((((.....))))....))))).
+((((((..((....(((....)))....))..((((.....))))...)))))).
+((.((..(((((........))))).)).)).((((.....))))..........
+.......((((((......))))))..........((....))............
+.((((............((((....))))...(((.......)))....))))..
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......))))).....((..(((.....)))))..)))))).
+(((((((((((((......))))))....................)..)))))).
+((((((.(((((........)))))(....).((((.....))))...)))))).
+(((.(((((((((......))))))..)))..((((.....))))......))).
+...((((((..((.((..(((....))))).))..)....).)))).........
+..........((((((..(((....))))))))).....................
+.(((((..(((((......)))))........((((.....))))...)))))..
+((((((.((.(((((..((((....))))))))).)..........).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((((........)))))(((..(....).)..))......)))))).
+(((((((.(....)...((((....))))...((((.....))))))..))))).
+..(((....(....)...))).......................((......)).
+.......((((((.(...)))))))(((....((((.....))))....)))...
+.......((((((......)))))).......((((.....))))..........
+((((((((((((........)))))..)))..((((.....)))).....)))).
+(((((...((...(((......)))...))..((((.....))))....))))).
+((((((...(.(((.((((((....))))........))))).)....)))))).
+((((((.............((....)).....(((.......)))...)))))).
+(((..((((((((......))))))..))...((((.....))))......))).
+.(((((.....((......))...........((((.....))))...)))))..
+....((.((((((......))))))...)).........................
+....(..((((((......)))))))......((((.....))))..........
+((((((...((((......)))).........((((.....))))...)))))).
+((((.............((((....))))...(((..........)..)))))).
+((((((.(((((........))))).(....)((((.....))))...)))))).
+((((((..(((((......))))).(....).((((.....))))...)))))).
+((((((......(((..((((....)))))))((((.....))))...)))))).
+.(((((.(((((........))))).......((((.....))))...)))))..
+....(((.(((((......)))))...))).........................
+(((((((.((.(((..........(((....))).....))).)))..)))))).
+((((((.((((((......))))))(......(((.......))))..)))))).
+(((((((((((((......)))))).......((((.....))))))..))))).
+(((((..(((.(((..........................))))))...))))).
+(((.....(((((......)))))..((....((((.....))))....))))).
+........(((((......))))).(((....(((.......)))....)))...
+.(((((.(.........((((....))))...((((.....)))))..)))))..
+.......((((((......))))))(((....((((.....))))....)))...
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((((..((........)))))))..(....).)))..)))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......................)))))).
+.......(((((........))))).......((((.....))))..........
+.(((((.(((((........))))).......((((.....))))...)))))..
+.(((((..........................((((.....))))...)))))..
+((((((............(.(....).)....((((.....))))...)))))).
+((((((..((((.((...))))))....))..((((.....)))).....)))).
+(((((((.......)..((((....))))...((((.....))))...)))))).
+(((.((.((((((......))))))(....).((((.....))))...)).))).
+.............................((.((((.....)))).......)).
+...(((((((((........)))))..)))..((((.....))))).........
+.((((........(..............)...((((.....))))....))))..
+((((((.(((((.((...))))))).......((((.....))))...)))))).
+(((((.(((((((......)))))................)).......))))).
+(((((...(((((......)))))........((((.....))))....))))).
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+(((((..(((((........))))).......((((.....))))....))))).
+(......(((((.((...)))))))..)...........................
+..............(((....))).(((....((((.....))))....)))...
+.(((((..((((........))))..(......(((.....)))...))))))..
+((((((.((.(((((..((((....))))))))).)..........).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))........(((.......)))...)))))).
+((((((.(..((((((..(((....)))))))))............).)))))).
+((((.((((((((.(...))))))).....(....).........))...)))).
+.............................(..((((.....))))).........
+.......((((((......)))))).......((((.....))))..........
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((.(((((............))).........)).))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.((((((((.........)))...........((((.....))))...)))))..
+........(((((......))))).((.....((((.....)))).....))...
+........((((.((...))))))........((((.....))))..........
+(((((.(((.........)))...........((((.....))))....))))).
+(((((..((((((......)))))).(.....(((.......)))...)))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+(((((..(....(((((....)))...))..)((((.....))))....))))).
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.......((((((......)))))).......((((.....))))..........
+.......((((((......))))))....(..(.((.....)).)......)...
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+(((((((...(((((..((((....)))))))))...........)..)))))).
+((((((.(((((........)))))....((..(((.....)))))..)))))).
+.......................(.(((....((((.....))))....))).).
+.(((((.(((.((..........(......).........)).)))..)))))..
+.((((((((((((......)))))).......((((.....))))))..))))..
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(((.(((.........................))).)))..)))))).
+((((((.((((((......))))))........(((.....)))....)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((.(((.((((..((((....)))).......)..))).)))..)))))).
+.............((((....))))((.....((((.....)))).....))...
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.(((((..(...)(((......))).......((((.....))))...)))))..
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((.(((((((......))))))..)....((((.....))))....))))).
+(((((((.(((((......)))))...))...((((.....))))....))))).
+((((((.((((((......)))))...)....((((.....))))...)))))).
+((((((.((((((......))))))(....).((((.....))))...)))))).
+....(((.(((..........)))...)))..((((.....))))..........
+.((((.(.(((((......)))))...).....(((.....))).....))))..
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+(((((((((((((......)))))).....).((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......)))))(((....))).((....)).....)))))).
+.............((((....))))(......((((.....))))......)...
+.....((((((((......))))))..))(..((((.....))))).........
+......(((........((((....))))...((((.....))))....)))...
+((((((.((..((((..((((....))))))))..)...........))))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((........((......)).(......((((.....)))))..)))))).
+(((((((((((....)).))............((((.....))))))..))))).
+(((((..(((.(((...((((....))))..........))).)))...))))).
+....(((.(((((......)))))...)))..((((.....))))..........
+.......((.((.((...)))).))(((....((((.....))))....)))...
+....((.(((((........)))))...))..((((.....))))..........
+(((((((.(((((......)))))...))...((((.....))))....))))).
+((((((.(((.((..((........(....)......))..)))))..)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+..........(((......))).(.(((....((((.....))))....))).).
+................................((((.....))))..........
+...........(((((............)))))(((.....)))...........
+((((...((((((......)))))).......((((.....)))).....)))).
+((((((............(((....)))....((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+(((((((((.........)))...........((((.....))))...)))))).
+((((((..((...((((....))))...))..((((.....))))...)))))).
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.(((((..(((((......))))).........(((.....)))....)))))..
+.....((((((((......))))))..))..........................
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..(((((......)))))........(.((.....)).)...)))))).
+(((((.((((((........)))))....................)...))))).
+(((((...((((........))))........((((.....))))....))))).
+(((....((((((......)))))).((....((((.....))))....))))).
+.(((((.(((.(((....(((....)))..(....)...))).)))..)))))..
+.((((((.((((........))))...)))..((((.....)))).....)))..
+(((((......((((((.........).)))))..((....))......))))).
+((((((.(...(((......(.............).....)))...).)))))).
+((((((.((((((......))))))(......(((.......))))..)))))).
+((((((.((((((......))))))....(..((((.....)))))..)))))).
+((((((.(((.(((.........................))).)))..)))))).
+.......((((((......))))))........(((.....)))...........
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.((((((.......)..((((....))))...((((.....))))...)))))..
+(((((((.(((((......)))))...)))..((((.....)))).....)))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((....(((((..((((....)))))))))..............)))))).
+((((((............(((....)))....((((.....))))...)))))).
+(((...((((((........))))).......((((.....))))).....))).
+........((((........)))).(((....((((.....))))....)))...
+.......(((((........)))))....(..((((.....))))).........
+.(((((.((.(((......))).)).......((((.....))))...)))))..
+(((((((((((((......)))))).......((((.....))))))..))))).
+((((((..((.((......)).)))).(....((((.....))))....))))).
+(((((..(((((........))))).......((((.....))))....))))).
+(((((..((((((......)))))).......(((.......)))....))))).
+......(((.........)))..(.((.....((((.....)))).....)).).
+....(((((((((......))))))..))).........................
+....(((((((((......))))))..)))..((((.....))))..........
+(((((((....((...........................))...)..)))))).
+((((((.(((((.((...))))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(...(..((......))........((((.....)))))).)))))).
+(((.((...(((........))).........((((.....))))...)).))).
+.((((.............))))...(((....((((.....))))....)))...
+........((.(((.........................))).))..........
+..(((..(((((........))))).......((((.....))))....)))...
+((((((.((((((......))))))....((...((.....)).))..)))))).
+((((((.(((.(((...((((....))))....(....)))).)))..)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((((........)))))........(((.....)))....)))))).
+((((((..((.(((.((........((....))....))))).))...)))))).
+.((((..((((..........)))).(.....((((.....))))..).))))..
+........(((((......))))).(((....((((.....))))....)))...
+(((((....(......................((((.....)))))...))))).
+(((((...(((((......)))))..(.....(((.......)))...)))))).
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+(((((..............((....)).....((((.....))))....))))).
+(((((............((((....))))...((((.....))))....))))).
+.(((((.((((((......))))))........((..........)).)))))..
+.(((((..(((((......)))))........((((.....))))...)))))..
+((..(((((((((......))))))..)))...(((.....))))).........
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((....((((((..(((....))))))))).((....)).....)))))).
+((((((..(((((......)))))....))..((((.....)))).....)))).
+((((((..(((((......)))))........((((.....))))...)))))).
+....(..(((((........))))).((....(((.......)))....)).)..
+.(((((.((((((......)))))).......((((.....))))...)))))..
+................................((((.....))))..........
+((((((.(...((..((((((....))))........)).))....).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(....(((.......((.(....).))...)))......).)))))).
+...........(........(........(..((((.....)))))......)).
+...((((((((((......))))))..)))).((((.....))))..........
+.(((((..((....))....(........)..((((.....))))...)))))..
+(((((........((((....))))........(((.....))).....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+((((((((((((........)))))..))...((((.....))))....))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+.............((((....)))).......((((.....))))..........
+.....((........(.((((....)))).).((((.....))))))........
+.(((((.((((((......)))))).......((((.....))))...)))))..
+(((((((((.........)))...........((((.....))))...)))))).
+((((((...........((((....))))...((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((.(..(.......)..((((....))))...((((.....)))).....).)).
+(((((((((.((........)).)).....).((((.....))))...)))))).
+.............((((....))))(((....((((.....))))....)))...
+...(((.((((((......))))))...)))......(.......).........
+((((((..........................................)))))).
+((((((.(((((........))))).....(..(((.....))))...)))))).
+((((((..(((((......)))))........(((.......)))...)))))).
+(((((((((.........)))...........................)))))).
+(((((.(((((((......)))))).......((((.....)))))...))))).
+.((.(...(((((......)))))........((((.....))))....).))..
+.................((((....))))...((((.....))))..........
+........(((((......)))))...............................
+(((((((.(((((......)))))...))...((((.....))))....))))).
+(((((......((((..((((....))))))))(((.....))).....))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((....((((....))))..))).((....)))))..)))))).
+.((((...(((((......)))))........((((.....))))....))))..
+.......(((...((........))...))).(((.......)))..........
+..(((((....(..((......))...)..)..(((.....)))....))))...
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((......((...((((....))))...((((.....)))))).)))))).
+(((((((((((((......))))))..)....((((.....))))...)))))).
+..(..................................................).
+.(((((..(((((......)))))........(((.......)))...)))))..
+.......((((((......))))))(((....((((.....))))....)))...
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))(((....))).((....)).....)))))).
+((((((.(((((........))))).......((((.....)))).)..))))).
+(((((.(((.........)))..(......).(((.......)))....))))).
+(((((..((((((......)))))).......(((.......)))....))))).
+....((..(((((......)))))))(.....((((.....)))).....)....
+.(((...((((((......))))))..(....((((.....))))....))))..
+...((((((.(((((..((((....))))))))).).....))))).........
+((((((.(.(.((((..((((....))))))))(((.....))).).))))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(......(((((((....))))........)).....).).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.................(((......)))..........................
+.((.....(((((......)))))..(.....((((.....))))...)..))..
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((((.((...))))))).......((((.....))))...)))))).
+((((((.(((.(((......((......)).........))).)))..)))))).
+((((((.((((((......))))))(......(((.......))))..)))))).
+((((((.((((((......))))))....(..((((.....)))))..)))))).
+...(((.......((((....))))....((.............))..)))....
+.................((......((....))...(.....)..))........
+.(((((.((((((......)))))).......((((.....))))...)))))..
+((((...(((((.(.....)))))).......((((.....)))).....)))).
+(((((...(((((......))))).........................))))).
+(((((...(((((......)))))........((((.....))))....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+....(...(((((......)))))..).....((((.....))))..........
+.......................................................
+.((((..(.....((((....)))).....).((((.....))))....))))..
+((((((.((((((......)))))).......(((.......)))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+(((((((..(((........))).........((((.....)))))..)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+(((.((..(((((......)))))........((((.....))))...)).))).
+..........(((......)))...(((....((((.....))))....)))...
+........(((((......)))))........((((.....))))..........
+((((((..((((........))))........((((.....))))...)))))).
+((((((.(..(....).((((....))))...((((.....)))).).)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((.(((.....((...(((....)))..)).))).)))..)))))).
+.((((...(((((......)))))........((((.....))))....))))..
+..........(((((..((((....))))))))).....................
+...((..((((((......))))))....)).((((.....))))..........
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+(((((..(((((........)))))(................)......))))).
+(((((..((((((......))))))....((..(((.....)))))...))))).
+(((((((((((((......))))))..))...((((.....))))....))))).
+(((((((((((((......))))))..)))...(((.....)))....)..))).
+.(((((..(((((......)))))........((((.....))))...)))))..
+........(((((......)))))...............................
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((...((((......))))..((.............))......)))))).
+((((...((((((......))))))..(....((((.....))))....))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))........((((.....))))...)))))).
+.........................((.....((((.....)))).....))...
+.(((((.((((((......)))))).......(((.......)))...)))))..
+.......((......))........(((....((((.....))))....)))...
+(((((((.((((........))))........((((.....)))))..)))))).
+((((((.(((((........))))).......(((.......)))...)))))).
+((((((..(((((......)))))........(((.......)))...)))))).
+((((((.(.........(..............((((.....)))))).)))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+........(((((......)))))........((((.....))))..........
+.(((((..(((....))).......(......((((.....)))))..)))))..
+........(((((......))))).....((..(((.....))))).........
+(((((..(((((........))))).......((.........))....))))).
+(((((((((((((......))))))..))...((((.....))))....))))).
+(((((((((((((......)))))).....))((((.....))))....))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((.((((.....((......))......)..))).))...)))))).
+...((((((((((......))))))..))))..((..........))........
+.(((((.((((((......)))))).......((((.....))))...)))))..
+((((((.....(((((..(((....))))).........)))......)))))).
+(((((((((((((......))))))..).((..(((.....)))))..)))))).
+(((((((((((((......))))))..)))...((((....))..))...)))).
+((((((.((.........))((......))..((((.....))))...)))))).
+((((((...........((((....))))...((((.....))))...)))))).
+.......((((((......))))))..............................
+....(((((.........))).)).(((....((((.....))))....)))...
+.(((((..(((((......)))))....)...((((.....))))....))))..
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((....(((((..((((....))))))))).((....)).....)))))).
+((((.((.(................).))...((((.....)))).....)))).
+(((((...(((....)))(((....))).(...........).......))))).
+.................((((....))))....(((.....)))...........
+..................((......))....((((.....))))..........
+(((((((...(..(((......))).)))...((((.....))))....))))).
+((((((.(((((........))))).....).((((.....))))....))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(((.(((...((.((......)))).......))).)))..)))))).
+.((((....(((((((..(((....)))))))))..((...))..)...))))..
+.............((((....))))(((....((((.....))))....)))...
+.......((.........))............((((.....))))..........
+((((((.((((((......)))))).......(((.(....))))...)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..((...((((....))))....(..(....)...).))...)))))).
+((((((.(((.((......)).))).......((((.....))))...)))))).
+((((((.((((((......))))))........(((.....)))....)))))).
+.(((((..((((........)))).(......((((.....)))))..)))))..
+...((...((((........)))).....)).((.((....))))..........
+.......((((((......))))))....((.((((.....))))....).)...
+(((((((((.........)))....(.......(((.....))).)..)))))).
+(((((((....(((......(.((........)))....)))...))..))))).
+(((((...((..(((((....))).......((...))...))))....))))).
+(((((((.(((((......)))))...)))..((((.....)))).....)))).
+(((((..((((((......))))))........(((.....))).....))))).
+.(((.(.(((((........))))).......((((.....))))...).)))..
+.................((((....))))...((((.....))))..........
+((((((..........................................)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(.(..((......(........)))((((.....))))).))))))).
+((((((.((.(((......))).)).(....)((((.....))))...)))))).
+.......((((((......))))))(((....((((.....))))....)))...
+.(((((.((.........))(........)..((((.....))))...)))))..
+.(((((((..(((((..((........))))))).......))).....))))..
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((.(((...(..((......))..)......))).)))..)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((.(((...((((....))))..........))).)))..)))))).
+.......((((((......)))))).((.....................))....
+.(((((.((((((......)))))).......((((.....))))...)))))..
+(((((((((((((......)))))).......((((.....))))))..))))).
+(((((..(((...((((....))))...))..(((.......))).)..))))).
+(((((...(((((......)))))........((((.....))))....))))).
+(.(((...(((((......)))))........((((.....))))....))).).
+(((((..(((((........))))).......((((.....))))....))))).
+.......((((((......))))))(((....((((.....))))....)))...
+...((((.((((........))))...)))).((((.....))))..........
+......((((............(..........)..............))))...
+((((((.((((((......))))))....((....).....)......)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((......(((..((((....)))))))((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))........((((.....))))...)))))).
+...(((.((((((......)))))).......((((.....))))...)))....
+.........................(((....(..((....)).)....)))...
+....(((((((((.(...)))))))..)))..((((.....))))..........
+((((((.(.((((((..((((....))))))))).(.....).)...))))))).
+((((((.((((((......)))))).......((.((....))))...)))))).
+((((((..(((((......)))))........(((.......)))...)))))).
+((((((.(.((((......))))......(...(((.....))).)).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+....(((.(((((......)))))...)))..((((.....))))..........
+.(.(.(.((((((......)))))).......((((.....))))).).).....
+(((((...((((........))))..(.....((((.....))))...)))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((((((((((......))))))..))...((.((....))))....))))).
+(((((((.(((((......)))))......))((((.....))))....))))).
+.(((((..(((((......)))))..(.....((((.....)))).).)))))..
+..(((.(.......)...)))....((.....((((.....)))).....))...
+..........((((((..(((....))))))))).....................
+((((....(((((......)))))..(.....((((.....))))...).)))).
+((((((...........((((....))))...((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((...((((......))))......(..((((.....)))))..)))))).
+(((((((((((((......)))))).....).((((.....))))...)))))).
+.(((((.((((..........)))).......((((.....))))...)))))..
+.(((((.((((((......)))))).......((.((....))))...)))))..
+((((((.....(((...((((....)))).)))(((.....)))....)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......))))).(....).((((.....))))...)))))).
+(((((((.(((((......)))))........((((.....)))))..)))))).
+((((((.((((((......))))))((....))...............)))))).
+.((((((((((((......))))))..))).))).....................
+.((((((((.........)))...........((((.....))))...)))))..
+.((((((((((((......))))))..)))).((((.....))))......))..
+(((((..((((((......)))))).......((((.....))))....))))).
+((((((..(((((......)))))...)....((((.....))))....))))).
+(..(((((((((........)))))..)))).((((.....))))........).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((.......((((....))))..............)))..)))))).
+.........................(((....((((.....))))....)))...
+.((((.(.......)...))))..........(((.......)))..........
+.(((((..(((((......)))))........((((.....))))...)))))..
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((.....((((.....(.((........))).)...))).....)))))).
+(((((((((((((.(...)))))))..).....((.......))....)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.((((((((((((......))))))..)))).)).....................
+..(.(((((((((......))))))..)))).((((.....))))..........
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))........((((.....))))...)))))).
+((((...((((((......)))))).....(.((((.....))))....))))).
+(((((((((((((......)))))).......((((.....))))))..))))).
+(((((...((.(((.(.((((....)))).)........))).))....))))).
+........(((((......))))).((.....((((.....)))).....))...
+........(((((......)))))........(((.......)))..........
+..((((.((((((......)))))).......((((.....))))...))))...
+(((((((((((((......))))))..))((....((....)).))...))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(.((((......)))).........((((.....)))).).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.(((((.((((.(......).)))).(....)((((.....))))...)))))..
+.............((((....))))(((....((((.....))))....)))...
+((((((.((((((......))))))........(((.....)))....)))))).
+((((((.((((((......)))))).(.....((((.....))))..))))))).
+((((((.((..(((..((..(........)..)).....)))..))..)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.(((((..(((((......)))))........((((.....))))...)))))..
+.((((..((((((......)))))).......((((.....))))....))))..
+....(((((((((......))))))..)))..((((.....))))..........
+((((((.....(((......(.((.(....).)))....)))......)))))).
+((((((..(((((......))))..)......((((.....))))..).))))).
+((((((((((((........)))))..)))..((((.....)))).....)))).
+(((((...((((........))))..(.....((((.....))))..).))))).
+(((((..((((((......))))))(......((((.....)))))...))))).
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.((((((.((((........))))...)))..((((.....)))).....)))..
+.......((((....((....))...)).).)((((.....))))..........
+((((((.((((((......)))))).(.....((((.....))))..))))))).
+((((((..((((.((...)))))).....((.............))..)))))).
+((((((..........................................)))))).
+((((.............((((....))))...((((.....)))).....)))).
+((((((..(((((......)))))........((((.....))))...)))))).
+.......((((((......)))))).......((((.....))))..........
+.(((((..((....(((....)))....))..((((.....))))...)))))..
+((((((........(((....)))........((((.....))))...)))))).
+((((((.((((((......))))).....((..(((.....)))))).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......(..((....)).)...)))))).
+((((((.(((.(((.((((((....))))........)).))))))..)))))).
+....((((((((..(...).)))))..)))..((((.....))))..........
+.........((....)).........((....((((.....))))....))....
+.(((((..((((........)))).....(..((((.....)))))..)))))..
+((((((((.................................))).....))))).
+(((((...(((((......)))))........((((.....))))....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+((....(((.........(((....)))....((((.....))))....))))).
+(((((((((((((......))))))..))...((((.....))))....))))).
+.(....)((((((......))))))(((....((((.....))))....)))...
+....(((((.(((......))).))..)))..((((.....))))..........
+.(((((.((((((......)))))).......((((.....))))...)))))..
+(((((((((.........)))...........((((.....))))...)))))).
+((((((..((........(((....)))))..((((.....))))...)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+.((((((((((((......))))))..))...(((.......)))....))))..
+.........(....(((....)))........((((.....)))).....)....
+(.......(..((.....(.(....).)...))..).....).............
+(((((((.(((..........)))........((.........)))..)))))).
+((((((.((((((......))))))(....).((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(...(((...((((....))))...........)))....))))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+.(((((((((((........)))).................))))).....))..
+.(.....((((((......))))))....)..(((.......)))..........
+..(((((((((((......)))))).....))((((.....))))....)))...
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((..((((((......))))))........(((.....))).....))))).
+(((((.((((((.(.....))))))..)....((((.....))))....))))).
+(((((.(.(((((......)))))......).((((.....))))....))))).
+((((((.((((((((..((((....))))))))).........)))..)))))).
+.((((..((((((......)))))).......((((.....))))....))))..
+.((((..(((....))).))))...(((....((((.....))))....)))...
+((((((...(.(((......((......)).........)))).....)))))).
+(((((((((((((......))))))..)....((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..........................((((.....))))...)))))).
+((((((...........((((....))))...((((.....))))...)))))).
+.((.(((((((((......))))))..)))..)).....................
+.(((((.((((((......))))))(......((((.....)))))..)))))..
+..(((.............)))...........((((.....))))..........
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))........((((.....))))...)))))).
+((((((.(......(..........)......)(((.....)))....)))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+(((((((((((((......)))))).......((((.....))))))..))))).
+................................(................).....
+.(((((........(..............)..((((.....))))...)))))..
+.......((((((......)))))).......((((.....))))..........
+(((((..((((((......)))))).......((((.....))))....))))).
+((((((.((((((......))))))...)...((((.....))))....))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.((((((......)))))........((((.....)))).).)))))).
+....((((((((........)))))..)))..((((.....))))..........
+.(((...(((((........)))))......))).....................
+.((.((.(((.((((..((((....)))).....)....))).)))..)).))..
+((((((.......(((......))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......................)))))).
+((((((.((.((........)).)).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.......((((((......)))))).......((((.....))))..........
+.......((((((......))))))........(((.....)))...........
+.(((((.(((((........))))).......((((.....))))...)))))..
+((((....(((((......)))))..(.....((((.....))))..)..)))).
+((((((...........((((....))))...((((.....))))...)))))).
+((((((.(((((........))))).......((((.....))))..).))))).
+(((((..((((((......)))))........(((.......))).)..))))).
+(((((...(((((......)))))........((((.....))))....))))).
+........(((((......))))).(((.....(((.....))).....)))...
+....((((((((........)))))..)))..((((.....))))..........
+(((((............((((....))))...((((.....))))....))))).
+((((((.((((((......))))))..(.......)............)))))).
+((((((..((((........))))........((((.....))))...)))))).
+(((((((.(((((......)))))........((((.....)))))..)))))).
+((((((.((((((......))))))....((.............))..)))))).
+.(((((.((((((......)))))).......((((.....))))...)))))..
+....(((((((((......))))))..)))(.....)..................
+.......((((((......))))))................(.......).....
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(......(((....)))........((((.....)))).).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((.(...))))))).......((((.....))))...)))))).
+((((((.(((.((((.(.(.((......))..)).)...))).)))..)))))).
+.((((...((((........))))........((((.....))))....))))..
+...((((((((((......))))))..))))..(((.....)))...........
+.((((.............))))..........((((.....))))..........
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+((((((((..(((((..((((....))))))))).......))).....))))).
+(((((...(((((......)))))........(..((....)).)....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+.......((((((......))))))(((.(..((((.....)))))...)))...
+.(((((..(((((......)))))))......((((.....)))).....)))..
+.............((((....))))(((....((((.....))))....)))...
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))..(....).(((.....)))....)))))).
+((((...((((((......))))))..(....((((.....))))....))))).
+((((((.(((((........))))).......(((.......)))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+.....(.((((((......)))))).......((((.....))))..).......
+.(((((........(..((((....)))))...((.......))....)))))..
+....((((((((........)))))..))).........................
+((((((((..((((((...((....)).)))))).......)).....)))))).
+((((((.((((((......))))))....(..((((.....)))))..)))))).
+((((((..((((..(...).)))).....(..(((.......))))..)))))).
+((((((.((((((......)))))........((((.....)))).).)))))).
+((((((.((((((......))))))........(((.....)))....)))))).
+.......((((((......)))))).......((((.....))))..........
+.(((((..(((((......)))))........(((.......)))...)))))..
+(((((((.((.((((...(.(........)..)...)..))).))))..))))).
+(((((..........(.((((....)))).)..................))))).
+(((((..(((((.((...))))))).......((((.....))))....))))).
+(((((..((((((......))))))(((.........)..)).......))))).
+(((((......(.(((......)))..)....((((.....))))....))))).
+(......(((((........))))).......)(((.....)))...........
+.......((((((......))))))(((....((((.....))))....)))...
+.(((((......(.(((....))))(....)..(((.....)))....)))))..
+((((((.....(((.((((((....))))........)))))......)))))).
+(((((((((((((......))))))..)....((((.....))))...)))))).
+(((((((((((((......))))))..)))..(((.......))).....)))).
+(((((((((.........)))...........((((.....))))...)))))).
+((((((..((.(..(((....)))...)))...(((.....)))....)))))).
+....(((((.(((((..............))))).).....))))..........
+...(....).................((....((((.....))))....))....
+.((((((((((((......))))))..)))).)).....................
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))..(.....((((.....))))..))))))).
+(((((((.((((........))))........((((.....)))))..)))))).
+(((((...(((((......))))).)......(((.......))).....)))).
+.(((((.((((((......)))))).(.....((((.....))))..))))))..
+.......((((((......))))))(((....((((.....))))....)))...
+.....((......................................))........
+(((((...(((((......)))))........((((.....))))....))))).
+(((((..(((((........)))))(......((.........)))...))))).
+(((((..((((((......))))))(....).((((.....))))....))))).
+(((((((.(((((......)))))...))...((((.....))))....))))).
+((((((.(((.(((.........................))).)))..)))))).
+.(((((..........)((.............(((.......)))))..))))..
+...((((((((((......)))))).......((((.....))))))..))....
+.......((((((......))))))....(..((((.....))))......)...
+((((((.(((((........)))))........(((.....)))....)))))).
+((((((.((((((......)))))).(...).((((.....))))...)))))).
+((((((...(.......((((....))))...((((.....)))))..)))))).
+((((((..............(....)......((((.....))))...)))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+.(((((.((((((.(...))))))).......((((.....))))...)))))..
+.................((((....))))...((((.....))))..........
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((....(((......)))..........((((.....))))...)))))).
+((((((..............(........)..((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+(((((((((((((......))))))..)))...(((.....)))......)))).
+........(((((......))))).((.....((((.....)))).....))...
+.(((((..(........((((....)))))..((((.....))))...)))))..
+.(((((.((((((......)))))).......(((.......)))...)))))..
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((((((((((......))))))..))...((((.....))))....))))).
+((((((..(((((......)))))(((....))).((....)).....)))))).
+((((((.(.........((...........))...............))))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+...((((.(((((......)))))...)))).(((.......)))..........
+.(((((..(((((......)))))........(((.......)))...)))))..
+.((((..(((.(((...........(....)........))).))..).))))..
+((((((.((((((......))))))....(..((((.....)))))..)))))).
+((((((.(((.(((.........................))).)))..)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+.................((...........))............((......)).
+....(((((((((......))))))..)))..((((.....))))..........
+......((((........(((....)))....((((.....))))...))))...
+((((((.....(.....((((....))))...((((.....)))))..)))))).
+(((((((((((((......))))))..)....(((.......)))...)))))).
+((((((.((((((......)))))).(..((.............)).))))))).
+((((((..(((((......)))))........((((.....)))))...))))).
+(((((...(((((.(...))))))........(((.......)))....))))).
+.......((((((......)))))).......((((.....))))..........
+........(((((......))))).(((.(..((((.....)))))...)))...
+....((((((((........)))))..)))..((((.....))))..........
+((((((((((((........))))).....))((((.....))))....))))).
+((((((..(((((......)))))........(((.......)))...)))))).
+((((((.....((((..((((....))))))))..((....)).....)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+.......(((((..(...).))))).....(.((((.....))))....).....
+....((((((((........)))))..)))...((..........))........
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.((((((.(...))))))........((((.....)))).).)))))).
+((((((.((((((......))))))(....).(...)...........)))))).
+((((((..((((........))))........((((.....))))...)))))).
+((((((.((((((......))))).....(..((((.....)))))).)))))).
+.((((..(((.(((.........(..(....))......))).)))...))))..
+........(((((......))))).(((....((((.....))))....)))...
+.(.....((((((......))))))....)......(....).............
+((((((.(((((........))))).(.....((((.....)))).).)))))).
+(((((((((((((.(...))))))).......((((.....))))))..))))).
+(((((.......((....(((....)))....((((.....))))..))))))).
+(((((..((((((......)))))).(....)((((.....))))....))))).
+(((((..(((((........))))).......((((.....))))....))))).
+.(((....(((((......)))))........((((.....)))).....)))..
+.((((((((((((......))))))..)))..((((.....)))).....)))..
+.........................(((....((((.....))))....)))...
+((((....((.(((...((((....))))..........))).)).....)))).
+((((((...........((((....))))...((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+.............................((.((((.....)))).......)).
+.(((((..((...((((....))))...))..((((.....))))...)))))..
+.(((((.((((((......))))))....(..((((.....)))))..)))))..
+((((((....((((((..(((....))))))))).((....)).....)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+(((((((.(((((......)))))........((((.....)))))..)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+.......((((((......))))))(((....((((.....))))....)))...
+.......((((((......)))))).......((((.....))))..........
+.(..(((.......((....))........))((((.....))))....)..)..
+(((((..((((((......))).....................)))...))))).
+(((((...(((((.(...))))))........((((.....))))....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((..(((((........))))).......((((.....))))....))))).
+(((((((((((((......))))))..))...((((.....))))....))))).
+..(....((((((.(...))))))).....).....(....).............
+........(((((......)))))........((((.....))))..........
+((((((..((.(((.(.((((....)))).)........))).))...)))))).
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+((((((.((((((......))))))........(((.....)))....)))))).
+((((((.....(((((.((((....)))).).....)..)))......)))))).
+(((((((((((((......))))))..)....((((.....))))...)))))).
+.......((((((......))))))((.....((((.....)))).....))...
+.......((((((......)))))).......((((.....))))..........
+..((.......(((....(.............)......)))........))...
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((...((((((......))))))..(....((((.....))))....))))).
+((((((.((((((......)))))).......(((.(....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+.(((.((((((((......))))))..))..))).....................
+.......((((((......))))))((.......................))...
+....(((((((((......))))))..)))..((((.....))))..........
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((((.(((((......)))))...))...((((.....))))....))))).
+(((((............................................))))).
+.........((((......))))(.(((....((((.....))))....))).).
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.((((...(......)..))))....((....((((.....))))....))....
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((.(((.........(......)........))).)))..)))))).
+((((((.((((((......))))))....(..(((.......))))..)))))).
+((((((.((((((......))))))....(..((((.....)))))..)))))).
+.(((((.(((((........))))).......((.((....))))...)))))..
+.((((..(((((........))))).......((((.....))))....))))..
+....(((((((((......))))))..)))..((((.....))))..........
+((((((......((...((((....))))..........)).......)))))).
+((((((((((((........)))))..)....((((.....))))...)))))).
+(((((((.(((((......)))))...)))..((((.....)))).....)))).
+(((((((((.........))).((........))((.....)).....)))))).
+((((((.(((.((((..((((....)))).....)....))).))))..))))).
+((.....))((((......)))).........((((.....))))..........
+.(((((.((((((.(...))))))).......((((.....))))...)))))..
+(((((..((((..........))))((....((...))...))......))))).
+(((((((.((.((......))...)).))...((((.....))))....))))).
+(((((((((((((......)))))).....))((((.....))))....))))).
+(((((((.(((((......)))))........((((.....)))))..)))))).
+((((...((((((......)))))).......((((.....)))).....)))).
+....(((((((((......))))))..)))..((((.....))))..........
+(...(((.(((((......)))))...)))..((((.....))))......)...
+.((((((((((((......)))))).......((((.....))))))..))))..
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.((((((......)))))........(.((.....)).).).)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((......((((........)))).(((.....(((.....))).....))))).
+((((((.(((.((....((((....)))).(....)....)).)))..)))))).
+....(((((.(......)))).)).(((....((((.....))))....)))...
+...((((.((((........))))...)))).((((.....))))..........
+.(((((.((((..........)))).......((((.....))))...)))))..
+((((((.((((((......))))))....((..(((.....)))))..)))))).
+((((((.(((((........)))))(...................)..)))))).
+(((((((..(.(........)...).......((((.....))))))..))))).
+(((((......(((.........(......)........))).......))))).
+..(((...((....))..)))..(.(((....(((.......)))....))).).
+.......((((((......)))))).......((((.....))))..........
+....(((((((((.(...)))))))..))).........................
+(((((...((..................))..((((.....))))....))))).
+((((((...((((......)))).........((((.....))))...)))))).
+(((((((((((((......)))))).....).((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......))))))...))..((((.....)))).....)))).
+.((((..((.....(((....))).....)).((((.....))))....))))..
+..(.....(((((......)))))...)....((((.....))))..........
+..((((.....((..(....(.((........)))...).))......))))...
+((((((((((((........))))).......(((.......))))..)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......))))).(......)(((.....)))....)))))).
+((((((.(((((........))))........((((.....)))).).)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+.(((((.((((((......)))))).......(((.(....))))...)))))..
+........(((((......))))).(((....((((.....))))....)))...
+((((((.((((((......)))))).......((((.....))))...)))))).
+(((((((((((((......)))))).......((((.....))))))..))))).
+(((((..(((.(.((..((.((......)))).....)..)).)))...))))).
+(((((...((((........)))).....(..((((.....)))))...))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+....(((((((((......))))))..))).........................
+.((((((.(((((......)))))...)))..((((.....)))).....)))..
+...(((((((((........)))))..)))).((((.....))))..........
+((((((.....(((.((((((....))))........)).))).....)))))).
+((((((((((((........)))))..)....(....)..........)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((....)).(.((....)).)(..((((.....)))))..)))))).
+((((((...........((((....))))...(((.......)))...)))))).
+....(((((((((......))))))..))).........................
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.......(((((........))))).......((((.....))))..........
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..((............))........((((.....))))...)))))).
+((((((....((((((..(((....))))))))).((....)).....)))))).
+((((((.((((((.(...))))))).......(((.......)))...)))))).
+.......................(.(((....((((.....))))....))).).
+....(((((((((......))))))..)))(.((((.....))))....).....
+.(((((.(.(..(((...))).).........((((.....)))).).)))))..
+(((((..(.(((........)))..........((((....))..)).)))))).
+(((((...(((((......)))))........((((.....))))....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((..((((((......))))))..(.......).............))))).
+(((((((((((((......))))))..))...((((.....))))....))))).
+(..((((((((((......))))))..)))).)....(..........)......
+....(((((.((((((..(((....))))))))).).....))))..........
+.((.((.(((.(((....(.(........)..)......))).)))..)).))..
+((((((.((((..........)))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((.(((.........................))).))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+.......((.(((......))).))(((....((((.....))))....)))...
+...((((((((((......))))))..)))).((((.....))))..........
+(((((((((((((......))))))..)))).((((.....))))......))).
+((((.((.((((........))))........((((.....))))))...)))).
+((((((...........((((....))))...((((.....))))...)))))).
+((((((.((((((......))))))(....).((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+.(((((((((((........)))))..))...((((.....))))....))))..
+....(((((((((......))))))..)))...(((.....)))...........
+.((((.............))))..........(.((.....)).)..........
+(.((((.((((((......)))))).......((((.....))))...)))).).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((((..((((......))))....))...((((.....))))....))))).
+(((((((((((((......)))))).....))((((.....))))....))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.(((((.(((((........))))).......((((.....))))...)))))..
+.((((((.(((((......)))))...)))).)).....................
+....((..(((((.(...))))))))((....((((.....))))....))....
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.(((.(((...((((....))))..........))).)))..)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......(((.......)))...)))))).
+.......................(...(....((((.....))))....)...).
+.((((...(((((......)))))........((((.....))))....))))..
+.......((((((......))))))((.....((((.....)))).....))...
+((((((..((.((((..((((....))))).........))).))...)))))).
+((((((.((((((......))))))...))..((((.....)))).....)))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.....(((((..(((....))))))))...............)))))).
+(((((((.(((((......)))))(((....)))...........))..))))).
+...((((((((((......))))))..)))).((((.....))))..........
+.(((((.(((((........))))).......((((.....))))...)))))..
+.............(((.((.............((((.....)))))).)))....
+(((((.(.((((........))))...)....(((.......)))....))))).
+(((((...((...((((....))))...))..((((.....))))....))))).
+(((((((((.........))).))......(.((((.....))))....))))).
+((((((.((((((......)))))).(.....((((.....))))..))))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+..............(...).............((((.....))))..........
+.(((((.(.........((((....))))...((((.....)))).).)))))..
+((((((..((((........))))........((((.....))))...)))))).
+((((((.((((((......)))))........((((.....))))..))))))).
+((((((.((.((........)).)).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.((((((......))))).((...(.....)...))....).)))))).
+...((((((((((......))))))..))))....((....))............
+.......((((((......)))))).(.....((((.....))))......)...
+.(((((.(((((........)))))((....))((.......))....)))))..
+((((((.((((((......)))))).......((((.....))))...)))))).
+(((((((((((((......))))))..)))..((((.....)))).....)))).
+(((((((((((((......)))))).......(((.......)))))..))))).
+(((((..((((((......))))).(....).((((.....)))))...))))).
+(((((...(((((......)))))........((((.....))))....))))).
+....(((((.((((((...((....)).)))))).).....))))..........
+(...(((..(((........)))....)))).((((.....))))..........
+..(.(((((((((......))))))..))))....((....))..(......)..
+((((((...........((((....))))...................)))))).
+((((((...........((((....))))...((((.....))))...)))))).
+((((((((((((........)))))..)))..((((.....)))).....)))).
+((((((....((........)).......(..((((.....)))))..)))))).
+...((.(..((((......))))....(....((((.....))))....).))).
+.........................(((....((((.....))))....)))...
+.....((((((((......))))))..))...((((.....))))..........
+((((((.......(...((((....))))..)((((.....))))...)))))).
+((((((.(((((........))))).(.....((((.....)))).).)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+(((((((((((((......)))))).......((((.....)))))..)))))).
+((((...((((((......)))))).(.....((((.....))))...).)))).
+.(((((.((((((......)))))).......((((.....))))...)))))..
+....(((((((((......))))))..)))..(((.......)))..........
+....(((((((((......))))))..))).....(...............)...
+((((((..((((........))))........((((.....))))...)))))).
+(((((.((..(......((...........)).....)..)).......))))).
+(((((...(((((......)))))..(.....(((.......)))..).))))).
+(((((..((((((......))))))(....).((((.....))))....))))).
+(((((..((((((......))))))........(((.....))).....))))).
+.((((((((((((......))))))..)))..((((.....)))).....)))..
+........(((((......)))))..(.....((((.....))))...)......
+((((((.(.(((........)))..((..............)))....)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((.((....))))...)))))).
+((((((.....(.....((((....))))....(((.....))).)..)))))).
+(((((((((((((......))))))..)....((((.....))))...)))))).
+.........(((........)))..(((....((((.....))))....)))...
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.((((..(((((........)))))........(((.....))).....))))..
+((((((.((((((......))))))....((..(((.....)))))..)))))).
+((((((...((((......))))......(..((((.....)))))..)))))).
+((((((.........(.(((......))).).((((.....))))...)))))).
+((((((.((((((......)))))).(....)((((.....))))...)))))).
+(((((((((((..........))))..)))..((((.....)))).....)))).
+.......((((((......)))))).......((((.....))))..........
+.(((((.((((((......)))))((......))............).)))))..
+.(((((.((((((......)))))).......((((.....))))...)))))..
+(((((.(((.........)))...........((((.....))))....))))).
+(((((..(((((........))))).......((((.....))))....))))).
+(((((..((((((......)))))).......((((.....))))....))))).
+(((((((((((((......))))))..))((....((....)).))...))))).
+((((((((((((........)))))..)...)((((.....))))....))))).
+....(((.(((((......)))))...)))..((((.....))))..........
+......(((...((((.((((....))))..((...)).....))))..)))...
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((.(((.(((.(.((((....)))).)........))).)))..)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.........((((......)))).........((((.....))))..........
+.......(((((........)))))(((....((((.....))))....)))...
+.......(((((........))))).......((((.....))))..........
+(((((((((((((......))))))..)))).((.(.....).))......))).
+(((((((((((((......))))))..)....((((.....))))...)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((....)))(((....)))....((((.....))))...)))))).
+((((((...........((((....))))...((((.....))))...)))))).
+...((((.(((((......)))))...)))).((((.....))))..........
+....((((((((........)))))..))).........................
+(((((...(((((......))))).....(..((((.....)))))...))))).
+(((((..((((((......))))))(....).((((.....))))....))))).
+(((((.(((((((......))))))..)....((((.....))))....))))).
+(((((............((((....))))...((((.....))))....))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.......(((((........)))))(.(....((((.....))))....).)...
+....((((((((........)))))..))).........................
+(((.((((((((........)))))..)))..((((.....))))......))).
+((((((.((((((......))))).....(..((((.....)))))).)))))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.((.(((.....(((....)))...)))((.....)).))..)))))).
+.((((...(((((((..((((....)))))))))((.....))))....))))..
+.(((((............(((....))).....(((.....)))....)))))..
+.......((((((......))))))(((....((((.....))))....)))...
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((.......((((....)))).......(((.(....))))...)))))).
+((((((..((.(((......((.(......).)).....))).))...)))))).
+(((((((.(((((......)))))........((((.....))))))..))))).
+(((((..((..(((((.(.........))))))(........).))...))))).
+.(((((.((((((......)))))).......((((.....))))...)))))..
+.((((..((((((......)))))).......((((.....))))....))))..
+(((.((.((((((......))))))...))(.((((.....))))....).))).
+((((.((((((((.(...))))))).....).((((.....))))...).)))).
+((((((..((...(((......)))...))...(((.....)))....)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..((((........))))..(.....((((.....))))..))))))).
+.......((((((......))))))(((....((((.....))))....)))...
+...((((((((((......))))))..)))).((((.....))))..........
+.(((((.(((((........))))).(.....((((.....))))..))))))..
+((((((..........................................)))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+((((((..(((((......)))))........((((.....))))...)))))).
+((((((.((((((.(...))))))........((((.....))))..))))))).
+((((((.((((((......)))))).......((((.....))))...)))))).
+...((((.((....(((....))))).))))........................
+................................((((.....))))..........
+(((....(((((........))))).......(((.......)))......))).
+((((((.(((((........))))).......((((.....))))...)))))).
+((((((.(((........(.(........)..)..........)))..)))))).
+(((((.((((((........)))))....(...........)...)...))))).
+(((((...(((((......)))))........((((.....))))....))))).
+.......((((((......))))))(((....((((.....))))....)))...
+........(((((......)))))........((((.....))))..........
+..(((((((((((......))))))..))...((((.....))))....)))...
+(((((......(((((..(((....))))))))...(....).......))))).
diff --git a/./rand.h b/./rand.h
new file mode 100644
index 0000000..d47d2c3
--- /dev/null
+++ b/./rand.h
@@ -0,0 +1,62 @@
+#ifndef __INC_RAND_H__
+#define __INC_RAND_H__
+
+#include <cstdlib>
+class Die
+{
+public:
+  Die(unsigned int seed)
+  {
+    srand(seed);
+  }
+
+  double operator()()
+  {
+    return rand()/(RAND_MAX+1.0);
+  }
+};
+
+template < class T, class RealT >
+class Roulette
+{
+public:
+    Roulette(Die &die)
+        : t_(), max_(NEG_INF), die_(die)
+    { }
+
+    void add(T t, RealT v)
+    {
+        t_.push_back(std::make_pair(t, v));
+        max_ = std::max(max_, v);
+    }
+
+    T choose() const
+    {
+        RealT sum = 0.0;
+        std::list<std::pair<T,RealT> > u;
+        typename std::list< std::pair<T,RealT> >::const_iterator x;
+        for (x=t_.begin(); x!=t_.end(); ++x)
+        {
+            u.push_back(std::make_pair(x->first, Fast_Exp(x->second - max_)));
+            sum += u.back().second;
+        }
+
+        Assert(sum>0.0, "sum not > 0");
+        RealT r = die_()*sum;
+        RealT s = 0.0;
+        for (x=u.begin(); x!=u.end(); ++x)
+        {
+            s += x->second;
+            if (r<s) return x->first;
+        }
+        return u.back().first;
+    }
+
+    unsigned int size() const { return t_.size(); }
+
+private:
+    std::list<std::pair<T,RealT> > t_;
+    RealT max_;
+    Die& die_;
+};
+#endif  //  __INC_RAND_H__
\ No newline at end of file
diff --git a/./revi_patch b/./revi_patch
new file mode 100644
index 0000000..6f82b32
--- /dev/null
+++ b/./revi_patch
@@ -0,0 +1,4350 @@
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.hpp b/./ComputationEngine.hpp
+index 4166df6..68d656c 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.hpp
++++ b/./ComputationEngine.hpp
+@@ -18,6 +18,7 @@
+ #include "DistributedComputation.hpp"
+ #include "FileDescription.hpp"
+ #include <vector>
++#include <cstdlib>
+ 
+ //////////////////////////////////////////////////////////////////////
+ // struct SharedInfo
+@@ -37,6 +38,7 @@ struct SharedInfo
+     bool use_nonsmooth;
+     bool use_loss;
+     RealT gamma;
++    RealT sigma;
+     RealT log_base;
+ //    std::vector<int> evidence_cpd_id;
+     RealT evidence_data_scale;
+@@ -76,7 +78,10 @@ enum ProcessingType
+     COMPUTE_GRADIENT_SE,
+     CHECK_ZEROS_IN_DATA,
+     COMPUTE_HV,
+-    PREDICT
++    PREDICT,
++    SAMPLE,
++    TEST_ENERGIES,
++    REVI,
+ };
+ 
+ struct NonSharedInfo
+@@ -125,6 +130,9 @@ public:
+     void ComputeGammaMLEFunctionAndGradient(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared, bool need_gradient);
+     void ComputeHessianVectorProduct(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+     void Predict(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
++    void Sample(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
++    void RunREVI(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
++    void TestEnergies(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+     void CheckZerosInData(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+     void ComputeGammaMLEScalingFactor(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+     void ComputeFunctionAndGradientSE(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared, bool need_gradient);
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.ipp b/./ComputationEngine.ipp
+index 742d4c0..6903662 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.ipp
++++ b/./ComputationEngine.ipp
+@@ -89,6 +89,15 @@ void ComputationEngine<RealT>::DoComputation(std::vector<RealT> &result,
+         case PREDICT:
+             Predict(result, shared, nonshared);
+             break;
++        case SAMPLE:
++            Sample(result, shared, nonshared);
++            break;
++        case REVI:
++            RunREVI(result, shared, nonshared);
++            break;
++        case TEST_ENERGIES:
++            TestEnergies(result,shared,nonshared);
++            break;
+         default: 
+             Assert(false, "Unknown command type.");
+             break;
+@@ -1043,7 +1052,7 @@ void ComputationEngine<RealT>::ComputeFunctionAndGradientSE(std::vector<RealT> &
+                 }
+ 
+                 int index_k = parameter_manager.GetLogicalIndex(
+-                    inference_engine.GetLogScoreEvidence(0, i, j, dataset_id));
++                    inference_engine.GetLogScoreEvidence(0, i, j, dataset_id)); // i: seq, j: pr or unpaired, ds=0
+                 int index_theta = parameter_manager.GetLogicalIndex(
+                     inference_engine.GetLogScoreEvidence(1, i, j, dataset_id));
+ 
+@@ -1210,6 +1219,268 @@ void ComputationEngine<RealT>::ComputeHessianVectorProduct(std::vector<RealT> &r
+     
+     result = (result - result2) / (RealT(2) * EPSILON);
+ }
++//////////////////////////////////////////////////////////////////////
++// ComputationEngine::TestEnergies()
++//
++// Print energies for a single sequence.
++//////////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void ComputationEngine<RealT>::TestEnergies(std::vector<RealT> &result, 
++                                       const SharedInfo<RealT> &shared,
++                                       const NonSharedInfo &nonshared)
++{
++    result.clear();
++
++    // load sequence, with constraints if necessary
++    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
++    inference_engine.LoadSequence(sstruct);
++    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
++
++    // load parameters
++    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
++    inference_engine.LoadValues(w * shared.log_base);
++
++    inference_engine.UpdateEvidenceStructures();
++
++    // perform inference
++    SStruct *solution;
++
++    inference_engine.ComputeViterbi();
++
++    if (options.GetBoolValue("use_evidence")){
++        inference_engine.GetViterbiFeaturesESS();
++    }
++    else{
++            inference_engine.GetViterbiFeatures();
++    }
++
++    std::cout << "Viterbi score for \"" << descriptions[nonshared.index].input_filename << "\": " 
++            << inference_engine.GetViterbiScore() << std::endl;
++
++    solution = new SStruct(sstruct);
++    solution->SetMapping(inference_engine.PredictPairingsViterbi());
++
++    WriteProgressMessage("");
++    solution->WriteParens(std::cout);
++
++    delete solution;
++}
++
++//////////////////////////////////////////////////////////////////////
++// ComputationEngine::REVI()
++//
++//////////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void ComputationEngine<RealT>::RunREVI(std::vector<RealT> &result, 
++                                       const SharedInfo<RealT> &shared,
++                                       const NonSharedInfo &nonshared)
++{
++    result.clear();
++
++
++    // perform inference (repurposing chem mapping potentials as pairwise potentials)
++
++    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
++    inference_engine.LoadSequence(sstruct);
++    inference_engine.InitializeREVIVec();
++
++    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
++    // load parameters
++
++    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
++    inference_engine.LoadValues(w * shared.log_base);
++
++    int L = sstruct.GetLength();
++    int n_samples = 1000;
++    int n_iters = 100;
++    double last_loss_0 = 100000000;
++    double last_loss_1 = 100000000;
++    double last_loss_2 = 100000000;
++    double step_size = 0.1;
++
++    RealT sigma = shared.sigma;
++
++    for (int k=1; k<=n_iters; k++){
++
++    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
++    inference_engine.LoadValues(w * shared.log_base);
++
++    inference_engine.ComputeInsideESS();
++
++    std::vector<RealT> unp_i(L,0.0);
++    std::vector<RealT> pr_i(L,0.0);
++
++    std::vector<std::vector<RealT> > p_j_unp_given_i_unp;
++    std::vector<std::vector<RealT> > p_j_paired_given_i_paired;
++
++    for (int i=0; i< L; i++)
++    {    
++        std::vector<RealT> vec(L,0.0);
++        p_j_unp_given_i_unp.push_back(vec);
++        p_j_paired_given_i_paired.push_back(vec);
++    }
++
++    for (int sample_ind = 0; sample_ind < n_samples; sample_ind++)
++    { 
++
++    int seed = rand();
++    inference_engine.InitRand(seed);
++    std::vector<int> map = inference_engine.PredictPairingsStochasticTracebackESS();
++
++    // count occurences from samples
++    for (int i=0; i< L; i++)
++        {
++            if (map[i+1] == 0){
++                unp_i[i] += 1;
++
++                for (int j=0; j<L; j++){
++                    if (map[j+1] == 0)
++                    {
++                        p_j_unp_given_i_unp[i][j] += 1;
++                    }
++                }
++        }
++        else{ // base is paired
++            pr_i[i] += 1;
++             for (int j=0; j<L; j++){
++                        if (map[j+1] != 0)
++                        {
++                            p_j_paired_given_i_paired[i][j] += 1;
++                        }
++                    }   
++        }
++    }
++
++}
++    // normalize probability counts for p_unpaired vector
++
++    for (int i=0; i< L; i++)
++        {
++            if (unp_i[i] > 0){
++
++                for (int j=0; j<L; j++){
++                    p_j_unp_given_i_unp[i][j] /= unp_i[i]; 
++                }
++            }
++            unp_i[i] /= n_samples;
++    }
++
++    // normalize probability counts for p_paired vector
++    for (int i=0; i< L; i++)
++        {
++            if (pr_i[i] > 0){
++
++                for (int j=0; j<L; j++){
++                    p_j_paired_given_i_paired[i][j] /= pr_i[i]; 
++                }
++            }
++            pr_i[i] /= n_samples;
++    }
++
++    std::vector<RealT> error = inference_engine.GetREVIError(unp_i);
++    std::vector<std::vector< double> > currREVIvec_up = inference_engine.GetREVIvec_up();
++    std::vector<std::vector< double> > currREVIvec_pr = inference_engine.GetREVIvec_pr();
++
++    std::vector<RealT> update_unp(L,0.0);
++    std::vector<RealT> update_pr(L,0.0);
++
++    // get p_i, p_i_given_j
++    // write gradient
++
++    double curr_loss = 0.0;
++
++    // get gradient for unpaired potentials
++    for (int j=0; j< L; j++){
++
++     for (int i=0; i< L; i++)
++        {    
++        update_unp[j] += sigma*step_size*error[i]*unp_i[i]*(unp_i[j] - p_j_unp_given_i_unp[i][j]);
++        update_pr[j] += sigma*step_size*error[i]*pr_i[i]*(pr_i[j] - p_j_paired_given_i_paired[i][j]);
++
++            }
++        update_unp[j] += -2*step_size*currREVIvec_up[0][j];
++        update_pr[j] += -2*step_size*currREVIvec_pr[0][j]; //UPDATE to be curr REVI vec for paired
++
++        }
++
++    for (int i=0; i< L; i++)
++        {   
++        curr_loss += pow(currREVIvec_up[0][i],2) + sigma*pow(error[i],2) + pow(currREVIvec_pr[0][i],2); // UPDATE to be curr REVI vec for paired
++        }     
++
++
++    if ((abs(last_loss_2 - curr_loss) < 0.1) || k==n_iters){
++        // We're done, sample and print structures one more time
++
++    SStruct *solution;
++
++    if (options.GetStringValue("output_bpseq_destination") != "")
++    {
++        solution = new SStruct(sstruct);
++        //solution->SetMapping(inference_engine.PredictPairingsViterbi());
++
++        const std::string filename = MakeOutputFilename(descriptions[nonshared.index].input_filename,
++                                                        options.GetStringValue("output_bpseq_destination"),
++                                                        options.GetRealValue("gamma") < 0,
++                                                        shared.gamma);
++        std::ofstream outfile(filename.c_str());
++        if (outfile.fail()) Error("Unable to open output bpseq file '%s' for writing.", filename.c_str());
++        solution->WriteBPPSEQ(outfile, inference_engine.GetREVIvec_up());
++        outfile.close();
++        delete solution;
++    }
++
++    if (options.GetStringValue("output_posteriors_destination") != "")
++    {
++        const std::string filename = MakeOutputFilename(descriptions[nonshared.index].input_filename,
++                                                        options.GetStringValue("output_posteriors_destination"),
++                                                        options.GetRealValue("gamma") < 0,
++                                                        shared.gamma);
++
++        inference_engine.ComputeOutsideESS();
++        inference_engine.ComputePosteriorESS();
++
++        RealT *posterior = inference_engine.GetPosterior(options.GetRealValue("output_posteriors_cutoff"));
++        SparseMatrix<RealT> sparse(posterior, sstruct.GetLength()+1, RealT(0));
++        delete [] posterior;
++        std::ofstream outfile(filename.c_str());
++        if (outfile.fail()) Error("Unable to open output posteriors file '%s' for writing.", filename.c_str());
++        sparse.PrintSparseBPSEQ(outfile, sstruct.GetSequences()[0]);
++        outfile.close();
++    }
++
++        for (int sample_ind = 0; sample_ind < 100; sample_ind++)
++            { 
++            solution = new SStruct(sstruct);
++            int seed = rand();
++            inference_engine.InitRand(seed);
++
++            solution->SetMapping(inference_engine.PredictPairingsStochasticTracebackESS());
++            solution->WriteParensOnly(std::cout);
++            delete solution;
++            }
++
++        break;
++    } else {
++        // continue
++        std::cerr << k << " " << curr_loss << std::endl;
++        std::cerr << "p_i " << unp_i << std::endl; 
++        std::cerr << "err " << error << std::endl;
++        last_loss_2 = last_loss_1;
++        last_loss_1 = last_loss_0;
++        last_loss_0 = curr_loss;
++
++        step_size /= 2;
++
++        inference_engine.UpdateREVIVec(update_unp, update_pr);
++    
++    }
++
++
++}
++}
+ 
+ //////////////////////////////////////////////////////////////////////
+ // ComputationEngine::Predict()
+@@ -1244,6 +1515,8 @@ void ComputationEngine<RealT>::Predict(std::vector<RealT> &result,
+         // Basically, add a ComputeViterbiESS and then call it to support this.
+ 
+         inference_engine.ComputeViterbi();
++        inference_engine.ComputeViterbiFeatureCounts();
++
+         if (options.GetBoolValue("partition_function_only"))
+         {
+             std::cout << "Viterbi score for \"" << descriptions[nonshared.index].input_filename << "\": " 
+@@ -1344,6 +1617,66 @@ void ComputationEngine<RealT>::Predict(std::vector<RealT> &result,
+     
+     delete solution;
+ }
++//////////////////////////////////////////////////////////////////////
++// ComputationEngine::Sample()
++//
++// Sample structures from predicted ensemble.
++//////////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void ComputationEngine<RealT>::Sample(std::vector<RealT> &result, 
++                                       const SharedInfo<RealT> &shared,
++                                       const NonSharedInfo &nonshared)
++{
++    result.clear();
++    
++    // load sequence, with constraints if necessary
++    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
++    inference_engine.LoadSequence(sstruct);
++    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
++
++    // load parameters
++    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
++    inference_engine.LoadValues(w * shared.log_base);
++
++    inference_engine.UpdateEvidenceStructures();
++
++    // perform inference
++    SStruct *solution;
++
++    int N = options.GetIntValue("nsamples");
++
++    //inference_engine.ComputePosterior(); // do we need this
++
++    if (options.GetBoolValue("use_evidence"))
++    {
++        inference_engine.ComputeInsideESS();
++
++    for (int sample_ind = 0; sample_ind < N; sample_ind++) { 
++
++    solution = new SStruct(sstruct);
++    inference_engine.InitRand(sample_ind);
++
++    solution->SetMapping(inference_engine.PredictPairingsStochasticTracebackESS());
++    solution->WriteParensOnly(std::cout);
++    delete solution;
++    }
++
++    } else {
++        inference_engine.ComputeInside();
++    
++    for (int sample_ind = 0; sample_ind < N; sample_ind++) { 
++
++    solution = new SStruct(sstruct);
++    inference_engine.InitRand(sample_ind);
++
++    solution->SetMapping(inference_engine.PredictPairingsStochasticTraceback());
++    solution->WriteParensOnly(std::cout);
++    delete solution;
++    }
++    }
++
++}
+ 
+ //////////////////////////////////////////////////////////////////////
+ // ComputationEngine::MakeOutputFilename()
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.hpp b/./ComputationWrapper.hpp
+index 1fe451b..13862ef 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.hpp
++++ b/./ComputationWrapper.hpp
+@@ -52,6 +52,8 @@ public:
+     RealT ComputeSolutionNormBound(const std::vector<int> &units, const std::vector<RealT> &C, RealT log_base);
+     RealT ComputeGradientNormBound(const std::vector<int> &units, const std::vector<RealT> &C, RealT log_base);
+     void Predict(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
++    void Sample(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
++    void RunREVI(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base, RealT sigma);
+     RealT ComputeLoss(const std::vector<int> &units, const std::vector<RealT> &w, RealT log_base);
+     RealT ComputeFunction(const std::vector<int> &units, const std::vector<RealT> &w, bool toggle_use_nonsmooth, bool toggle_use_loss, RealT log_base, RealT hyperparam_data);
+     std::vector<RealT> ComputeGradient(const std::vector<int> &units, const std::vector<RealT> &w, bool toggle_use_nonsmooth, bool toggle_use_loss, RealT log_base, RealT hyperparam_data);
+@@ -68,6 +70,7 @@ public:
+     
+     // for debugging
+     void SanityCheckGradient(const std::vector<int> &units, const std::vector<RealT> &w);
++    void TestEnergies(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
+ 
+     // getters
+     const Options &GetOptions() const { return computation_engine.GetOptions(); }
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.ipp b/./ComputationWrapper.ipp
+index 4a1fa43..f6d803b 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.ipp
++++ b/./ComputationWrapper.ipp
+@@ -888,6 +888,118 @@ void ComputationWrapper<RealT>::Predict(const std::vector<int> &units,
+     computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
+ }
+ 
++//////////////////////////////////////////////////////////////////////
++// ComputationWrapper::Sample()
++//
++// Run sampling algorithm on each of the work units.
++//////////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void ComputationWrapper<RealT>::Sample(const std::vector<int> &units,
++                                        const std::vector<RealT> &w,
++                                        RealT gamma,
++                                        RealT log_base)
++{
++    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
++    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
++
++    if (GetOptions().GetBoolValue("verbose_output"))
++    {
++        std::cerr << "Performing predictions with gamma=" << double(gamma) << "..." << std::endl;
++    }
++        
++    std::vector<RealT> ret;
++
++    shared_info.command = SAMPLE;
++    for (size_t i = 0; i < w.size(); i++)
++    {
++        shared_info.w[i] = w[i];
++    }
++    shared_info.gamma = gamma;
++    shared_info.log_base = log_base;
++    
++    nonshared_info.resize(units.size());
++    for (size_t i = 0; i < units.size(); i++)
++    {
++        nonshared_info[i].index = units[i];
++    }
++    
++    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
++}
++//////////////////////////////////////////////////////////////////////
++// ComputationWrapper::RunREVI()
++//
++// Run REVI on each of the work units.
++//////////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void ComputationWrapper<RealT>::RunREVI(const std::vector<int> &units,
++                                        const std::vector<RealT> &w,
++                                        RealT gamma,
++                                        RealT log_base,
++                                        RealT sigma)
++{
++    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
++    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
++
++    if (GetOptions().GetBoolValue("verbose_output"))
++    {
++        std::cerr << "Performing predictions with gamma=" << double(gamma) << "..." << std::endl;
++    }
++        
++    std::vector<RealT> ret;
++
++    shared_info.command = REVI;
++    for (size_t i = 0; i < w.size(); i++)
++    {
++        shared_info.w[i] = w[i];
++    }
++    shared_info.gamma = gamma;
++    shared_info.log_base = log_base;
++    shared_info.sigma = sigma;
++    
++    nonshared_info.resize(units.size());
++    for (size_t i = 0; i < units.size(); i++)
++    {
++        nonshared_info[i].index = units[i];
++    }
++    
++    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
++}
++//////////////////////////////////////////////////////////////////////
++// ComputationWrapper::TestEnergies()
++//
++// Run energy test.
++//////////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void ComputationWrapper<RealT>::TestEnergies(const std::vector<int> &units,
++                                        const std::vector<RealT> &w,
++                                        RealT gamma,
++                                        RealT log_base)
++{
++    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
++    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
++
++        
++    std::vector<RealT> ret;
++
++    shared_info.command = TEST_ENERGIES;
++    for (size_t i = 0; i < w.size(); i++)
++    {
++        shared_info.w[i] = w[i];
++    }
++    shared_info.gamma = gamma;
++    shared_info.log_base = log_base;
++    
++    nonshared_info.resize(units.size());
++    for (size_t i = 0; i < units.size(); i++)
++    {
++        nonshared_info[i].index = units[i];
++    }
++    
++    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
++}
+ //////////////////////////////////////////////////////////////////////
+ // ComputationWrapper::SanityCheckGradient()
+ //
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Config.hpp b/./Config.hpp
+index ea7a70a..775bccf 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Config.hpp
++++ b/./Config.hpp
+@@ -179,6 +179,9 @@ const double MM_SMOOTHING = 1.0;
+ #define PARAMS_EXTERNAL_LENGTH                     1
+ #define PARAMS_EVIDENCE                            1  
+ 
++// Compile for using REVI or not
++#define USE_REVI									1
++
+ /*
+ #define PARAMS_BASE_PAIR                           1
+ #define PARAMS_BASE_PAIR_DIST                      0
+@@ -210,7 +213,7 @@ const double MM_SMOOTHING = 1.0;
+ // (F) Miscellaneous model constants
+ //////////////////////////////////////////////////////////////////////
+ 
+-const int C_MIN_HAIRPIN_LENGTH = 0;
++const int C_MIN_HAIRPIN_LENGTH = 3;
+ const int C_MAX_SINGLE_LENGTH = 30;
+ 
+ const int D_MAX_HAIRPIN_LENGTH = 30;
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.cpp b/./Contrafold.cpp
+index 992cf78..b574b23 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.cpp
++++ b/./Contrafold.cpp
+@@ -17,6 +17,8 @@
+ 
+ // constants
+ const double GAMMA_DEFAULT = 6;
++const double KAPPA_DEFAULT = 1.0;
++const double SIGMA_DEFAULT = 1.0;
+ const double REGULARIZATION_DEFAULT = 0;
+ const int TRAIN_MAX_ITER_DEFAULT = 1000;
+ const double HYPERPARAM_DATA_DEFAULT = 1;
+@@ -30,12 +32,21 @@ void MakeFileDescriptions(const Options &options, const std::vector<std::string>
+ template<class RealT>
+ void RunGradientSanityCheck(const Options &options, const std::vector<FileDescription> &descriptions);
+ 
++template<class RealT>
++void RunEnergyTest(const Options &options, const std::vector<FileDescription> &descriptions);
++
+ template<class RealT>
+ void RunTrainingMode(const Options &options, const std::vector<FileDescription> &descriptions);
+ 
+ template<class RealT>
+ void RunPredictionMode(const Options &options, const std::vector<FileDescription> &descriptions);
+ 
++template<class RealT>
++void RunSampleMode(const Options &options, const std::vector<FileDescription> &descriptions);
++
++template<class RealT>
++void RunREVIMode(const Options &options, const std::vector<FileDescription> &descriptions);
++
+ // default parameters
+ #include "Defaults.ipp"
+ 
+@@ -70,10 +81,20 @@ int main(int argc, char **argv)
+     {
+         RunGradientSanityCheck<double>(options, descriptions);
+     }
++    else if (options.GetBoolValue("test_energies"))
++    {
++        RunEnergyTest<double>(options, descriptions);
++    }
+     else if (options.GetStringValue("training_mode") != "")
+     {
+         RunTrainingMode<double>(options, descriptions);
+     }
++    else if (options.GetBoolValue("run_sample_mode")){
++        RunSampleMode<double>(options, descriptions);
++    }
++    else if (options.GetBoolValue("run_revi_mode")){
++        RunREVIMode<double>(options, descriptions);
++    }
+     else
+     {
+         RunPredictionMode<float>(options, descriptions);
+@@ -93,7 +114,7 @@ int main(int argc, char **argv)
+ void Usage(const Options &options)
+ {
+     std::cerr << std::endl
+-              << "Usage: contrafold [predict|train|em-train] [OPTION]... INFILE(s)" << std::endl 
++              << "Usage: contrafold [predict|sample|train|em-train] [OPTION]... INFILE(s)" << std::endl 
+               << std::endl
+               << "       where [OPTION]...   is a list of zero or more optional arguments" << std::endl
+               << "             INFILE(s)     is the name of the input BPSEQ, plain text, or FASTA file(s)" << std::endl 
+@@ -122,9 +143,17 @@ void Usage(const Options &options)
+               << "                           write posterior pairing probabilities to file or directory" << std::endl
+               << "  --partition              compute the partition function or Viterbi score only" << std::endl
+               << std::endl
++              << "Additional arguments for 'sample' mode:" <<std::endl
++              << "  --nsamples N             number of samples (default 100)" << std::endl
++              << "  --kappa k                weight to place on chemical mapping data (default 1.0)" << std::endl
++              << std::endl
++              << "Additional arguments for 'revi' mode:" <<std::endl
++              << "  --sigma S                weight to place on data vs. energy model" << std::endl
++              << std::endl
+               << "Additional arguments for training (many input files may be specified):" << std::endl
+               << "  --examplefile            read list of input files from provided text file (instead of as arguments)" << std::endl
+               << "  --sanity                 perform gradient sanity check" << std::endl
++              << "  --test_energies          print energies.  Requires sequence and constraint string" << std::endl
+               << "  --holdout F              use fraction F of training data for holdout cross-validation" << std::endl
+               << "  --regularize C           perform BFGS training, using a single regularization coefficient C" << std::endl
+               << "  --maxiter N              for single regularization coefficient the max number of iterations" << std::endl
+@@ -168,6 +197,8 @@ void ParseArguments(int argc,
+ {
+     // register default options
+     options.SetStringValue("training_mode", "");
++    options.SetBoolValue("run_sample_mode",false);
++    options.SetBoolValue("run_revi_mode",false);
+ 
+     options.SetBoolValue("verbose_output", false);
+     options.SetRealValue("log_base", 1.0);
+@@ -179,6 +210,8 @@ void ParseArguments(int argc,
+     options.SetBoolValue("centroid_estimator", false);
+     options.SetBoolValue("use_evidence", false);
+     options.SetRealValue("gamma", GAMMA_DEFAULT);
++    options.SetRealValue("kappa", KAPPA_DEFAULT);
++    options.SetRealValue("sigma", KAPPA_DEFAULT);
+     options.SetStringValue("output_parens_destination", "");
+     options.SetStringValue("output_bpseq_destination", "");
+     options.SetRealValue("output_posteriors_cutoff", 0);
+@@ -186,6 +219,7 @@ void ParseArguments(int argc,
+     options.SetBoolValue("partition_function_only", false);
+ 
+     options.SetBoolValue("gradient_sanity_check", false);
++    options.SetBoolValue("test_energies", false);
+     options.SetRealValue("holdout_ratio", 0);
+     options.SetRealValue("regularization_coefficient", REGULARIZATION_DEFAULT);
+ 
+@@ -198,6 +232,7 @@ void ParseArguments(int argc,
+     options.SetRealValue("s0", 0.0001);
+     options.SetRealValue("s1", 0);
+     options.SetRealValue("hyperparam_data",HYPERPARAM_DATA_DEFAULT);
++    options.SetIntValue("nsamples",100);
+ 
+     // check for sufficient arguments
+     if (argc < 2) Usage(options);
+@@ -216,9 +251,17 @@ void ParseArguments(int argc,
+     {
+         options.SetStringValue("training_mode", "em-sgd");
+     }
++    else if (!strcmp(argv[1], "sample"))
++    {
++        options.SetBoolValue("run_sample_mode",true);
++    }
++    else if (!strcmp(argv[1], "revi"))
++    {
++        options.SetBoolValue("run_revi_mode",true);
++    }
+     else if (strcmp(argv[1], "predict"))
+     {
+-        Error("CONTRAfold must be run in either 'predict' or 'train' mode.");
++        Error("CONTRAfold must be run in either 'predict', 'train', or 'sample' mode.");
+     }
+ 
+     // go through remaining arguments
+@@ -281,6 +324,22 @@ void ParseArguments(int argc,
+                     Error("Unable to parse value after --gamma.");
+                 options.SetRealValue("gamma", value);
+             }
++            else if (!strcmp(argv[argno], "--kappa"))
++            {
++                if (argno == argc - 1) Error("Must specify chemical mapping reweighting parameter KAPPA after --kappa.");
++                double value;
++                if (!ConvertToNumber(argv[++argno], value))
++                    Error("Unable to parse value after --kappa.");
++                options.SetRealValue("kappa", value);
++            }
++            else if (!strcmp(argv[argno], "--sigma"))
++            {
++                if (argno == argc - 1) Error("Must specify data reweighting parameter SIGMA after --sigma.");
++                double value;
++                if (!ConvertToNumber(argv[++argno], value))
++                    Error("Unable to parse value after --sigma.");
++                options.SetRealValue("sigma", value);
++            }
+             else if (!strcmp(argv[argno], "--parens"))
+             {
+                 if (argno == argc - 1) Error("Must specify output file or directory name after --parens.");
+@@ -316,6 +375,10 @@ void ParseArguments(int argc,
+             {
+                 options.SetBoolValue("gradient_sanity_check", true);
+             }
++            else if (!strcmp(argv[argno], "--test_energies"))
++            {
++                options.SetBoolValue("test_energies", true);
++            }
+             else if (!strcmp(argv[argno], "--holdout"))
+             {
+                 if (argno == argc - 1) Error("Must specify holdout ratio F after --holdout.");
+@@ -346,6 +409,16 @@ void ParseArguments(int argc,
+                     Error("Max number of iterations should not be negative.");
+                 options.SetIntValue("train_max_iter", value);
+             }
++            else if (!strcmp(argv[argno], "--nsamples"))
++            {
++                if (argno == argc - 1) Error("Must specify number of samples after --nsamples.");
++                int value;
++                if (!ConvertToNumber(argv[++argno], value))
++                    Error("Unable to parse max number of iterations after --nsamples.");
++                if (value < 0)
++                    Error("Number of samples should not be negative.");
++                options.SetIntValue("nsamples", value);
++            }
+             else if (!strcmp(argv[argno], "--hyperparam_data"))
+             {
+                 if (argno == argc - 1) Error("Must specify a value after --hyperparam_data.");
+@@ -537,6 +610,83 @@ void MakeFileDescriptions(const Options &options,
+     std::sort(descriptions.begin(), descriptions.end());
+ 
+ }
++/////////////////////////////////////////////////////////////////
++// RunEnergyTest()
++//
++// Print energies for test sequence.
++/////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void RunEnergyTest(const Options &options,
++                            const std::vector<FileDescription> &descriptions)
++{
++    // The architecture of the code is somewhat complicated here, so
++    // here's a quick explanation:
++    // 
++    //    ParameterManager: associates each parameter of the model
++    //                      with a name and manages hyperparameter
++    //                      groups
++    //                     
++    //    InferenceEngine: performs application-specific
++    //                     (loss-augmented) inference
++    //
++    //    ComputationEngine: makes all necessary calls to dynamic
++    //                       programming routines for processing
++    //                       individual sequences and interfaces with
++    //                       distributed computation module
++    //
++    //    ComputationWrapper: provides a high-level interface for
++    //                        performing computations on groups of
++    //                        sequences
++    //
++    //    OuterOptimizationWrapper / InnerOptimizationWrapper:
++    //                        interface between computation routines
++    //                        and optimization routines
++    
++   ParameterManager<RealT> parameter_manager;
++    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),
++        options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
++    inference_engine.RegisterParameters(parameter_manager);
++    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
++    ComputationWrapper<RealT> computation_wrapper(computation_engine);
++    
++    // decide whether I'm a compute node or master node
++    if (computation_engine.IsComputeNode())
++    {
++        computation_engine.RunAsComputeNode();
++        return;
++    }
++
++    const std::string output_parens_destination = options.GetStringValue("output_parens_destination");
++    const std::string output_bpseq_destination = options.GetStringValue("output_bpseq_destination");
++    const std::string output_posteriors_destination = options.GetStringValue("output_posteriors_destination");
++
++    // load parameters
++    std::vector<RealT> w;
++
++    if (options.GetStringValue("parameter_filename") != "")
++    {
++        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
++    }
++    else
++    {
++#if PROFILE
++        w = GetDefaultProfileValues<RealT>();
++#else
++        if (options.GetBoolValue("allow_noncomplementary"))
++            w = GetDefaultNoncomplementaryValues<RealT>();
++        else
++            w = GetDefaultComplementaryValues<RealT>();
++#endif
++    }
++
++    
++        // create output directories for output files, if needed
++
++    computation_wrapper.TestEnergies(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"));
++    
++    computation_engine.StopComputeNodes();
++}
+ 
+ /////////////////////////////////////////////////////////////////
+ // RunGradientSanityCheck()
+@@ -572,7 +722,8 @@ void RunGradientSanityCheck(const Options &options,
+     //                        and optimization routines
+     
+     ParameterManager<RealT> parameter_manager;
+-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
++    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),
++        options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+     inference_engine.RegisterParameters(parameter_manager);
+     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+     ComputationWrapper<RealT> computation_wrapper(computation_engine);
+@@ -614,7 +765,7 @@ void RunTrainingMode(const Options &options,
+                      const std::vector<FileDescription> &descriptions)
+ {
+     ParameterManager<RealT> parameter_manager;
+-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
++    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+     inference_engine.RegisterParameters(parameter_manager);
+     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+     ComputationWrapper<RealT> computation_wrapper(computation_engine);
+@@ -708,7 +859,7 @@ void RunPredictionMode(const Options &options,
+                        const std::vector<FileDescription> &descriptions)
+ {
+     ParameterManager<RealT> parameter_manager;
+-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
++    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+     inference_engine.RegisterParameters(parameter_manager);
+     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+     ComputationWrapper<RealT> computation_wrapper(computation_engine);
+@@ -793,3 +944,102 @@ void RunPredictionMode(const Options &options,
+     }
+     computation_engine.StopComputeNodes();
+ }
++
++/////////////////////////////////////////////////////////////////
++// RunSampleMode()
++//
++// Run CONTRAfold in sample mode.
++/////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void RunSampleMode(const Options &options,
++                       const std::vector<FileDescription> &descriptions)
++{
++    ParameterManager<RealT> parameter_manager;
++    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
++    inference_engine.RegisterParameters(parameter_manager);
++    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
++    ComputationWrapper<RealT> computation_wrapper(computation_engine);
++    
++    // decide whether I'm a compute node or master node
++    if (computation_engine.IsComputeNode())
++    {
++        computation_engine.RunAsComputeNode();
++        return;
++    }
++
++    // const std::string output_parens_destination = options.GetStringValue("output_parens_destination");
++    // const std::string output_bpseq_destination = options.GetStringValue("output_bpseq_destination");
++    // const std::string output_posteriors_destination = options.GetStringValue("output_posteriors_destination");
++
++    // load parameters
++    std::vector<RealT> w;
++
++    if (options.GetStringValue("parameter_filename") != "")
++    {
++        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
++    }
++    else
++    {
++#if PROFILE
++        w = GetDefaultProfileValues<RealT>();
++#else
++        if (options.GetBoolValue("allow_noncomplementary"))
++            w = GetDefaultNoncomplementaryValues<RealT>();
++        else
++            w = GetDefaultComplementaryValues<RealT>();
++#endif
++    }
++
++        
++    computation_wrapper.Sample(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"));
++    
++    computation_engine.StopComputeNodes();
++}
++
++/////////////////////////////////////////////////////////////////
++// RunREVIMode()
++//
++// Run REVI.
++/////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void RunREVIMode(const Options &options,
++                       const std::vector<FileDescription> &descriptions)
++{
++    ParameterManager<RealT> parameter_manager;
++    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
++    inference_engine.RegisterParameters(parameter_manager);
++    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
++    ComputationWrapper<RealT> computation_wrapper(computation_engine);
++    
++    // decide whether I'm a compute node or master node
++    if (computation_engine.IsComputeNode())
++    {
++        computation_engine.RunAsComputeNode();
++        return;
++    }
++
++    // load parameters
++    std::vector<RealT> w;
++
++    if (options.GetStringValue("parameter_filename") != "")
++    {
++        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
++    }
++    else
++    {
++#if PROFILE
++        w = GetDefaultProfileValues<RealT>();
++#else
++        if (options.GetBoolValue("allow_noncomplementary"))
++            w = GetDefaultNoncomplementaryValues<RealT>();
++        else
++            w = GetDefaultComplementaryValues<RealT>();
++#endif
++    }
++
++    computation_wrapper.RunREVI(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"), options.GetRealValue("sigma"));
++    
++    computation_engine.StopComputeNodes();
++}
+\ No newline at end of file
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.o b/./Contrafold.o
+index 00a11ca..3f458d0 100644
+Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.o and b/./Contrafold.o differ
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.hpp b/./InferenceEngine.hpp
+index 4818ec2..1f0295d 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.hpp
++++ b/./InferenceEngine.hpp
+@@ -13,6 +13,7 @@
+ #include "ParameterManager.hpp"
+ #include "Utilities.hpp"
+ #include "LogSpace.hpp"
++#include "rand.h"
+ 
+ //////////////////////////////////////////////////////////////////////
+ // class InferenceEngine
+@@ -23,12 +24,14 @@ class InferenceEngine
+ {
+     static const double DATA_LOW_THRESH = 1e-7;  // used for the data so that log is not -Inf
+ 
++    const double kappa;
+     const bool allow_noncomplementary;
+     unsigned char char_mapping[256];
+     int is_complementary[M+1][M+1];
+     bool cache_initialized;
+     ParameterManager<RealT> *parameter_manager;
+-    
++    Die* die;
++
+     int num_data_sources;
+     // dimensions
+     int L, SIZE;
+@@ -307,7 +310,7 @@ class InferenceEngine
+ public:
+ 
+     // constructor and destructor
+-    InferenceEngine(bool allow_noncomplementary, const int num_data_sources);
++    InferenceEngine(bool allow_noncomplementary, const int num_data_sources, const double kappa);
+     ~InferenceEngine();
+ 
+     // register params with the parameter manager
+@@ -331,6 +334,9 @@ public:
+     std::vector<int> PredictPairingsViterbi() const;
+     std::vector<RealT> ComputeViterbiFeatureCounts();
+ 
++    void GetViterbiFeatures();
++    void GetViterbiFeaturesESS();
++
+     // MEA inference
+     void ComputeInside();
+     RealT ComputeLogPartitionCoefficient() const;
+@@ -340,6 +346,11 @@ public:
+     std::vector<int> PredictPairingsPosterior(const RealT gamma) const;
+     std::vector<int> PredictPairingsPosteriorCentroid(const RealT gamma) const;
+     RealT *GetPosterior(const RealT posterior_cutoff) const;
++
++    // stoch traceback
++    void InitRand(unsigned int seed);
++    std::vector<int> PredictPairingsStochasticTraceback() const;
++    std::vector<int> PredictPairingsStochasticTracebackESS() const;
+     
+     // EM inference
+     void ComputeInsideESS();
+@@ -349,6 +360,13 @@ public:
+     RealT ComputeLogPartitionCoefficientESS() const;
+     std::vector<RealT> ComputeESS();    
+ 
++    //REVI
++    void UpdateREVIVec(std::vector<RealT> perturb_unpaired, std::vector<RealT> perturb_paired);
++    void InitializeREVIVec();
++    std::vector<RealT> GetREVIError(std::vector<RealT> p_i);
++    std::vector<std::vector<double> > GetREVIvec_up();
++    std::vector<std::vector<double> > GetREVIvec_pr();
++
+     // Learning Evidence CPD
+     RealT ComputeGammaMLESum(std::vector<int> ev_cpd_id, bool ignorePairing, bool usePosterior, int which_data);
+     std::vector<RealT> ComputeGammaMLESS(std::vector<int> ev_cpd_id, bool ignoreZeros, bool useMLE, int which_data);
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.ipp b/./InferenceEngine.ipp
+index def37bb..a32fb22 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.ipp
++++ b/./InferenceEngine.ipp
+@@ -42,7 +42,7 @@ RealT InferenceEngine<RealT>::ScoreUnpairedPositionEvidence(int i) const
+ {
+    RealT sum = 0;
+    for (int n = 0; n < num_data_sources; n++)
+-       sum = sum + score_unpaired_position[n][i-1];
++       sum = sum + kappa*score_unpaired_position[n][i-1]; // FLAG: put scalar here
+    return sum;
+ }
+ #else
+@@ -59,7 +59,7 @@ RealT InferenceEngine<RealT>::ScorePairedPositionEvidence(int i) const
+ {
+    RealT sum = 0;
+    for (int n = 0; n < num_data_sources; n++)
+-       sum = sum + score_paired_position[n][i-1];
++       sum = sum + kappa*score_paired_position[n][i-1]; // FLAG: put scalar here
+    return sum;
+ }
+ #else
+@@ -307,11 +307,12 @@ bool InferenceEngine<RealT>::IsComplementary(int i, int j) const
+ //////////////////////////////////////////////////////////////////////
+ 
+ template<class RealT>
+-InferenceEngine<RealT>::InferenceEngine(bool allow_noncomplementary, const int num_data_sources) :
++InferenceEngine<RealT>::InferenceEngine(bool allow_noncomplementary, const int num_data_sources, const double kappa) :
+     allow_noncomplementary(allow_noncomplementary),
+     cache_initialized(false),
+     parameter_manager(NULL),
+     num_data_sources(num_data_sources),
++    kappa(kappa),
+     L(0),
+     SIZE(0)
+ #if PROFILE
+@@ -946,6 +947,79 @@ double InferenceEngine<RealT>::LogGammaProb(RealT data, int which_data, int isUn
+     return (k-1)*log(data) - data/theta - lgamma(k) - k*log(theta);
+ }
+ 
++template<class RealT>
++void InferenceEngine<RealT>::UpdateREVIVec(std::vector<RealT> perturb_unpaired, std::vector<RealT> perturb_paired)
++{
++    int which_data = 0; // update if we ever want to do more than one
++
++    for (int i = 0; i < L; i++)
++    {
++        score_unpaired_position[which_data][i] += perturb_unpaired[i];
++        //score_paired_position[which_data][i] += perturb_paired[i];
++    }
++
++    std::cerr << "u_v " << score_unpaired_position[0] << std::endl;
++    std::cerr << "p_v " << score_paired_position[0] << std::endl;
++
++}
++
++template<class RealT>
++std::vector<std::vector<double> > InferenceEngine<RealT>::GetREVIvec_up()
++{
++    return score_unpaired_position;
++}
++
++template<class RealT>
++std::vector<std::vector<double> > InferenceEngine<RealT>::GetREVIvec_pr()
++{
++    return score_paired_position;
++}
++
++template<class RealT>
++std::vector<RealT> InferenceEngine<RealT>::GetREVIError(std::vector<RealT> p_i)
++{
++    int which_data = 0;
++    std::vector<RealT> error;
++
++     for (int i = 0; i < L; i++)
++     {
++
++        // analytical posterior
++    //     RealT pos_paired = 0;
++    //     // get paired posterior
++    //     for (int l = 1; l <= L; l++)
++    //     {
++    //             int offset1 = i <= l ? i : l;
++    //             int offset2 = i > l ? i : l;
++    //             if (i != l)
++    //                 pos_paired += posterior[offset[offset1]+offset2];
++    //     }
++    //     // if (i==1){
++    //     //     std::cerr << "pos_paired " << pos_paired << std::endl;
++    //     // }
++
++    // HWS: reintroduce when using reactivities instead of probabilities
++
++    // RealT k_pr = exp(log_score_evidence[which_data][0][s[i+1]][0].first);
++    // RealT theta_pr = exp(log_score_evidence[which_data][1][s[i+1]][0].first);
++    // RealT k_unp = exp(log_score_evidence[which_data][0][s[i+1]][1].first);
++    // RealT theta_unp = exp(log_score_evidence[which_data][1][s[i+1]][1].first);
++
++        // predict reactivity under this model
++        //RealT rhat = k_pr*theta_pr*(1-p_i[i]) + k_unp*theta_unp*p_i[i];
++        //score_unpaired_position_raw: where raw reacitivty data is stored
++
++        // fitting to raw diff in p(unp values)
++        RealT err = (p_i[i] - score_unpaired_position_raw[which_data][i]);
++
++        error.push_back(err);
++}
++    std::cerr << "sc_up_p_raw " << score_unpaired_position_raw[which_data] << std::endl;
++    return error;
++    
++}
++
++  
+ 
+ //////////////////////////////////////////////////////////////////////
+ // InferenceEngine::LoadSequence()
+@@ -966,7 +1040,6 @@ void InferenceEngine<RealT>::LoadSequence(const SStruct &sstruct)
+     SIZE2 = (L+1)*(L+1);
+ #endif
+ 
+-    
+     // allocate memory
+     s.resize(L+1);
+ #if PROFILE
+@@ -1120,8 +1193,23 @@ void InferenceEngine<RealT>::LoadSequence(const SStruct &sstruct)
+     score_paired_position = 1-sstruct.GetPairedPotentials();  // probability of paired = 1 - probability of unpaired (NOTE: currently PairedPotentials returns the probability of unpaired, so need the "1-" in front
+ #endif
+ 
++
+ }
+ 
++template<class RealT>
++void InferenceEngine<RealT>::InitializeREVIVec()
++{    
++    score_unpaired_position[0].clear();
++    score_paired_position[0].clear();
++    for (int i = 0; i < num_data_sources; i++)
++    {
++        for (int j = 0; j < L; j++)
++    {
++    score_unpaired_position[i].push_back(RealT(0));
++    score_paired_position[i].push_back(RealT(0));
++    }
++}
++}
+ 
+ template<class RealT>
+ void InferenceEngine<RealT>::UpdateEvidenceStructures()
+@@ -1148,6 +1236,7 @@ void InferenceEngine<RealT>::UpdateEvidenceStructures(int which_data)
+     }
+ }
+ 
++
+ //////////////////////////////////////////////////////////////////////
+ // InferenceEngine::InitializeCache()
+ //
+@@ -3929,9 +4018,8 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+ {
+     std::queue<triple<int *,int,int> > traceback_queue;
+     traceback_queue.push(make_triple(&F5t[0], 0, L));
+-
+     ClearCounts();
+-    
++
+     while (!traceback_queue.empty())
+     {
+         triple<int *,int,int> t = traceback_queue.front();
+@@ -3947,6 +4035,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+         
+         switch (traceback.first)
+         {
++
+ #if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+             case TB_FN_HAIRPIN: 
+                 CountHairpin(i,j,RealT(1));
+@@ -3956,6 +4045,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+                 const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                 const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                 CountSingle(i,j,p,q,RealT(1));
++
+                 traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+             }
+             break;
+@@ -3965,6 +4055,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+                 CountJunctionA(i,j,RealT(1));
+                 CountMultiPaired(RealT(1));
+                 CountMultiBase(RealT(1));
++
+                 traceback_queue.push(make_triple(&FM1t[0], i, k));
+                 traceback_queue.push(make_triple(&FMt[0], k, j));
+             }
+@@ -3973,6 +4064,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+             {
+                 CountBasePair(i+1,j,RealT(1));
+                 CountHelixStacking(i,j+1,RealT(1));
++
+                 traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
+             }
+             break;
+@@ -4001,9 +4093,11 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+                 traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
+             }
+             break;
++
+ #else
+             case TB_FC_HAIRPIN: 
+                 CountHairpin(i,j,RealT(1));
++
+                 break;
+             case TB_FC_SINGLE: 
+             {
+@@ -4018,6 +4112,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+                 else
+                 {
+                     CountSingle(i,j,p,q,RealT(1));
++
+                 }
+                 
+                 traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+@@ -4029,6 +4124,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+                 CountJunctionA(i,j,RealT(1));
+                 CountMultiPaired(RealT(1));
+                 CountMultiBase(RealT(1));
++
+                 traceback_queue.push(make_triple(&FM1t[0], i, k));
+                 traceback_queue.push(make_triple(&FMt[0], k, j));
+             }
+@@ -4039,12 +4135,14 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+                 CountJunctionA(j,i,RealT(1));
+                 CountMultiPaired(RealT(1));
+                 CountBasePair(i+1,j,RealT(1));
++
+                 traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
+             }
+             break;
+             case TB_FM1_UNPAIRED:
+             {
+                 CountMultiUnpaired(i+1,RealT(1));
++
+                 traceback_queue.push(make_triple(&FM1t[0], i+1, j));
+             }
+             break;
+@@ -4058,6 +4156,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+             case TB_FM_UNPAIRED:
+             {
+                 CountMultiUnpaired(j,RealT(1));
++
+                 traceback_queue.push(make_triple(&FMt[0], i, j-1));
+             }
+             break;
+@@ -4068,25 +4167,706 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
+                 break;
+             case TB_F5_UNPAIRED:
+                 CountExternalUnpaired(j,RealT(1));
++
++                traceback_queue.push(make_triple(&F5t[0], 0, j-1));
++                break;
++            case TB_F5_BIFURCATION:
++            {
++                const int k = traceback.second;
++                CountExternalPaired(RealT(1));
++                CountBasePair(k+1,j,RealT(1));
++                CountJunctionA(j,k,RealT(1));
++                traceback_queue.push(make_triple(&F5t[0], 0, k));
++                traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
++
++
++            }
++            break;
++            default:
++                Assert(false, "Bad traceback.");
++        }
++    }
++
++    FinalizeCounts();
++    return GetCounts();
++}
++
++//////////////////////////////////////////////////////////////////////
++// InferenceEngine::GetViterbiFeatures()
++// 
++// Use feature counts from Viterbi decoding.
++//////////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void InferenceEngine<RealT>::GetViterbiFeatures()
++{
++    std::queue<triple<int *,int,int> > traceback_queue;
++    traceback_queue.push(make_triple(&F5t[0], 0, L));
++
++    std::vector<triple<int, int, int> > multiloops;
++    ClearCounts();
++
++    std::map<int, RealT> eos_cb_map;
++    for (int k = -1; k <= L; k++){
++        eos_cb_map[k] = 0;
++    }
++
++    while (!traceback_queue.empty())
++    {
++        triple<int *,int,int> t = traceback_queue.front();
++        traceback_queue.pop();
++        const int *V = t.first;
++        const int i = t.second;
++        const int j = t.third;
++        
++        std::pair<int,int> traceback = DecodeTraceback (V == &F5t[0] ? V[j] : V[offset[i]+j]);
++        
++        //std::cout << (V == FCt ? "FC " : V == FMt ? "FM " : V == FM1t ? "FM1 " : "F5 ");
++        //std::cout << i << " " << j << ": " << traceback.first << " " << traceback.second << std::endl;
++        
++        switch (traceback.first)
++        {
++
++    // HWS: we're not using these params
++#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
++            case TB_FN_HAIRPIN: 
++                CountHairpin(i,j,RealT(1));
++                break;
++            case TB_FN_SINGLE: 
++            {
++                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
++                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
++                CountSingle(i,j,p,q,RealT(1));
++
++                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
++            }
++            break;
++            case TB_FN_BIFURCATION:
++            {
++                const int k = traceback.second;
++                CountJunctionA(i,j,RealT(1));
++                CountMultiPaired(RealT(1));
++                CountMultiBase(RealT(1));
++
++                traceback_queue.push(make_triple(&FM1t[0], i, k));
++                traceback_queue.push(make_triple(&FMt[0], k, j));
++            }
++            break;
++            case TB_FE_STACKING: 
++            {
++                CountBasePair(i+1,j,RealT(1));
++                CountHelixStacking(i,j+1,RealT(1));
++
++                traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
++            }
++            break;
++            case TB_FE_FN: 
++            {
++                traceback_queue.push(make_triple(&FNt[0], i, j));
++            }
++            break;
++            case TB_FC_FN:
++            {
++                CountIsolated(RealT(1));
++                traceback_queue.push(make_triple(&FNt[0], i, j));
++            }
++            break;
++            case TB_FC_HELIX:
++            {
++                const int m = traceback.second;
++                CountHelix(i-1,j+1,m,RealT(1));
++                traceback_queue.push(make_triple(&FNt[0], i+m-1, j-m+1));
++            }
++            break;
++            case TB_FC_FE:
++            {
++                const int m = D_MAX_HELIX_LENGTH;
++                CountHelix(i-1,j+1,m,RealT(1));
++                traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
++            }
++            break;
++
++    //HWS: our param sections start here
++#else
++            case TB_FC_HAIRPIN: 
++                //CountHairpin(i,j,RealT(1));
++                //////////////////////////////////////////////////////////////////////
++                // InferenceEngine::ScoreHairpin()
++                // InferenceEngine::CountHairpin()
++                //
++                // Returns the score for a hairpin spanning positions i to j.
++                //
++                // In an RNA structure, this would look like
++                //
++                //                           ...
++                //                       /         \. 
++                //                   x[i+2]       x[j-1]
++                //                      |            |
++                //                   x[i+1]        x[j]
++                // position i -------->  o          o  <----- position j
++                //                      x[i] -- x[j+1]
++                //                        |        |
++                //                     x[i-1] -- x[j+2]
++                //
++                //////////////////////////////////////////////////////////////////////
++
++                //HWS: subtracting off 1 to get zero-indexing for eos_cb
++
++                //std::cerr << "Hairpin " << i-1 << " " << ScoreHairpin(i,j) << std::endl;
++                eos_cb_map[i-1] += ScoreHairpin(i,j);
++
++                break;
++            case TB_FC_SINGLE: 
++            {
++                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
++                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
++
++                if (p == i && q == j)
++                {
++                    // CountBasePair(i+1,j,RealT(1));
++                    // CountHelixStacking(i,j+1,RealT(1));
++
++                //HWS: subtracting off 1 (from i+1) to get zero-indexing for eos_cb
++
++
++                //std::cerr << "BasePair " << i << " " << ScoreBasePair(i+1,j) << std::endl;
++                eos_cb_map[i] += ScoreBasePair(i+1,j);
++
++
++                // ScoreHelixStacking(i,j): score for a helix stacking pair of the form:
++                //
++                //       |         |
++                //    s[i+1] == s[j-1]
++                //       |         |
++                //     s[i] ==== s[j]
++                //       |         |
++                //HWS: subtracting off 1 (from i) to get zero-indexing for eos_cb
++
++                //std::cerr << "HelixStacking " << i-1 << " " << ScoreHelixStacking(i,j+1) << std::endl;
++                eos_cb_map[i-1] += ScoreHelixStacking(i,j+1);
++
++                }
++                else
++                {
++                    //CountSingle(i,j,p,q,RealT(1));
++                    //here we need to break this down because they sum a bunch of things to make ScoreSingle
++                    // here we need to subtract off the second base pair from ScoreSingle
++                // std::cerr << "Single " << i-1 << " " << ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q) << std::endl;
++                // std::cerr << "ScoreBasePair " << p << " " << ScoreBasePair(p+1,q) << std::endl;
++
++                eos_cb_map[i-1] += ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q);
++                eos_cb_map[p] += ScoreBasePair(p+1, q);
++
++                }
++                
++                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
++            }
++            break;
++            case TB_FC_BIFURCATION:
++            {
++                const int k = traceback.second;
++                // CountJunctionA(i,j,RealT(1));
++                // CountMultiPaired(RealT(1));
++                // CountMultiBase(RealT(1));
++
++                // This is where we first recognize we're in a new multiloop. Store the things at i
++                multiloops.push_back(make_triple(i,j,0));
++                // std::cerr << "New multiloop! " << i << ":" << j << std::endl;
++
++                // std::cerr << "FCBifurc:JunctionA " << i << " " << ScoreJunctionA(i,j) << std::endl;
++                // std::cerr << "FCBifurc:MultiPaired " << i << " " << ScoreMultiPaired() << std::endl;
++                // std::cerr << "FCBifurc:MultiBase " << i << " " << ScoreMultiBase() << std::endl;
++
++                eos_cb_map[i] += ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
++
++                traceback_queue.push(make_triple(&FM1t[0], i, k));
++                traceback_queue.push(make_triple(&FMt[0], k, j));
++            }
++            break;
++#endif
++            case TB_FM1_PAIRED:
++            {
++                // CountJunctionA(j,i,RealT(1));
++                // CountMultiPaired(RealT(1));
++                // CountBasePair(i+1,j,RealT(1));
++
++                // HWS: We're in a multiloop -- this gets the index of the 5' base 
++                // of the current multiloop and puts in curr_multiloop ind.
++
++                int min_dist = 100000;
++                int curr_multiloop_ind = -1;
++
++                for(int ind=0; ind < multiloops.size(); ind++){
++                    if (multiloops[ind].first < i < multiloops[ind].second){
++                        if (i - multiloops[ind].first < min_dist){
++                            min_dist = i - multiloops[ind].first;
++                            curr_multiloop_ind = multiloops[ind].first;
++                        }
++                    }
++                }
++
++                // These all go in the multiloop ind
++                //std::cerr << "Paired:JunctionA " << curr_multiloop_ind << " " << ScoreJunctionA(j,i) << std::endl;
++                //std::cerr << "Paired:MultiPaired " << curr_multiloop_ind << " " << ScoreMultiPaired() << std::endl;
++                
++                eos_cb_map[curr_multiloop_ind] += ScoreJunctionA(j,i) + ScoreMultiPaired();
++
++                //This just goes with the next base pair
++                //std::cerr << "Paired:BasePair " << i << " " << ScoreBasePair(i+1, j) << std::endl;
++                eos_cb_map[i] += ScoreBasePair(i+1, j);
++
++                traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
++            }
++            break;
++            case TB_FM1_UNPAIRED:
++            {
++                // CountMultiUnpaired(i+1,RealT(1));
++
++                // HWS: We're in a multiloop -- this gets the index of the 5' base 
++                // of the current multiloop and puts in curr_multiloop ind.
++
++                int min_dist = 100000;
++                int curr_multiloop_ind = -1;
++
++                for(int ind=0; ind < multiloops.size(); ind++){
++                    if (multiloops[ind].first < i+1 < multiloops[ind].second){
++                        if (i+1 - multiloops[ind].first < min_dist){
++                            min_dist = i+1 - multiloops[ind].first;
++                            curr_multiloop_ind = multiloops[ind].first;
++                        }
++                    }
++                }
++                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
++                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(i+1) << std::endl;
++                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpaired(i+1);
++
++                traceback_queue.push(make_triple(&FM1t[0], i+1, j));
++            }
++            break;
++            case TB_FM_BIFURCATION:
++            {
++                const int k = traceback.second;
++                traceback_queue.push(make_triple(&FM1t[0], i, k));
++                traceback_queue.push(make_triple(&FMt[0], k, j));
++            }
++            break;
++            case TB_FM_UNPAIRED:
++            {
++                // CountMultiUnpaired(j,RealT(1));
++
++                // HWS: We're in a multiloop -- this gets the index of the 5' base 
++                // of the current multiloop and puts in curr_multiloop ind.
++
++                int min_dist = 100000;
++                int curr_multiloop_ind = -1;
++
++                for(int ind=0; ind < multiloops.size(); ind++){
++                    if (multiloops[ind].first < j < multiloops[ind].second){
++                        if (j - multiloops[ind].first < min_dist){
++                            min_dist = j - multiloops[ind].first;
++                            curr_multiloop_ind = multiloops[ind].first;
++                        }
++                    }
++                }
++                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
++
++                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(j) << std::endl;
++                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpaired(j);
++
++                traceback_queue.push(make_triple(&FMt[0], i, j-1));
++            }
++            break;
++            case TB_FM_FM1: 
++                traceback_queue.push(make_triple(&FM1t[0], i, j));
++                break;
++            case TB_F5_ZERO:
++                break;
++            case TB_F5_UNPAIRED:
++                CountExternalUnpaired(j,RealT(1));
++
++                // HWS: a score for unpaired things in the external loop, dump into the -1 eos_cb
++
++                //std::cerr << "ExternalUnpaired -1 " << ScoreExternalUnpaired(j) << std::endl;
++                eos_cb_map[-1] += ScoreExternalUnpaired(j);
++
++                traceback_queue.push(make_triple(&F5t[0], 0, j-1));
++                break;
++            case TB_F5_BIFURCATION:
++            {
++                const int k = traceback.second;
++                // CountExternalPaired(RealT(1));
++                // CountBasePair(k+1,j,RealT(1));
++                // CountJunctionA(j,k,RealT(1));
++                traceback_queue.push(make_triple(&F5t[0], 0, k));
++                traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
++
++                //HWS: this is base pairs facing external loop. Hard-coding to print -1 as thinking these 
++                //should get summed in to the -1 "external loop " eos_cb category
++                
++                //std::cerr << "F5Bifurc:ExternalPaired -1 " << ScoreExternalPaired() << std::endl;
++                //std::cerr << "F5Bifurc:JunctionA -1 " << ScoreJunctionA(j,k) << std::endl;
++                eos_cb_map[-1] += ScoreExternalPaired()+ScoreJunctionA(j,k);
++
++                // HWS: another base pair, print (k+1) - 1 to zero-index
++                //std::cerr << "F5Bifurc:BasePair " << k << " " << ScoreBasePair(k+1, j) << std::endl;
++                eos_cb_map[k] += ScoreBasePair(k+1, j);
++
++            }
++            break;
++            default:
++                Assert(false, "Bad traceback.");
++        }
++    }
++    RealT local_sum = 0;
++    std::cerr << "EOS_CB: ";
++    for (std::pair<int, RealT> element : eos_cb_map) {
++        if (element.first == -1 || element.second != 0){
++        std::cerr << element.first << ", " << element.second << ", ";
++        local_sum += element.second;
++    }
++    }
++    std::cerr << std::endl;
++    std::cerr << "local sum " << local_sum << std::endl;
++
++}
++
++//////////////////////////////////////////////////////////////////////
++// InferenceEngine::GetViterbiFeaturesESS()
++// 
++// Use feature counts from Viterbi decoding, using evidence-based energies.
++//////////////////////////////////////////////////////////////////////
++
++template<class RealT>
++void InferenceEngine<RealT>::GetViterbiFeaturesESS()
++{
++    std::queue<triple<int *,int,int> > traceback_queue;
++    traceback_queue.push(make_triple(&F5t[0], 0, L));
++
++    std::vector<triple<int, int, int> > multiloops;
++    ClearCounts();
++
++    std::map<int, RealT> eos_cb_map;
++    for (int k = -1; k <= L; k++){
++        eos_cb_map[k] = 0;
++    }
++
++    while (!traceback_queue.empty())
++    {
++        triple<int *,int,int> t = traceback_queue.front();
++        traceback_queue.pop();
++        const int *V = t.first;
++        const int i = t.second;
++        const int j = t.third;
++        
++        std::pair<int,int> traceback = DecodeTraceback (V == &F5t[0] ? V[j] : V[offset[i]+j]);
++        
++        //std::cout << (V == FCt ? "FC " : V == FMt ? "FM " : V == FM1t ? "FM1 " : "F5 ");
++        //std::cout << i << " " << j << ": " << traceback.first << " " << traceback.second << std::endl;
++        
++        switch (traceback.first)
++        {
++
++    // HWS: we're not using these params
++#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
++            case TB_FN_HAIRPIN: 
++                CountHairpin(i,j,RealT(1));
++                break;
++            case TB_FN_SINGLE: 
++            {
++                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
++                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
++                CountSingle(i,j,p,q,RealT(1));
++
++                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
++            }
++            break;
++            case TB_FN_BIFURCATION:
++            {
++                const int k = traceback.second;
++                CountJunctionA(i,j,RealT(1));
++                CountMultiPaired(RealT(1));
++                CountMultiBase(RealT(1));
++
++                traceback_queue.push(make_triple(&FM1t[0], i, k));
++                traceback_queue.push(make_triple(&FMt[0], k, j));
++            }
++            break;
++            case TB_FE_STACKING: 
++            {
++                CountBasePair(i+1,j,RealT(1));
++                CountHelixStacking(i,j+1,RealT(1));
++
++                traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
++            }
++            break;
++            case TB_FE_FN: 
++            {
++                traceback_queue.push(make_triple(&FNt[0], i, j));
++            }
++            break;
++            case TB_FC_FN:
++            {
++                CountIsolated(RealT(1));
++                traceback_queue.push(make_triple(&FNt[0], i, j));
++            }
++            break;
++            case TB_FC_HELIX:
++            {
++                const int m = traceback.second;
++                CountHelix(i-1,j+1,m,RealT(1));
++                traceback_queue.push(make_triple(&FNt[0], i+m-1, j-m+1));
++            }
++            break;
++            case TB_FC_FE:
++            {
++                const int m = D_MAX_HELIX_LENGTH;
++                CountHelix(i-1,j+1,m,RealT(1));
++                traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
++            }
++            break;
++
++    //HWS: our param sections start here
++#else
++            case TB_FC_HAIRPIN: 
++                //CountHairpin(i,j,RealT(1));
++                //////////////////////////////////////////////////////////////////////
++                // InferenceEngine::ScoreHairpin()
++                // InferenceEngine::CountHairpin()
++                //
++                // Returns the score for a hairpin spanning positions i to j.
++                //
++                // In an RNA structure, this would look like
++                //
++                //                           ...
++                //                       /         \. 
++                //                   x[i+2]       x[j-1]
++                //                      |            |
++                //                   x[i+1]        x[j]
++                // position i -------->  o          o  <----- position j
++                //                      x[i] -- x[j+1]
++                //                        |        |
++                //                     x[i-1] -- x[j+2]
++                //
++                //////////////////////////////////////////////////////////////////////
++
++                //HWS: subtracting off 1 to get zero-indexing for eos_cb
++
++                //std::cerr << "Hairpin " << i-1 << " " << ScoreHairpin(i,j) << std::endl;
++                eos_cb_map[i-1] += ScoreHairpinEvidence(i,j);
++
++                break;
++            case TB_FC_SINGLE: 
++            {
++                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
++                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
++
++                if (p == i && q == j)
++                {
++                    // CountBasePair(i+1,j,RealT(1));
++                    // CountHelixStacking(i,j+1,RealT(1));
++
++                //HWS: subtracting off 1 (from i+1) to get zero-indexing for eos_cb
++
++
++                //std::cerr << "BasePair " << i << " " << ScoreBasePair(i+1,j) << std::endl;
++                eos_cb_map[i] += ScoreBasePairEvidence(i+1,j);
++
++
++                // ScoreHelixStacking(i,j): score for a helix stacking pair of the form:
++                //
++                //       |         |
++                //    s[i+1] == s[j-1]
++                //       |         |
++                //     s[i] ==== s[j]
++                //       |         |
++                //HWS: subtracting off 1 (from i) to get zero-indexing for eos_cb
++
++                //std::cerr << "HelixStacking " << i-1 << " " << ScoreHelixStacking(i,j+1) << std::endl;
++                eos_cb_map[i-1] += ScoreHelixStacking(i,j+1);
++
++                }
++                else
++                {
++                    //CountSingle(i,j,p,q,RealT(1));
++                    //here we need to break this down because they sum a bunch of things to make ScoreSingle
++                    // here we need to subtract off the second base pair from ScoreSingle
++                // std::cerr << "Single " << i-1 << " " << ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q) << std::endl;
++                // std::cerr << "ScoreBasePair " << p << " " << ScoreBasePair(p+1,q) << std::endl;
++
++                eos_cb_map[i-1] += ScoreSingleEvidence(i,j,p,q)-ScoreBasePairEvidence(p+1,q);
++                eos_cb_map[p] += ScoreBasePairEvidence(p+1, q);
++
++                }
++                
++                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
++            }
++            break;
++            case TB_FC_BIFURCATION:
++            {
++                const int k = traceback.second;
++                // CountJunctionA(i,j,RealT(1));
++                // CountMultiPaired(RealT(1));
++                // CountMultiBase(RealT(1));
++
++                // This is where we first recognize we're in a new multiloop. Store the things at i
++                multiloops.push_back(make_triple(i,j,0));
++                // std::cerr << "New multiloop! " << i << ":" << j << std::endl;
++
++                // std::cerr << "FCBifurc:JunctionA " << i << " " << ScoreJunctionA(i,j) << std::endl;
++                // std::cerr << "FCBifurc:MultiPaired " << i << " " << ScoreMultiPaired() << std::endl;
++                // std::cerr << "FCBifurc:MultiBase " << i << " " << ScoreMultiBase() << std::endl;
++
++                eos_cb_map[i] += ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
++
++                traceback_queue.push(make_triple(&FM1t[0], i, k));
++                traceback_queue.push(make_triple(&FMt[0], k, j));
++            }
++            break;
++#endif
++            case TB_FM1_PAIRED:
++            {
++                // CountJunctionA(j,i,RealT(1));
++                // CountMultiPaired(RealT(1));
++                // CountBasePair(i+1,j,RealT(1));
++
++                // HWS: We're in a multiloop -- this gets the index of the 5' base 
++                // of the current multiloop and puts in curr_multiloop ind.
++
++                int min_dist = 100000;
++                int curr_multiloop_ind = -1;
++
++                for(int ind=0; ind < multiloops.size(); ind++){
++                    if (multiloops[ind].first < i < multiloops[ind].second){
++                        if (i - multiloops[ind].first < min_dist){
++                            min_dist = i - multiloops[ind].first;
++                            curr_multiloop_ind = multiloops[ind].first;
++                        }
++                    }
++                }
++
++                // These all go in the multiloop ind
++                //std::cerr << "Paired:JunctionA " << curr_multiloop_ind << " " << ScoreJunctionA(j,i) << std::endl;
++                //std::cerr << "Paired:MultiPaired " << curr_multiloop_ind << " " << ScoreMultiPaired() << std::endl;
++                
++                eos_cb_map[curr_multiloop_ind] += ScoreJunctionA(j,i) + ScoreMultiPaired();
++
++                //This just goes with the next base pair
++                //std::cerr << "Paired:BasePair " << i << " " << ScoreBasePair(i+1, j) << std::endl;
++                eos_cb_map[i] += ScoreBasePairEvidence(i+1, j);
++
++                traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
++            }
++            break;
++            case TB_FM1_UNPAIRED:
++            {
++                // CountMultiUnpaired(i+1,RealT(1));
++
++                // HWS: We're in a multiloop -- this gets the index of the 5' base 
++                // of the current multiloop and puts in curr_multiloop ind.
++
++                int min_dist = 100000;
++                int curr_multiloop_ind = -1;
++
++                for(int ind=0; ind < multiloops.size(); ind++){
++                    if (multiloops[ind].first < i+1 < multiloops[ind].second){
++                        if (i+1 - multiloops[ind].first < min_dist){
++                            min_dist = i+1 - multiloops[ind].first;
++                            curr_multiloop_ind = multiloops[ind].first;
++                        }
++                    }
++                }
++                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
++                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(i+1) << std::endl;
++                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpairedEvidence(i+1);
++
++                traceback_queue.push(make_triple(&FM1t[0], i+1, j));
++            }
++            break;
++            case TB_FM_BIFURCATION:
++            {
++                const int k = traceback.second;
++                traceback_queue.push(make_triple(&FM1t[0], i, k));
++                traceback_queue.push(make_triple(&FMt[0], k, j));
++            }
++            break;
++            case TB_FM_UNPAIRED:
++            {
++                // CountMultiUnpaired(j,RealT(1));
++
++                // HWS: We're in a multiloop -- this gets the index of the 5' base 
++                // of the current multiloop and puts in curr_multiloop ind.
++
++                int min_dist = 100000;
++                int curr_multiloop_ind = -1;
++
++                for(int ind=0; ind < multiloops.size(); ind++){
++                    if (multiloops[ind].first < j < multiloops[ind].second){
++                        if (j - multiloops[ind].first < min_dist){
++                            min_dist = j - multiloops[ind].first;
++                            curr_multiloop_ind = multiloops[ind].first;
++                        }
++                    }
++                }
++                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
++
++                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(j) << std::endl;
++                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpairedEvidence(j);
++
++                traceback_queue.push(make_triple(&FMt[0], i, j-1));
++            }
++            break;
++            case TB_FM_FM1: 
++                traceback_queue.push(make_triple(&FM1t[0], i, j));
++                break;
++            case TB_F5_ZERO:
++                break;
++            case TB_F5_UNPAIRED:
++                CountExternalUnpaired(j,RealT(1));
++
++                // HWS: a score for unpaired things in the external loop, dump into the -1 eos_cb
++
++                //std::cerr << "ExternalUnpaired -1 " << ScoreExternalUnpaired(j) << std::endl;
++                eos_cb_map[-1] += ScoreExternalUnpairedEvidence(j);
++
+                 traceback_queue.push(make_triple(&F5t[0], 0, j-1));
+                 break;
+             case TB_F5_BIFURCATION:
+             {
+                 const int k = traceback.second;
+-                CountExternalPaired(RealT(1));
+-                CountBasePair(k+1,j,RealT(1));
+-                CountJunctionA(j,k,RealT(1));
++                // CountExternalPaired(RealT(1));
++                // CountBasePair(k+1,j,RealT(1));
++                // CountJunctionA(j,k,RealT(1));
+                 traceback_queue.push(make_triple(&F5t[0], 0, k));
+                 traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
++
++                //HWS: this is base pairs facing external loop. Hard-coding to print -1 as thinking these 
++                //should get summed in to the -1 "external loop " eos_cb category
++                
++                //std::cerr << "F5Bifurc:ExternalPaired -1 " << ScoreExternalPaired() << std::endl;
++                //std::cerr << "F5Bifurc:JunctionA -1 " << ScoreJunctionA(j,k) << std::endl;
++                eos_cb_map[-1] += ScoreExternalPaired()+ScoreJunctionA(j,k); //TODO: ScoreExternalPairedEvidence
++ 
++                // HWS: another base pair, print (k+1) - 1 to zero-index
++                //std::cerr << "F5Bifurc:BasePair " << k << " " << ScoreBasePair(k+1, j) << std::endl;
++                eos_cb_map[k] += ScoreBasePairEvidence(k+1, j);
++
+             }
+             break;
+             default:
+                 Assert(false, "Bad traceback.");
+         }
+     }
++    RealT local_sum = 0;
++    std::cerr << "EOS_CB: ";
++    for (std::pair<int, RealT> element : eos_cb_map) {
++        if (element.first == -1 || element.second != 0){
++        std::cerr << element.first << ", " << element.second << ", ";
++        local_sum += element.second;
++    }
++    }
++    std::cerr << std::endl;
++    std::cerr << "local sum " << local_sum << std::endl;
+ 
+-    FinalizeCounts();
+-    return GetCounts();
+ }
+ 
+ //////////////////////////////////////////////////////////////////////
+@@ -5938,7 +6718,6 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
+     //double starting_time = GetSystemTime();
+ 
+     const RealT Z = ComputeLogPartitionCoefficientESS();
+-
+     
+     for (int i = L; i >= 0; i--)
+     {
+@@ -5992,7 +6771,7 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
+                 
+                 if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
+                     CountHairpinEvidence(i,j,Fast_Exp(outside + ScoreHairpinEvidence(i,j)));
+-                
++
+                 // compute SUM (i<=p<p+2<=q<=j, p-i+j-q>0 : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
+                 
+ #if !FAST_SINGLE_BRANCH_LOOPS
+@@ -6128,8 +6907,12 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
+                 // compute ScoreHairpin(i,j)
+                 
+                 if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
++                {
+                     CountHairpinEvidence(i,j,Fast_Exp(outside + ScoreHairpinEvidence(i,j)));
+-                
++                                  //  std::cerr << ScoreHairpinEvidence(i,j) << std::endl; HWS
++
++                }
++
+                 // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
+                 
+ #if !FAST_SINGLE_BRANCH_LOOPS
+@@ -7716,8 +8499,8 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeGammaMLESS(std::vector<int> ev
+     RealT sum1 = 0;
+     RealT sum2 = 0;
+     int N = 0;
+-    int i = ev_cpd_id[0];
+-    int j = ev_cpd_id[1];
++    int i = ev_cpd_id[0]; // nucleotide type
++    int j = ev_cpd_id[1]; // paired or unpaired
+ 
+     double score_up = 0;
+ 
+@@ -7911,3 +8694,497 @@ int InferenceEngine<RealT>::AreZerosInSeq(int id_base, int which_data)
+     return areZeros;
+ }
+ 
++template<class RealT>
++void InferenceEngine<RealT>::InitRand(unsigned int seed)
++{
++    if (die) delete die;
++    die = new Die(seed);
++}
++
++// stochastic traceback algorithm
++template<class RealT>
++std::vector<int> InferenceEngine<RealT>::PredictPairingsStochasticTraceback() const
++{
++    enum { ST_FC, ST_F5, ST_FM, ST_FM1, ST_FE, ST_FN };
++
++    std::vector<int> solution(L+1,SStruct::UNPAIRED);
++    solution[0] = SStruct::UNKNOWN;
++
++    std::queue<triple<int,int,int> > traceback_queue;
++    traceback_queue.push(make_triple(int(ST_F5), 0, L));
++
++    while (!traceback_queue.empty())
++    {
++        triple<int,int,int> t = traceback_queue.front();
++        traceback_queue.pop();
++        const int i = t.second;
++        const int j = t.third;
++        int L2 = L; // ed to remove max bp dist
++
++        switch (t.first)
++        {
++#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
++            case ST_FC:
++                break;
++            case ST_FE:
++                break;
++            case ST_FN:
++                break;
++#else
++            case ST_FC:
++            {
++                if (0 < i && j < L2 && allow_paired[offset[i]+j+1]) // ???
++                {
++                    Roulette<int,RealT> roulette(*die);
++                
++                    // compute ScoreHairpin(i,j)
++                    if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
++                        roulette.add(EncodeTraceback(TB_FC_HAIRPIN,0), ScoreHairpin(i,j));
++                
++                    // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
++                    for (int p = i; p <= std::min(i+C_MAX_SINGLE_LENGTH,j); p++)
++                    {
++                        if (p > i && !allow_unpaired_position[p]) break;
++                        int q_min = std::max(p+2,p-i+j-C_MAX_SINGLE_LENGTH);
++                        for (int q = j; q >= q_min; q--)
++                        {
++                            if (q < j && !allow_unpaired_position[q+1]) break;
++                            if (!allow_paired[offset[p+1]+q]) continue;
++
++                            if (p == i && q == j)
++                            {
++                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
++                                             ScoreBasePair(i+1,j) + ScoreHelixStacking(i,j+1) +
++                                             FCi[offset[p+1]+q-1]);
++                            }
++                            else
++                            {
++                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
++                                             ScoreSingle(i,j,p,q) + FCi[offset[p+1]+q-1]);
++                            }
++                        }
++                    }
++
++                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j] + ScoreJunctionA(i,j) + a + c)
++                    for (int k=i+1; k < j; k++)
++                    {
++                        RealT FM2i = FM1i[offset[i]+k] + FMi[offset[k]+j];
++                        RealT val = FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
++                        roulette.add(EncodeTraceback(TB_FC_BIFURCATION, k), val);
++                    }
++
++                    // choose
++                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
++                    switch (traceback.first)
++                    {
++                        case TB_FC_HAIRPIN: 
++                            break;
++                        case TB_FC_SINGLE: 
++                        {
++                            const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
++                            const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
++                            solution[p+1] = q;
++                            solution[q] = p+1;
++                            traceback_queue.push(make_triple(int(ST_FC), p+1, q-1));
++                        }
++                        break;
++                        case TB_FC_BIFURCATION:
++                        {
++                            const int k = traceback.second;
++                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
++                            traceback_queue.push(make_triple(int(ST_FM), k, j));
++                        }
++                        break;
++                    }
++                } //else { Assert(!, "unreachable"); }
++            } 
++            break;
++#endif
++
++            case ST_FM:
++                if (0 < i && i+2 <= j && j < L2) // ???
++                {
++                    Roulette<int,RealT> roulette(*die);
++
++                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j]) 
++                    for (int k=i+1; k < j; k++)
++                    {
++                        RealT FM2i = FM1i[offset[i]+k] + FMi[offset[k]+j];
++                        roulette.add(EncodeTraceback(TB_FM_BIFURCATION, k), FM2i);
++                    }
++
++                    // compute FM[i,j-1] + b
++                    if (allow_unpaired_position[j])
++                    {
++                        roulette.add(EncodeTraceback(TB_FM_UNPAIRED,0),
++                                     FMi[offset[i]+j-1] + ScoreMultiUnpaired(j));
++                    }
++
++                    // compute FM1[i,j]
++                    roulette.add(EncodeTraceback(TB_FM_FM1,0), FM1i[offset[i]+j]);
++
++                    // choose
++                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
++                    switch (traceback.first)
++                    {
++                        case TB_FM_BIFURCATION:
++                        {
++                            const int k = traceback.second;
++                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
++                            traceback_queue.push(make_triple(int(ST_FM), k, j));
++                        }
++                        break;
++                        case TB_FM_UNPAIRED:
++                        {
++                            traceback_queue.push(make_triple(int(ST_FM), i, j-1));
++                        }
++                        break;
++                        case TB_FM_FM1: 
++                        {
++                            traceback_queue.push(make_triple(int(ST_FM1), i, j));
++                        }
++                        break;
++                    }
++                
++                } //else { Assert(!, "unreachable"); }
++                break;
++
++            case ST_FM1:
++                if (0 < i && i+2 <= j && j < L2) // ???
++                {
++                    Roulette<int,RealT> roulette(*die);
++
++                    // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
++                    if (allow_paired[offset[i+1]+j])
++                    {
++                        RealT value = FCi[offset[i+1]+j-1] + ScoreJunctionA(j,i) +
++                            ScoreMultiPaired() + ScoreBasePair(i+1,j);
++                        roulette.add(EncodeTraceback(TB_FM1_PAIRED, 0), value);
++                    }
++                
++                    // compute FM1[i+1,j] + b
++                    if (allow_unpaired_position[i+1])
++                    {
++                        roulette.add(EncodeTraceback(TB_FM1_UNPAIRED,0),
++                                     FM1i[offset[i+1]+j] + ScoreMultiUnpaired(i+1));
++                    }
++
++                    // choose
++                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
++                    switch (traceback.first)
++                    {
++                        case TB_FM1_PAIRED:
++                        {
++                            solution[i+1] = j;
++                            solution[j] = i+1;
++                            traceback_queue.push(make_triple(int(ST_FC), i+1, j-1));
++                        }
++                        break;
++                        case TB_FM1_UNPAIRED:
++                        {
++                            traceback_queue.push(make_triple(int(ST_FM1), i+1, j));
++                        }
++                        break;
++                    }
++                } //else { Assert(!, "unreachable"); }
++                break;
++
++            case ST_F5:
++                if (j!=0)
++                {
++                    Roulette<int,RealT> roulette(*die);
++
++                    // compute F5[j-1] + ScoreExternalUnpaired()
++                    if (allow_unpaired_position[j])
++                    {
++                        roulette.add(EncodeTraceback(TB_F5_UNPAIRED,0),
++                                     F5i[j-1] + ScoreExternalUnpaired(j));
++                    }
++        
++                    // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
++                    int l = 0; // ed remove max bp dist
++                    for (int k = l; k < j; k++)
++                    {
++                        if (allow_paired[offset[k+1]+j])
++                        {
++                            RealT value = F5i[k] + FCi[offset[k+1]+j-1] + ScoreExternalPaired() +
++                                ScoreBasePair(k+1,j) + ScoreJunctionA(j,k);
++                            roulette.add(EncodeTraceback(TB_F5_BIFURCATION,k), value);
++                        }      
++                    }
++
++                    // choose
++                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
++                    switch (traceback.first)
++                    {
++                        case TB_F5_ZERO:
++                            break;
++                        case TB_F5_UNPAIRED:
++                        {
++                            traceback_queue.push(make_triple(int(ST_F5), 0, j-1));
++                        }
++                        break;
++                        case TB_F5_BIFURCATION:
++                        {
++                            const int k = traceback.second;
++                            solution[k+1] = j;
++                            solution[j] = k+1;
++                            traceback_queue.push(make_triple(int(ST_F5), 0, k));
++                            traceback_queue.push(make_triple(int(ST_FC), k+1, j-1));
++                        }
++                        break;
++                    }
++                }
++                break;
++
++            default:
++                break;
++        }
++    }
++
++    return solution;
++}
++
++// stochastic traceback algorithm with chemical mapping data
++template<class RealT>
++std::vector<int> InferenceEngine<RealT>::PredictPairingsStochasticTracebackESS() const
++{
++    enum { ST_FC, ST_F5, ST_FM, ST_FM1, ST_FE, ST_FN };
++
++    std::vector<int> solution(L+1,SStruct::UNPAIRED);
++    solution[0] = SStruct::UNKNOWN;
++
++    std::queue<triple<int,int,int> > traceback_queue;
++    traceback_queue.push(make_triple(int(ST_F5), 0, L));
++
++    while (!traceback_queue.empty())
++    {
++        triple<int,int,int> t = traceback_queue.front();
++        traceback_queue.pop();
++        const int i = t.second;
++        const int j = t.third;
++        int L2 = L; // ed to remove max bp dist
++
++        switch (t.first)
++        {
++#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
++            case ST_FC:
++                break;
++            case ST_FE:
++                break;
++            case ST_FN:
++                break;
++#else
++            case ST_FC:
++            {
++                if (0 < i && j < L2 && allow_paired[offset[i]+j+1]) // ???
++                {
++                    Roulette<int,RealT> roulette(*die);
++                
++                    // compute ScoreHairpin(i,j)
++                    if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
++                        roulette.add(EncodeTraceback(TB_FC_HAIRPIN,0), ScoreHairpinEvidence(i,j));
++                
++                    // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
++                    for (int p = i; p <= std::min(i+C_MAX_SINGLE_LENGTH,j); p++)
++                    {
++                        if (p > i && !allow_unpaired_position[p]) break;
++                        int q_min = std::max(p+2,p-i+j-C_MAX_SINGLE_LENGTH);
++                        for (int q = j; q >= q_min; q--)
++                        {
++                            if (q < j && !allow_unpaired_position[q+1]) break;
++                            if (!allow_paired[offset[p+1]+q]) continue;
++
++                            if (p == i && q == j)
++                            {
++                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
++                                             ScoreBasePairEvidence(i+1,j) + ScoreHelixStacking(i,j+1) +
++                                             FCi_ess[offset[p+1]+q-1]);
++                            }
++                            else
++                            {
++                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
++                                             ScoreSingleEvidence(i,j,p,q) + FCi_ess[offset[p+1]+q-1]);
++                            }
++                        }
++                    }
++
++                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j] + ScoreJunctionA(i,j) + a + c)
++                    for (int k=i+1; k < j; k++)
++                    {
++                        RealT FM2i = FM1i_ess[offset[i]+k] + FMi_ess[offset[k]+j];
++                        RealT val = FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
++                        roulette.add(EncodeTraceback(TB_FC_BIFURCATION, k), val);
++                    }
++
++                    // choose
++                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
++                    switch (traceback.first)
++                    {
++                        case TB_FC_HAIRPIN: 
++                            break;
++                        case TB_FC_SINGLE: 
++                        {
++                            const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
++                            const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
++                            solution[p+1] = q;
++                            solution[q] = p+1;
++                            traceback_queue.push(make_triple(int(ST_FC), p+1, q-1));
++                        }
++                        break;
++                        case TB_FC_BIFURCATION:
++                        {
++                            const int k = traceback.second;
++                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
++                            traceback_queue.push(make_triple(int(ST_FM), k, j));
++                        }
++                        break;
++                    }
++                } //else { Assert(!, "unreachable"); }
++            } 
++            break;
++#endif
++
++            case ST_FM:
++                if (0 < i && i+2 <= j && j < L2) // ???
++                {
++                    Roulette<int,RealT> roulette(*die);
++
++                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j]) 
++                    for (int k=i+1; k < j; k++)
++                    {
++                        RealT FM2i = FM1i_ess[offset[i]+k] + FMi_ess[offset[k]+j];
++                        roulette.add(EncodeTraceback(TB_FM_BIFURCATION, k), FM2i);
++                    }
++
++                    // compute FM[i,j-1] + b
++                    if (allow_unpaired_position[j])
++                    {
++                        roulette.add(EncodeTraceback(TB_FM_UNPAIRED,0),
++                                     FMi_ess[offset[i]+j-1] + ScoreMultiUnpairedEvidence(j));
++                    }
++
++                    // compute FM1[i,j]
++                    roulette.add(EncodeTraceback(TB_FM_FM1,0), FM1i_ess[offset[i]+j]);
++
++                    // choose
++                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
++                    switch (traceback.first)
++                    {
++                        case TB_FM_BIFURCATION:
++                        {
++                            const int k = traceback.second;
++                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
++                            traceback_queue.push(make_triple(int(ST_FM), k, j));
++                        }
++                        break;
++                        case TB_FM_UNPAIRED:
++                        {
++                            traceback_queue.push(make_triple(int(ST_FM), i, j-1));
++                        }
++                        break;
++                        case TB_FM_FM1: 
++                        {
++                            traceback_queue.push(make_triple(int(ST_FM1), i, j));
++                        }
++                        break;
++                    }
++                
++                } //else { Assert(!, "unreachable"); }
++                break;
++
++            case ST_FM1:
++                if (0 < i && i+2 <= j && j < L2) // ???
++                {
++                    Roulette<int,RealT> roulette(*die);
++
++                    // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
++                    if (allow_paired[offset[i+1]+j])
++                    {
++                        RealT value = FCi_ess[offset[i+1]+j-1] + ScoreJunctionA(j,i) +
++                            ScoreMultiPaired() + ScoreBasePairEvidence(i+1,j);
++                        roulette.add(EncodeTraceback(TB_FM1_PAIRED, 0), value);
++                    }
++                
++                    // compute FM1[i+1,j] + b
++                    if (allow_unpaired_position[i+1])
++                    {
++                        roulette.add(EncodeTraceback(TB_FM1_UNPAIRED,0),
++                                     FM1i_ess[offset[i+1]+j] + ScoreMultiUnpaired(i+1));
++                    }
++
++                    // choose
++                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
++                    switch (traceback.first)
++                    {
++                        case TB_FM1_PAIRED:
++                        {
++                            solution[i+1] = j;
++                            solution[j] = i+1;
++                            traceback_queue.push(make_triple(int(ST_FC), i+1, j-1));
++                        }
++                        break;
++                        case TB_FM1_UNPAIRED:
++                        {
++                            traceback_queue.push(make_triple(int(ST_FM1), i+1, j));
++                        }
++                        break;
++                    }
++                } //else { Assert(!, "unreachable"); }
++                break;
++
++            case ST_F5:
++                if (j!=0)
++                {
++                    Roulette<int,RealT> roulette(*die);
++
++                    // compute F5[j-1] + ScoreExternalUnpaired()
++                    if (allow_unpaired_position[j])
++                    {
++                        roulette.add(EncodeTraceback(TB_F5_UNPAIRED,0),
++                                     F5i_ess[j-1] + ScoreExternalUnpairedEvidence(j));
++                    }
++        
++                    // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
++                    int l = 0; // ed remove max bp dist
++                    for (int k = l; k < j; k++)
++                    {
++                        if (allow_paired[offset[k+1]+j])
++                        {
++                            RealT value = F5i_ess[k] + FCi_ess[offset[k+1]+j-1] + ScoreExternalPaired() +
++                                ScoreBasePairEvidence(k+1,j) + ScoreJunctionA(j,k);
++                            roulette.add(EncodeTraceback(TB_F5_BIFURCATION,k), value);
++                        }      
++                    }
++
++                    // choose
++                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
++                    switch (traceback.first)
++                    {
++                        case TB_F5_ZERO:
++                            break;
++                        case TB_F5_UNPAIRED:
++                        {
++                            traceback_queue.push(make_triple(int(ST_F5), 0, j-1));
++                        }
++                        break;
++                        case TB_F5_BIFURCATION:
++                        {
++                            const int k = traceback.second;
++                            solution[k+1] = j;
++                            solution[j] = k+1;
++                            traceback_queue.push(make_triple(int(ST_F5), 0, k));
++                            traceback_queue.push(make_triple(int(ST_FC), k+1, j-1));
++                        }
++                        break;
++                    }
++                }
++                break;
++
++            default:
++                break;
++        }
++    }
++
++    return solution;
++}
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.cpp b/./SStruct.cpp
+index 77e7edc..14619ef 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.cpp
++++ b/./SStruct.cpp
+@@ -804,6 +804,22 @@ void SStruct::WriteBPSEQ(std::ostream &outfile, const int seq) const
+         outfile << i << ' ' << sequences[seq][i] << ' ' << mapping[i] << std::endl;
+ }
+ 
++//////////////////////////////////////////////////////////////////////
++// SStruct::WriteBPPSEQ()
++//
++// Write sequence in BPPSEQ format.  The BPSEQ format can only handle
++// single sequences, so it will only print out the sequence "seq".
++//////////////////////////////////////////////////////////////////////
++
++void SStruct::WriteBPPSEQ(std::ostream &outfile, std::vector<std::vector<double> > potential, const int seq)
++{
++    if (seq < 0 || seq >= int(sequences.size())) Error("Reference to invalid sequence.");
++    Assert(sequences[seq].length() == mapping.size(), "Inconsistent lengths.");
++    
++    for (size_t i = 1; i < mapping.size(); i++)
++        outfile << i << ' ' << sequences[seq][i] << " e1 " << potential[seq][i-1] << std::endl;
++}
++
+ //////////////////////////////////////////////////////////////////////
+ // SStruct::WriteParens()
+ //
+@@ -828,6 +844,29 @@ void SStruct::WriteParens(std::ostream &outfile) const
+     outfile << ConvertMappingToParens(mapping).substr(1) << std::endl;
+ }
+ 
++//////////////////////////////////////////////////////////////////////
++// SStruct::WriteParensOnly()
++//
++// Write sequence in parenthesized format.  This routine assumes that
++// the structure does not contain pseudoknots.  All sequences are
++// printed.
++//////////////////////////////////////////////////////////////////////
++
++void SStruct::WriteParensOnly(std::ostream &outfile) const
++{
++    if (ContainsPseudoknots()) Error("Cannot write structure containing pseudoknots using parenthesized format.");
++    
++    // print sequences
++    // for (size_t k = 0; k < sequences.size(); k++)
++    // {
++    //     outfile << ">" << names[k] << std::endl;
++    //     outfile << sequences[k].substr(1) << std::endl;
++    // }
++
++    // print structure
++    //outfile << ">structure" << std::endl;
++    outfile << ConvertMappingToParens(mapping).substr(1) << std::endl;
++}
+ //////////////////////////////////////////////////////////////////////
+ // SStruct::ComputePercentIdentity()
+ //
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.hpp b/./SStruct.hpp
+index 969b761..f2fa204 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.hpp
++++ b/./SStruct.hpp
+@@ -16,6 +16,7 @@
+ #include <vector>
+ #include <string>
+ #include <sstream>
++#include "Config.hpp"
+ #include "Utilities.hpp"
+ 
+ //////////////////////////////////////////////////////////////////////
+@@ -87,6 +88,9 @@ public:
+     // output in various formats
+     void WriteBPSEQ(std::ostream &outfile, const int seq = 0) const;
+     void WriteParens(std::ostream &outfile) const;
++    void WriteParensOnly(std::ostream &outfile) const;
++    void WriteBPPSEQ(std::ostream &outfile, std::vector<std::vector<double> > potential, const int seq = 0);
++
+ 
+     // compute alignment percent identity
+     double ComputePercentIdentity() const;
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.o b/./SStruct.o
+index 1063744..bd04391 100644
+Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.o and b/./SStruct.o differ
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ScorePrediction.o b/./ScorePrediction.o
+index 3d04098..14c63e8 100644
+Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/ScorePrediction.o and b/./ScorePrediction.o differ
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Utilities.hpp b/./Utilities.hpp
+index 7a6708d..af7ed86 100644
+--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Utilities.hpp
++++ b/./Utilities.hpp
+@@ -12,6 +12,7 @@
+ #include <cstdio>
+ #include <cstdlib>
+ #include <cstring>
++#include <list>
+ #include <climits>
+ #include <fstream>
+ #include <iomanip>
+diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/contrafold b/./contrafold
+index d833057..c530cc9 100755
+Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/contrafold and b/./contrafold differ
+diff --git a/./contrafold.params.basic b/./contrafold.params.basic
+new file mode 100644
+index 0000000..b00904b
+--- /dev/null
++++ b/./contrafold.params.basic
+@@ -0,0 +1,708 @@
++base_pair_AA 0.0
++base_pair_AC 0.0
++base_pair_AG 0.0
++base_pair_AU 1.0
++base_pair_CC 0.0
++base_pair_CG 1.0
++base_pair_CU 0.0
++base_pair_GG 0.0
++base_pair_GU 0.0
++base_pair_UU 0.0
++terminal_mismatch_AAAA 0.0
++terminal_mismatch_AAAC 0.0
++terminal_mismatch_AAAG 0.0
++terminal_mismatch_AAAU 0.0
++terminal_mismatch_AACA 0.0
++terminal_mismatch_AACC 0.0
++terminal_mismatch_AACG 0.0
++terminal_mismatch_AACU 0.0
++terminal_mismatch_AAGA 0.0
++terminal_mismatch_AAGC 0.0
++terminal_mismatch_AAGG 0.0
++terminal_mismatch_AAGU 0.0
++terminal_mismatch_AAUA 0.0
++terminal_mismatch_AAUC 0.0
++terminal_mismatch_AAUG 0.0
++terminal_mismatch_AAUU 0.0
++terminal_mismatch_ACAA 0.0
++terminal_mismatch_ACAC 0.0
++terminal_mismatch_ACAG 0.0
++terminal_mismatch_ACAU 0.0
++terminal_mismatch_ACCA 0.0
++terminal_mismatch_ACCC 0.0
++terminal_mismatch_ACCG 0.0
++terminal_mismatch_ACCU 0.0
++terminal_mismatch_ACGA 0.0
++terminal_mismatch_ACGC 0.0
++terminal_mismatch_ACGG 0.0
++terminal_mismatch_ACGU 0.0
++terminal_mismatch_ACUA 0.0
++terminal_mismatch_ACUC 0.0
++terminal_mismatch_ACUG 0.0
++terminal_mismatch_ACUU 0.0
++terminal_mismatch_AGAA 0.0
++terminal_mismatch_AGAC 0.0
++terminal_mismatch_AGAG 0.0
++terminal_mismatch_AGAU 0.0
++terminal_mismatch_AGCA 0.0
++terminal_mismatch_AGCC 0.0
++terminal_mismatch_AGCG 0.0
++terminal_mismatch_AGCU 0.0
++terminal_mismatch_AGGA 0.0
++terminal_mismatch_AGGC 0.0
++terminal_mismatch_AGGG 0.0
++terminal_mismatch_AGGU 0.0
++terminal_mismatch_AGUA 0.0
++terminal_mismatch_AGUC 0.0
++terminal_mismatch_AGUG 0.0
++terminal_mismatch_AGUU 0.0
++terminal_mismatch_AUAA 0.0
++terminal_mismatch_AUAC 0.0
++terminal_mismatch_AUAG 0.0
++terminal_mismatch_AUAU 0.0
++terminal_mismatch_AUCA 0.0
++terminal_mismatch_AUCC 0.0
++terminal_mismatch_AUCG 0.0
++terminal_mismatch_AUCU 0.0
++terminal_mismatch_AUGA 0.0
++terminal_mismatch_AUGC 0.0
++terminal_mismatch_AUGG 0.0
++terminal_mismatch_AUGU 0.0
++terminal_mismatch_AUUA 0.0
++terminal_mismatch_AUUC 0.0
++terminal_mismatch_AUUG 0.0
++terminal_mismatch_AUUU 0.0
++terminal_mismatch_CAAA 0.0
++terminal_mismatch_CAAC 0.0
++terminal_mismatch_CAAG 0.0
++terminal_mismatch_CAAU 0.0
++terminal_mismatch_CACA 0.0
++terminal_mismatch_CACC 0.0
++terminal_mismatch_CACG 0.0
++terminal_mismatch_CACU 0.0
++terminal_mismatch_CAGA 0.0
++terminal_mismatch_CAGC 0.0
++terminal_mismatch_CAGG 0.0
++terminal_mismatch_CAGU 0.0
++terminal_mismatch_CAUA 0.0
++terminal_mismatch_CAUC 0.0
++terminal_mismatch_CAUG 0.0
++terminal_mismatch_CAUU 0.0
++terminal_mismatch_CCAA 0.0
++terminal_mismatch_CCAC 0.0
++terminal_mismatch_CCAG 0.0
++terminal_mismatch_CCAU 0.0
++terminal_mismatch_CCCA 0.0
++terminal_mismatch_CCCC 0.0
++terminal_mismatch_CCCG 0.0
++terminal_mismatch_CCCU 0.0
++terminal_mismatch_CCGA 0.0
++terminal_mismatch_CCGC 0.0
++terminal_mismatch_CCGG 0.0
++terminal_mismatch_CCGU 0.0
++terminal_mismatch_CCUA 0.0
++terminal_mismatch_CCUC 0.0
++terminal_mismatch_CCUG 0.0
++terminal_mismatch_CCUU 0.0
++terminal_mismatch_CGAA 0.0
++terminal_mismatch_CGAC 0.0
++terminal_mismatch_CGAG 0.0
++terminal_mismatch_CGAU 0.0
++terminal_mismatch_CGCA 0.0
++terminal_mismatch_CGCC 0.0
++terminal_mismatch_CGCG 0.0
++terminal_mismatch_CGCU 0.0
++terminal_mismatch_CGGA 0.0
++terminal_mismatch_CGGC 0.0
++terminal_mismatch_CGGG 0.0
++terminal_mismatch_CGGU 0.0
++terminal_mismatch_CGUA 0.0
++terminal_mismatch_CGUC 0.0
++terminal_mismatch_CGUG 0.0
++terminal_mismatch_CGUU 0.0
++terminal_mismatch_CUAA 0.0
++terminal_mismatch_CUAC 0.0
++terminal_mismatch_CUAG 0.0
++terminal_mismatch_CUAU 0.0
++terminal_mismatch_CUCA 0.0
++terminal_mismatch_CUCC 0.0
++terminal_mismatch_CUCG 0.0
++terminal_mismatch_CUCU 0.0
++terminal_mismatch_CUGA 0.0
++terminal_mismatch_CUGC 0.0
++terminal_mismatch_CUGG 0.0
++terminal_mismatch_CUGU 0.0
++terminal_mismatch_CUUA 0.0
++terminal_mismatch_CUUC 0.0
++terminal_mismatch_CUUG 0.0
++terminal_mismatch_CUUU 0.0
++terminal_mismatch_GAAA 0.0
++terminal_mismatch_GAAC 0.0
++terminal_mismatch_GAAG 0.0
++terminal_mismatch_GAAU 0.0
++terminal_mismatch_GACA 0.0
++terminal_mismatch_GACC 0.0
++terminal_mismatch_GACG 0.0
++terminal_mismatch_GACU 0.0
++terminal_mismatch_GAGA 0.0
++terminal_mismatch_GAGC 0.0
++terminal_mismatch_GAGG 0.0
++terminal_mismatch_GAGU 0.0
++terminal_mismatch_GAUA 0.0
++terminal_mismatch_GAUC 0.0
++terminal_mismatch_GAUG 0.0
++terminal_mismatch_GAUU 0.0
++terminal_mismatch_GCAA 0.0
++terminal_mismatch_GCAC 0.0
++terminal_mismatch_GCAG 0.0
++terminal_mismatch_GCAU 0.0
++terminal_mismatch_GCCA 0.0
++terminal_mismatch_GCCC 0.0
++terminal_mismatch_GCCG 0.0
++terminal_mismatch_GCCU 0.0
++terminal_mismatch_GCGA 0.0
++terminal_mismatch_GCGC 0.0
++terminal_mismatch_GCGG 0.0
++terminal_mismatch_GCGU 0.0
++terminal_mismatch_GCUA 0.0
++terminal_mismatch_GCUC 0.0
++terminal_mismatch_GCUG 0.0
++terminal_mismatch_GCUU 0.0
++terminal_mismatch_GGAA 0.0
++terminal_mismatch_GGAC 0.0
++terminal_mismatch_GGAG 0.0
++terminal_mismatch_GGAU 0.0
++terminal_mismatch_GGCA 0.0
++terminal_mismatch_GGCC 0.0
++terminal_mismatch_GGCG 0.0
++terminal_mismatch_GGCU 0.0
++terminal_mismatch_GGGA 0.0
++terminal_mismatch_GGGC 0.0
++terminal_mismatch_GGGG 0.0
++terminal_mismatch_GGGU 0.0
++terminal_mismatch_GGUA 0.0
++terminal_mismatch_GGUC 0.0
++terminal_mismatch_GGUG 0.0
++terminal_mismatch_GGUU 0.0
++terminal_mismatch_GUAA 0.0
++terminal_mismatch_GUAC 0.0
++terminal_mismatch_GUAG 0.0
++terminal_mismatch_GUAU 0.0
++terminal_mismatch_GUCA 0.0
++terminal_mismatch_GUCC 0.0
++terminal_mismatch_GUCG 0.0
++terminal_mismatch_GUCU 0.0
++terminal_mismatch_GUGA 0.0
++terminal_mismatch_GUGC 0.0
++terminal_mismatch_GUGG 0.0
++terminal_mismatch_GUGU 0.0
++terminal_mismatch_GUUA 0.0
++terminal_mismatch_GUUC 0.0
++terminal_mismatch_GUUG 0.0
++terminal_mismatch_GUUU 0.0
++terminal_mismatch_UAAA 0.0
++terminal_mismatch_UAAC 0.0
++terminal_mismatch_UAAG 0.0
++terminal_mismatch_UAAU 0.0
++terminal_mismatch_UACA 0.0
++terminal_mismatch_UACC 0.0
++terminal_mismatch_UACG 0.0
++terminal_mismatch_UACU 0.0
++terminal_mismatch_UAGA 0.0
++terminal_mismatch_UAGC 0.0
++terminal_mismatch_UAGG 0.0
++terminal_mismatch_UAGU 0.0
++terminal_mismatch_UAUA 0.0
++terminal_mismatch_UAUC 0.0
++terminal_mismatch_UAUG 0.0
++terminal_mismatch_UAUU 0.0
++terminal_mismatch_UCAA 0.0
++terminal_mismatch_UCAC 0.0
++terminal_mismatch_UCAG 0.0
++terminal_mismatch_UCAU 0.0
++terminal_mismatch_UCCA 0.0
++terminal_mismatch_UCCC 0.0
++terminal_mismatch_UCCG 0.0
++terminal_mismatch_UCCU 0.0
++terminal_mismatch_UCGA 0.0
++terminal_mismatch_UCGC 0.0
++terminal_mismatch_UCGG 0.0
++terminal_mismatch_UCGU 0.0
++terminal_mismatch_UCUA 0.0
++terminal_mismatch_UCUC 0.0
++terminal_mismatch_UCUG 0.0
++terminal_mismatch_UCUU 0.0
++terminal_mismatch_UGAA 0.0
++terminal_mismatch_UGAC 0.0
++terminal_mismatch_UGAG 0.0
++terminal_mismatch_UGAU 0.0
++terminal_mismatch_UGCA 0.0
++terminal_mismatch_UGCC 0.0
++terminal_mismatch_UGCG 0.0
++terminal_mismatch_UGCU 0.0
++terminal_mismatch_UGGA 0.0
++terminal_mismatch_UGGC 0.0
++terminal_mismatch_UGGG 0.0
++terminal_mismatch_UGGU 0.0
++terminal_mismatch_UGUA 0.0
++terminal_mismatch_UGUC 0.0
++terminal_mismatch_UGUG 0.0
++terminal_mismatch_UGUU 0.0
++terminal_mismatch_UUAA 0.0
++terminal_mismatch_UUAC 0.0
++terminal_mismatch_UUAG 0.0
++terminal_mismatch_UUAU 0.0
++terminal_mismatch_UUCA 0.0
++terminal_mismatch_UUCC 0.0
++terminal_mismatch_UUCG 0.0
++terminal_mismatch_UUCU 0.0
++terminal_mismatch_UUGA 0.0
++terminal_mismatch_UUGC 0.0
++terminal_mismatch_UUGG 0.0
++terminal_mismatch_UUGU 0.0
++terminal_mismatch_UUUA 0.0
++terminal_mismatch_UUUC 0.0
++terminal_mismatch_UUUG 0.0
++terminal_mismatch_UUUU 0.0
++hairpin_length_at_least_0 0.0
++hairpin_length_at_least_1 0.0
++hairpin_length_at_least_2 0.0
++hairpin_length_at_least_3 0.0
++hairpin_length_at_least_4 0.0
++hairpin_length_at_least_5 0.0
++hairpin_length_at_least_6 0.0
++hairpin_length_at_least_7 0.0
++hairpin_length_at_least_8 0.0
++hairpin_length_at_least_9 0.0
++hairpin_length_at_least_10 0.0
++hairpin_length_at_least_11 0.0
++hairpin_length_at_least_12 0.0
++hairpin_length_at_least_13 0.0
++hairpin_length_at_least_14 0.0
++hairpin_length_at_least_15 0.0
++hairpin_length_at_least_16 0.0
++hairpin_length_at_least_17 0.0
++hairpin_length_at_least_18 0.0
++hairpin_length_at_least_19 0.0
++hairpin_length_at_least_20 0.0
++hairpin_length_at_least_21 0.0
++hairpin_length_at_least_22 0.0
++hairpin_length_at_least_23 0.0
++hairpin_length_at_least_24 0.0
++hairpin_length_at_least_25 0.0
++hairpin_length_at_least_26 0.0
++hairpin_length_at_least_27 0.0
++hairpin_length_at_least_28 0.0
++hairpin_length_at_least_29 0.0
++hairpin_length_at_least_30 0.0
++internal_explicit_1_1 0.0
++internal_explicit_1_2 0.0
++internal_explicit_1_3 0.0
++internal_explicit_1_4 0.0
++internal_explicit_2_2 0.0
++internal_explicit_2_3 0.0
++internal_explicit_2_4 0.0
++internal_explicit_3_3 0.0
++internal_explicit_3_4 0.0
++internal_explicit_4_4 0.0
++bulge_length_at_least_1 0.0
++bulge_length_at_least_2 0.0
++bulge_length_at_least_3 0.0
++bulge_length_at_least_4 0.0
++bulge_length_at_least_5 0.0
++bulge_length_at_least_6 0.0
++bulge_length_at_least_7 0.0
++bulge_length_at_least_8 0.0
++bulge_length_at_least_9 0.0
++bulge_length_at_least_10 0.0
++bulge_length_at_least_11 0.0
++bulge_length_at_least_12 0.0
++bulge_length_at_least_13 0.0
++bulge_length_at_least_14 0.0
++bulge_length_at_least_15 0.0
++bulge_length_at_least_16 0.0
++bulge_length_at_least_17 0.0
++bulge_length_at_least_18 0.0
++bulge_length_at_least_19 0.0
++bulge_length_at_least_20 0.0
++bulge_length_at_least_21 0.0
++bulge_length_at_least_22 0.0
++bulge_length_at_least_23 0.0
++bulge_length_at_least_24 0.0
++bulge_length_at_least_25 0.0
++bulge_length_at_least_26 0.0
++bulge_length_at_least_27 0.0
++bulge_length_at_least_28 0.0
++bulge_length_at_least_29 0.0
++bulge_length_at_least_30 0.0
++internal_length_at_least_2 0.0
++internal_length_at_least_3 0.0
++internal_length_at_least_4 0.0
++internal_length_at_least_5 0.0
++internal_length_at_least_6 0.0
++internal_length_at_least_7 0.0
++internal_length_at_least_8 0.0
++internal_length_at_least_9 0.0
++internal_length_at_least_10 0.0
++internal_length_at_least_11 0.0
++internal_length_at_least_12 0.0
++internal_length_at_least_13 0.0
++internal_length_at_least_14 0.0
++internal_length_at_least_15 0.0
++internal_length_at_least_16 0.0
++internal_length_at_least_17 0.0
++internal_length_at_least_18 0.0
++internal_length_at_least_19 0.0
++internal_length_at_least_20 0.0
++internal_length_at_least_21 0.0
++internal_length_at_least_22 0.0
++internal_length_at_least_23 0.0
++internal_length_at_least_24 0.0
++internal_length_at_least_25 0.0
++internal_length_at_least_26 0.0
++internal_length_at_least_27 0.0
++internal_length_at_least_28 0.0
++internal_length_at_least_29 0.0
++internal_length_at_least_30 0.0
++internal_symmetric_length_at_least_1 0.0
++internal_symmetric_length_at_least_2 0.0
++internal_symmetric_length_at_least_3 0.0
++internal_symmetric_length_at_least_4 0.0
++internal_symmetric_length_at_least_5 0.0
++internal_symmetric_length_at_least_6 0.0
++internal_symmetric_length_at_least_7 0.0
++internal_symmetric_length_at_least_8 0.0
++internal_symmetric_length_at_least_9 0.0
++internal_symmetric_length_at_least_10 0.0
++internal_symmetric_length_at_least_11 0.0
++internal_symmetric_length_at_least_12 0.0
++internal_symmetric_length_at_least_13 0.0
++internal_symmetric_length_at_least_14 0.0
++internal_symmetric_length_at_least_15 0.0
++internal_asymmetry_at_least_1 0.0
++internal_asymmetry_at_least_2 0.0
++internal_asymmetry_at_least_3 0.0
++internal_asymmetry_at_least_4 0.0
++internal_asymmetry_at_least_5 0.0
++internal_asymmetry_at_least_6 0.0
++internal_asymmetry_at_least_7 0.0
++internal_asymmetry_at_least_8 0.0
++internal_asymmetry_at_least_9 0.0
++internal_asymmetry_at_least_10 0.0
++internal_asymmetry_at_least_11 0.0
++internal_asymmetry_at_least_12 0.0
++internal_asymmetry_at_least_13 0.0
++internal_asymmetry_at_least_14 0.0
++internal_asymmetry_at_least_15 0.0
++internal_asymmetry_at_least_16 0.0
++internal_asymmetry_at_least_17 0.0
++internal_asymmetry_at_least_18 0.0
++internal_asymmetry_at_least_19 0.0
++internal_asymmetry_at_least_20 0.0
++internal_asymmetry_at_least_21 0.0
++internal_asymmetry_at_least_22 0.0
++internal_asymmetry_at_least_23 0.0
++internal_asymmetry_at_least_24 0.0
++internal_asymmetry_at_least_25 0.0
++internal_asymmetry_at_least_26 0.0
++internal_asymmetry_at_least_27 0.0
++internal_asymmetry_at_least_28 0.0
++bulge_0x1_nucleotides_A 0.0
++bulge_0x1_nucleotides_C 0.0
++bulge_0x1_nucleotides_G 0.0
++bulge_0x1_nucleotides_U 0.0
++internal_1x1_nucleotides_AA 0.0
++internal_1x1_nucleotides_AC 0.0
++internal_1x1_nucleotides_AG 0.0
++internal_1x1_nucleotides_AU 0.0
++internal_1x1_nucleotides_CC 0.0
++internal_1x1_nucleotides_CG 0.0
++internal_1x1_nucleotides_CU 0.0
++internal_1x1_nucleotides_GG 0.0
++internal_1x1_nucleotides_GU 0.0
++internal_1x1_nucleotides_UU 0.0
++helix_stacking_AAAA 0.0
++helix_stacking_AAAC 0.0
++helix_stacking_AAAG 0.0
++helix_stacking_AAAU 0.0
++helix_stacking_AACA 0.0
++helix_stacking_AACC 0.0
++helix_stacking_AACG 0.0
++helix_stacking_AACU 0.0
++helix_stacking_AAGA 0.0
++helix_stacking_AAGC 0.0
++helix_stacking_AAGG 0.0
++helix_stacking_AAGU 0.0
++helix_stacking_AAUA 0.0
++helix_stacking_AAUC 0.0
++helix_stacking_AAUG 0.0
++helix_stacking_AAUU 0.0
++helix_stacking_ACAC 0.0
++helix_stacking_ACAG 0.0
++helix_stacking_ACAU 0.0
++helix_stacking_ACCA 0.0
++helix_stacking_ACCC 0.0
++helix_stacking_ACCG 0.0
++helix_stacking_ACCU 0.0
++helix_stacking_ACGA 0.0
++helix_stacking_ACGC 0.0
++helix_stacking_ACGG 0.0
++helix_stacking_ACGU 0.0
++helix_stacking_ACUA 0.0
++helix_stacking_ACUC 0.0
++helix_stacking_ACUG 0.0
++helix_stacking_ACUU 0.0
++helix_stacking_AGAC 0.0
++helix_stacking_AGAG 0.0
++helix_stacking_AGAU 0.0
++helix_stacking_AGCC 0.0
++helix_stacking_AGCG 0.0
++helix_stacking_AGCU 0.0
++helix_stacking_AGGA 0.0
++helix_stacking_AGGC 0.0
++helix_stacking_AGGG 0.0
++helix_stacking_AGGU 0.0
++helix_stacking_AGUA 0.0
++helix_stacking_AGUC 0.0
++helix_stacking_AGUG 0.0
++helix_stacking_AGUU 0.0
++helix_stacking_AUAC 0.0
++helix_stacking_AUAG 0.0
++helix_stacking_AUAU 0.0
++helix_stacking_AUCC 0.0
++helix_stacking_AUCG 0.0
++helix_stacking_AUCU 0.0
++helix_stacking_AUGC 0.0
++helix_stacking_AUGG 0.0
++helix_stacking_AUGU 0.0
++helix_stacking_AUUA 0.0
++helix_stacking_AUUC 0.0
++helix_stacking_AUUG 0.0
++helix_stacking_AUUU 0.0
++helix_stacking_CAAC 0.0
++helix_stacking_CAAG 0.0
++helix_stacking_CAAU 0.0
++helix_stacking_CACC 0.0
++helix_stacking_CACG 0.0
++helix_stacking_CACU 0.0
++helix_stacking_CAGC 0.0
++helix_stacking_CAGG 0.0
++helix_stacking_CAGU 0.0
++helix_stacking_CAUC 0.0
++helix_stacking_CAUG 0.0
++helix_stacking_CAUU 0.0
++helix_stacking_CCAG 0.0
++helix_stacking_CCAU 0.0
++helix_stacking_CCCC 0.0
++helix_stacking_CCCG 0.0
++helix_stacking_CCCU 0.0
++helix_stacking_CCGC 0.0
++helix_stacking_CCGG 0.0
++helix_stacking_CCGU 0.0
++helix_stacking_CCUC 0.0
++helix_stacking_CCUG 0.0
++helix_stacking_CCUU 0.0
++helix_stacking_CGAG 0.0
++helix_stacking_CGAU 0.0
++helix_stacking_CGCG 0.0
++helix_stacking_CGCU 0.0
++helix_stacking_CGGC 0.0
++helix_stacking_CGGG 0.0
++helix_stacking_CGGU 0.0
++helix_stacking_CGUC 0.0
++helix_stacking_CGUG 0.0
++helix_stacking_CGUU 0.0
++helix_stacking_CUAG 0.0
++helix_stacking_CUAU 0.0
++helix_stacking_CUCG 0.0
++helix_stacking_CUCU 0.0
++helix_stacking_CUGG 0.0
++helix_stacking_CUGU 0.0
++helix_stacking_CUUC 0.0
++helix_stacking_CUUG 0.0
++helix_stacking_CUUU 0.0
++helix_stacking_GAAG 0.0
++helix_stacking_GAAU 0.0
++helix_stacking_GACG 0.0
++helix_stacking_GACU 0.0
++helix_stacking_GAGG 0.0
++helix_stacking_GAGU 0.0
++helix_stacking_GAUG 0.0
++helix_stacking_GAUU 0.0
++helix_stacking_GCAU 0.0
++helix_stacking_GCCG 0.0
++helix_stacking_GCCU 0.0
++helix_stacking_GCGG 0.0
++helix_stacking_GCGU 0.0
++helix_stacking_GCUG 0.0
++helix_stacking_GCUU 0.0
++helix_stacking_GGAU 0.0
++helix_stacking_GGCU 0.0
++helix_stacking_GGGG 0.0
++helix_stacking_GGGU 0.0
++helix_stacking_GGUG 0.0
++helix_stacking_GGUU 0.0
++helix_stacking_GUAU 0.0
++helix_stacking_GUCU 0.0
++helix_stacking_GUGU 0.0
++helix_stacking_GUUG 0.0
++helix_stacking_GUUU 0.0
++helix_stacking_UAAU 0.0
++helix_stacking_UACU 0.0
++helix_stacking_UAGU 0.0
++helix_stacking_UAUU 0.0
++helix_stacking_UCCU 0.0
++helix_stacking_UCGU 0.0
++helix_stacking_UCUU 0.0
++helix_stacking_UGGU 0.0
++helix_stacking_UGUU 0.0
++helix_stacking_UUUU 0.0
++helix_closing_AA 0.0
++helix_closing_AC 0.0
++helix_closing_AG 0.0
++helix_closing_AU 0.0
++helix_closing_CA 0.0
++helix_closing_CC 0.0
++helix_closing_CG 0.0
++helix_closing_CU 0.0
++helix_closing_GA 0.0
++helix_closing_GC 0.0
++helix_closing_GG 0.0
++helix_closing_GU 0.0
++helix_closing_UA 0.0
++helix_closing_UC 0.0
++helix_closing_UG 0.0
++helix_closing_UU 0.0
++multi_base 0.0
++multi_unpaired 0.0
++multi_paired 0.0
++dangle_left_AAA 0.0
++dangle_left_AAC 0.0
++dangle_left_AAG 0.0
++dangle_left_AAU 0.0
++dangle_left_ACA 0.0
++dangle_left_ACC 0.0
++dangle_left_ACG 0.0
++dangle_left_ACU 0.0
++dangle_left_AGA 0.0
++dangle_left_AGC 0.0
++dangle_left_AGG 0.0
++dangle_left_AGU 0.0
++dangle_left_AUA 0.0
++dangle_left_AUC 0.0
++dangle_left_AUG 0.0
++dangle_left_AUU 0.0
++dangle_left_CAA 0.0
++dangle_left_CAC 0.0
++dangle_left_CAG 0.0
++dangle_left_CAU 0.0
++dangle_left_CCA 0.0
++dangle_left_CCC 0.0
++dangle_left_CCG 0.0
++dangle_left_CCU 0.0
++dangle_left_CGA 0.0
++dangle_left_CGC 0.0
++dangle_left_CGG 0.0
++dangle_left_CGU 0.0
++dangle_left_CUA 0.0
++dangle_left_CUC 0.0
++dangle_left_CUG 0.0
++dangle_left_CUU 0.0
++dangle_left_GAA 0.0
++dangle_left_GAC 0.0
++dangle_left_GAG 0.0
++dangle_left_GAU 0.0
++dangle_left_GCA 0.0
++dangle_left_GCC 0.0
++dangle_left_GCG 0.0
++dangle_left_GCU 0.0
++dangle_left_GGA 0.0
++dangle_left_GGC 0.0
++dangle_left_GGG 0.0
++dangle_left_GGU 0.0
++dangle_left_GUA 0.0
++dangle_left_GUC 0.0
++dangle_left_GUG 0.0
++dangle_left_GUU 0.0
++dangle_left_UAA 0.0
++dangle_left_UAC 0.0
++dangle_left_UAG 0.0
++dangle_left_UAU 0.0
++dangle_left_UCA 0.0
++dangle_left_UCC 0.0
++dangle_left_UCG 0.0
++dangle_left_UCU 0.0
++dangle_left_UGA 0.0
++dangle_left_UGC 0.0
++dangle_left_UGG 0.0
++dangle_left_UGU 0.0
++dangle_left_UUA 0.0
++dangle_left_UUC 0.0
++dangle_left_UUG 0.0
++dangle_left_UUU 0.0
++dangle_right_AAA 0.0
++dangle_right_AAC 0.0
++dangle_right_AAG 0.0
++dangle_right_AAU 0.0
++dangle_right_ACA 0.0
++dangle_right_ACC 0.0
++dangle_right_ACG 0.0
++dangle_right_ACU 0.0
++dangle_right_AGA 0.0
++dangle_right_AGC 0.0
++dangle_right_AGG 0.0
++dangle_right_AGU 0.0
++dangle_right_AUA 0.0
++dangle_right_AUC 0.0
++dangle_right_AUG 0.0
++dangle_right_AUU 0.0
++dangle_right_CAA 0.0
++dangle_right_CAC 0.0
++dangle_right_CAG 0.0
++dangle_right_CAU 0.0
++dangle_right_CCA 0.0
++dangle_right_CCC 0.0
++dangle_right_CCG 0.0
++dangle_right_CCU 0.0
++dangle_right_CGA 0.0
++dangle_right_CGC 0.0
++dangle_right_CGG 0.0
++dangle_right_CGU 0.0
++dangle_right_CUA 0.0
++dangle_right_CUC 0.0
++dangle_right_CUG 0.0
++dangle_right_CUU 0.0
++dangle_right_GAA 0.0
++dangle_right_GAC 0.0
++dangle_right_GAG 0.0
++dangle_right_GAU 0.0
++dangle_right_GCA 0.0
++dangle_right_GCC 0.0
++dangle_right_GCG 0.0
++dangle_right_GCU 0.0
++dangle_right_GGA 0.0
++dangle_right_GGC 0.0
++dangle_right_GGG 0.0
++dangle_right_GGU 0.0
++dangle_right_GUA 0.0
++dangle_right_GUC 0.0
++dangle_right_GUG 0.0
++dangle_right_GUU 0.0
++dangle_right_UAA 0.0
++dangle_right_UAC 0.0
++dangle_right_UAG 0.0
++dangle_right_UAU 0.0
++dangle_right_UCA 0.0
++dangle_right_UCC 0.0
++dangle_right_UCG 0.0
++dangle_right_UCU 0.0
++dangle_right_UGA 0.0
++dangle_right_UGC 0.0
++dangle_right_UGG 0.0
++dangle_right_UGU 0.0
++dangle_right_UUA 0.0
++dangle_right_UUC 0.0
++dangle_right_UUG 0.0
++dangle_right_UUU 0.0
++external_unpaired 0.0
++external_paired 0.0
+diff --git a/./hhr.seq b/./hhr.seq
+new file mode 100644
+index 0000000..a0d1ffb
+--- /dev/null
++++ b/./hhr.seq
+@@ -0,0 +1 @@
++ACGCUGUCUGUACUUGUAUCAGUACACUGACGAGUCCCUAAAGGACGAAACAGCGC
+diff --git a/./out b/./out
+new file mode 100644
+index 0000000..c6814eb
+--- /dev/null
++++ b/./out
+@@ -0,0 +1,1000 @@
++.((((((.(((((......)))))...))).))).......(.......).....
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.........................(((....(((.......)))....)))...
++((((((((......((..(((....))))).))...............)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))........((((.....))))...)))))).
++((((((.(((.((.(........)((......))......)).)).).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++......(((.(....)..)))..................................
++.((....((((((......)))))).......((((.....))))......))..
++.......((((((......)))))).......((((.....))))..........
++((((((.((((((......)))))).......(((.......)))...)))))).
++((((((.(((.((........(......)...........)).)))..)))))).
++((((((.......(..........).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++(((((((((((((......))))))..)))).((((.....))))......))).
++........................(((....))).....................
++.(((((.((((((......))))))....(..(((.......))))..)))))..
++((((...((((((......)))))).......((((.....)))).....)))).
++(((((..(((((........)))))((....))(((.....))).....))))).
++(((((((((((((......))))))..))...(((.......)))....))))).
++(((((((......(((......))).....))((((.....))))....))))).
++((((((..((....(((....)))....))..((((.....))))...)))))).
++((.((..(((((........))))).)).)).((((.....))))..........
++.......((((((......))))))..........((....))............
++.((((............((((....))))...(((.......)))....))))..
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......))))).....((..(((.....)))))..)))))).
++(((((((((((((......))))))....................)..)))))).
++((((((.(((((........)))))(....).((((.....))))...)))))).
++(((.(((((((((......))))))..)))..((((.....))))......))).
++...((((((..((.((..(((....))))).))..)....).)))).........
++..........((((((..(((....))))))))).....................
++.(((((..(((((......)))))........((((.....))))...)))))..
++((((((.((.(((((..((((....))))))))).)..........).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((((........)))))(((..(....).)..))......)))))).
++(((((((.(....)...((((....))))...((((.....))))))..))))).
++..(((....(....)...))).......................((......)).
++.......((((((.(...)))))))(((....((((.....))))....)))...
++.......((((((......)))))).......((((.....))))..........
++((((((((((((........)))))..)))..((((.....)))).....)))).
++(((((...((...(((......)))...))..((((.....))))....))))).
++((((((...(.(((.((((((....))))........))))).)....)))))).
++((((((.............((....)).....(((.......)))...)))))).
++(((..((((((((......))))))..))...((((.....))))......))).
++.(((((.....((......))...........((((.....))))...)))))..
++....((.((((((......))))))...)).........................
++....(..((((((......)))))))......((((.....))))..........
++((((((...((((......)))).........((((.....))))...)))))).
++((((.............((((....))))...(((..........)..)))))).
++((((((.(((((........))))).(....)((((.....))))...)))))).
++((((((..(((((......))))).(....).((((.....))))...)))))).
++((((((......(((..((((....)))))))((((.....))))...)))))).
++.(((((.(((((........))))).......((((.....))))...)))))..
++....(((.(((((......)))))...))).........................
++(((((((.((.(((..........(((....))).....))).)))..)))))).
++((((((.((((((......))))))(......(((.......))))..)))))).
++(((((((((((((......)))))).......((((.....))))))..))))).
++(((((..(((.(((..........................))))))...))))).
++(((.....(((((......)))))..((....((((.....))))....))))).
++........(((((......))))).(((....(((.......)))....)))...
++.(((((.(.........((((....))))...((((.....)))))..)))))..
++.......((((((......))))))(((....((((.....))))....)))...
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((((..((........)))))))..(....).)))..)))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......................)))))).
++.......(((((........))))).......((((.....))))..........
++.(((((.(((((........))))).......((((.....))))...)))))..
++.(((((..........................((((.....))))...)))))..
++((((((............(.(....).)....((((.....))))...)))))).
++((((((..((((.((...))))))....))..((((.....)))).....)))).
++(((((((.......)..((((....))))...((((.....))))...)))))).
++(((.((.((((((......))))))(....).((((.....))))...)).))).
++.............................((.((((.....)))).......)).
++...(((((((((........)))))..)))..((((.....))))).........
++.((((........(..............)...((((.....))))....))))..
++((((((.(((((.((...))))))).......((((.....))))...)))))).
++(((((.(((((((......)))))................)).......))))).
++(((((...(((((......)))))........((((.....))))....))))).
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++(((((..(((((........))))).......((((.....))))....))))).
++(......(((((.((...)))))))..)...........................
++..............(((....))).(((....((((.....))))....)))...
++.(((((..((((........))))..(......(((.....)))...))))))..
++((((((.((.(((((..((((....))))))))).)..........).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))........(((.......)))...)))))).
++((((((.(..((((((..(((....)))))))))............).)))))).
++((((.((((((((.(...))))))).....(....).........))...)))).
++.............................(..((((.....))))).........
++.......((((((......)))))).......((((.....))))..........
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((.(((((............))).........)).))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.((((((((.........)))...........((((.....))))...)))))..
++........(((((......))))).((.....((((.....)))).....))...
++........((((.((...))))))........((((.....))))..........
++(((((.(((.........)))...........((((.....))))....))))).
++(((((..((((((......)))))).(.....(((.......)))...)))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++(((((..(....(((((....)))...))..)((((.....))))....))))).
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.......((((((......)))))).......((((.....))))..........
++.......((((((......))))))....(..(.((.....)).)......)...
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++(((((((...(((((..((((....)))))))))...........)..)))))).
++((((((.(((((........)))))....((..(((.....)))))..)))))).
++.......................(.(((....((((.....))))....))).).
++.(((((.(((.((..........(......).........)).)))..)))))..
++.((((((((((((......)))))).......((((.....))))))..))))..
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(((.(((.........................))).)))..)))))).
++((((((.((((((......))))))........(((.....)))....)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((.(((.((((..((((....)))).......)..))).)))..)))))).
++.............((((....))))((.....((((.....)))).....))...
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.(((((..(...)(((......))).......((((.....))))...)))))..
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((.(((((((......))))))..)....((((.....))))....))))).
++(((((((.(((((......)))))...))...((((.....))))....))))).
++((((((.((((((......)))))...)....((((.....))))...)))))).
++((((((.((((((......))))))(....).((((.....))))...)))))).
++....(((.(((..........)))...)))..((((.....))))..........
++.((((.(.(((((......)))))...).....(((.....))).....))))..
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++(((((((((((((......)))))).....).((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......)))))(((....))).((....)).....)))))).
++.............((((....))))(......((((.....))))......)...
++.....((((((((......))))))..))(..((((.....))))).........
++......(((........((((....))))...((((.....))))....)))...
++((((((.((..((((..((((....))))))))..)...........))))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((........((......)).(......((((.....)))))..)))))).
++(((((((((((....)).))............((((.....))))))..))))).
++(((((..(((.(((...((((....))))..........))).)))...))))).
++....(((.(((((......)))))...)))..((((.....))))..........
++.......((.((.((...)))).))(((....((((.....))))....)))...
++....((.(((((........)))))...))..((((.....))))..........
++(((((((.(((((......)))))...))...((((.....))))....))))).
++((((((.(((.((..((........(....)......))..)))))..)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++..........(((......))).(.(((....((((.....))))....))).).
++................................((((.....))))..........
++...........(((((............)))))(((.....)))...........
++((((...((((((......)))))).......((((.....)))).....)))).
++((((((............(((....)))....((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++(((((((((.........)))...........((((.....))))...)))))).
++((((((..((...((((....))))...))..((((.....))))...)))))).
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.(((((..(((((......))))).........(((.....)))....)))))..
++.....((((((((......))))))..))..........................
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..(((((......)))))........(.((.....)).)...)))))).
++(((((.((((((........)))))....................)...))))).
++(((((...((((........))))........((((.....))))....))))).
++(((....((((((......)))))).((....((((.....))))....))))).
++.(((((.(((.(((....(((....)))..(....)...))).)))..)))))..
++.((((((.((((........))))...)))..((((.....)))).....)))..
++(((((......((((((.........).)))))..((....))......))))).
++((((((.(...(((......(.............).....)))...).)))))).
++((((((.((((((......))))))(......(((.......))))..)))))).
++((((((.((((((......))))))....(..((((.....)))))..)))))).
++((((((.(((.(((.........................))).)))..)))))).
++.......((((((......))))))........(((.....)))...........
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.((((((.......)..((((....))))...((((.....))))...)))))..
++(((((((.(((((......)))))...)))..((((.....)))).....)))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((....(((((..((((....)))))))))..............)))))).
++((((((............(((....)))....((((.....))))...)))))).
++(((...((((((........))))).......((((.....))))).....))).
++........((((........)))).(((....((((.....))))....)))...
++.......(((((........)))))....(..((((.....))))).........
++.(((((.((.(((......))).)).......((((.....))))...)))))..
++(((((((((((((......)))))).......((((.....))))))..))))).
++((((((..((.((......)).)))).(....((((.....))))....))))).
++(((((..(((((........))))).......((((.....))))....))))).
++(((((..((((((......)))))).......(((.......)))....))))).
++......(((.........)))..(.((.....((((.....)))).....)).).
++....(((((((((......))))))..))).........................
++....(((((((((......))))))..)))..((((.....))))..........
++(((((((....((...........................))...)..)))))).
++((((((.(((((.((...))))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(...(..((......))........((((.....)))))).)))))).
++(((.((...(((........))).........((((.....))))...)).))).
++.((((.............))))...(((....((((.....))))....)))...
++........((.(((.........................))).))..........
++..(((..(((((........))))).......((((.....))))....)))...
++((((((.((((((......))))))....((...((.....)).))..)))))).
++((((((.(((.(((...((((....))))....(....)))).)))..)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((((........)))))........(((.....)))....)))))).
++((((((..((.(((.((........((....))....))))).))...)))))).
++.((((..((((..........)))).(.....((((.....))))..).))))..
++........(((((......))))).(((....((((.....))))....)))...
++(((((....(......................((((.....)))))...))))).
++(((((...(((((......)))))..(.....(((.......)))...)))))).
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++(((((..............((....)).....((((.....))))....))))).
++(((((............((((....))))...((((.....))))....))))).
++.(((((.((((((......))))))........((..........)).)))))..
++.(((((..(((((......)))))........((((.....))))...)))))..
++((..(((((((((......))))))..)))...(((.....))))).........
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((....((((((..(((....))))))))).((....)).....)))))).
++((((((..(((((......)))))....))..((((.....)))).....)))).
++((((((..(((((......)))))........((((.....))))...)))))).
++....(..(((((........))))).((....(((.......)))....)).)..
++.(((((.((((((......)))))).......((((.....))))...)))))..
++................................((((.....))))..........
++((((((.(...((..((((((....))))........)).))....).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(....(((.......((.(....).))...)))......).)))))).
++...........(........(........(..((((.....)))))......)).
++...((((((((((......))))))..)))).((((.....))))..........
++.(((((..((....))....(........)..((((.....))))...)))))..
++(((((........((((....))))........(((.....))).....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++((((((((((((........)))))..))...((((.....))))....))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++.............((((....)))).......((((.....))))..........
++.....((........(.((((....)))).).((((.....))))))........
++.(((((.((((((......)))))).......((((.....))))...)))))..
++(((((((((.........)))...........((((.....))))...)))))).
++((((((...........((((....))))...((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((.(..(.......)..((((....))))...((((.....)))).....).)).
++(((((((((.((........)).)).....).((((.....))))...)))))).
++.............((((....))))(((....((((.....))))....)))...
++...(((.((((((......))))))...)))......(.......).........
++((((((..........................................)))))).
++((((((.(((((........))))).....(..(((.....))))...)))))).
++((((((..(((((......)))))........(((.......)))...)))))).
++(((((((((.........)))...........................)))))).
++(((((.(((((((......)))))).......((((.....)))))...))))).
++.((.(...(((((......)))))........((((.....))))....).))..
++.................((((....))))...((((.....))))..........
++........(((((......)))))...............................
++(((((((.(((((......)))))...))...((((.....))))....))))).
++(((((......((((..((((....))))))))(((.....))).....))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((....((((....))))..))).((....)))))..)))))).
++.((((...(((((......)))))........((((.....))))....))))..
++.......(((...((........))...))).(((.......)))..........
++..(((((....(..((......))...)..)..(((.....)))....))))...
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((......((...((((....))))...((((.....)))))).)))))).
++(((((((((((((......))))))..)....((((.....))))...)))))).
++..(..................................................).
++.(((((..(((((......)))))........(((.......)))...)))))..
++.......((((((......))))))(((....((((.....))))....)))...
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))(((....))).((....)).....)))))).
++((((((.(((((........))))).......((((.....)))).)..))))).
++(((((.(((.........)))..(......).(((.......)))....))))).
++(((((..((((((......)))))).......(((.......)))....))))).
++....((..(((((......)))))))(.....((((.....)))).....)....
++.(((...((((((......))))))..(....((((.....))))....))))..
++...((((((.(((((..((((....))))))))).).....))))).........
++((((((.(.(.((((..((((....))))))))(((.....))).).))))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(......(((((((....))))........)).....).).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.................(((......)))..........................
++.((.....(((((......)))))..(.....((((.....))))...)..))..
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((((.((...))))))).......((((.....))))...)))))).
++((((((.(((.(((......((......)).........))).)))..)))))).
++((((((.((((((......))))))(......(((.......))))..)))))).
++((((((.((((((......))))))....(..((((.....)))))..)))))).
++...(((.......((((....))))....((.............))..)))....
++.................((......((....))...(.....)..))........
++.(((((.((((((......)))))).......((((.....))))...)))))..
++((((...(((((.(.....)))))).......((((.....)))).....)))).
++(((((...(((((......))))).........................))))).
++(((((...(((((......)))))........((((.....))))....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++....(...(((((......)))))..).....((((.....))))..........
++.......................................................
++.((((..(.....((((....)))).....).((((.....))))....))))..
++((((((.((((((......)))))).......(((.......)))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++(((((((..(((........))).........((((.....)))))..)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++(((.((..(((((......)))))........((((.....))))...)).))).
++..........(((......)))...(((....((((.....))))....)))...
++........(((((......)))))........((((.....))))..........
++((((((..((((........))))........((((.....))))...)))))).
++((((((.(..(....).((((....))))...((((.....)))).).)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((.(((.....((...(((....)))..)).))).)))..)))))).
++.((((...(((((......)))))........((((.....))))....))))..
++..........(((((..((((....))))))))).....................
++...((..((((((......))))))....)).((((.....))))..........
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++(((((..(((((........)))))(................)......))))).
++(((((..((((((......))))))....((..(((.....)))))...))))).
++(((((((((((((......))))))..))...((((.....))))....))))).
++(((((((((((((......))))))..)))...(((.....)))....)..))).
++.(((((..(((((......)))))........((((.....))))...)))))..
++........(((((......)))))...............................
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((...((((......))))..((.............))......)))))).
++((((...((((((......))))))..(....((((.....))))....))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))........((((.....))))...)))))).
++.........................((.....((((.....)))).....))...
++.(((((.((((((......)))))).......(((.......)))...)))))..
++.......((......))........(((....((((.....))))....)))...
++(((((((.((((........))))........((((.....)))))..)))))).
++((((((.(((((........))))).......(((.......)))...)))))).
++((((((..(((((......)))))........(((.......)))...)))))).
++((((((.(.........(..............((((.....)))))).)))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++........(((((......)))))........((((.....))))..........
++.(((((..(((....))).......(......((((.....)))))..)))))..
++........(((((......))))).....((..(((.....))))).........
++(((((..(((((........))))).......((.........))....))))).
++(((((((((((((......))))))..))...((((.....))))....))))).
++(((((((((((((......)))))).....))((((.....))))....))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((.((((.....((......))......)..))).))...)))))).
++...((((((((((......))))))..))))..((..........))........
++.(((((.((((((......)))))).......((((.....))))...)))))..
++((((((.....(((((..(((....))))).........)))......)))))).
++(((((((((((((......))))))..).((..(((.....)))))..)))))).
++(((((((((((((......))))))..)))...((((....))..))...)))).
++((((((.((.........))((......))..((((.....))))...)))))).
++((((((...........((((....))))...((((.....))))...)))))).
++.......((((((......))))))..............................
++....(((((.........))).)).(((....((((.....))))....)))...
++.(((((..(((((......)))))....)...((((.....))))....))))..
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((....(((((..((((....))))))))).((....)).....)))))).
++((((.((.(................).))...((((.....)))).....)))).
++(((((...(((....)))(((....))).(...........).......))))).
++.................((((....))))....(((.....)))...........
++..................((......))....((((.....))))..........
++(((((((...(..(((......))).)))...((((.....))))....))))).
++((((((.(((((........))))).....).((((.....))))....))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(((.(((...((.((......)))).......))).)))..)))))).
++.((((....(((((((..(((....)))))))))..((...))..)...))))..
++.............((((....))))(((....((((.....))))....)))...
++.......((.........))............((((.....))))..........
++((((((.((((((......)))))).......(((.(....))))...)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..((...((((....))))....(..(....)...).))...)))))).
++((((((.(((.((......)).))).......((((.....))))...)))))).
++((((((.((((((......))))))........(((.....)))....)))))).
++.(((((..((((........)))).(......((((.....)))))..)))))..
++...((...((((........)))).....)).((.((....))))..........
++.......((((((......))))))....((.((((.....))))....).)...
++(((((((((.........)))....(.......(((.....))).)..)))))).
++(((((((....(((......(.((........)))....)))...))..))))).
++(((((...((..(((((....))).......((...))...))))....))))).
++(((((((.(((((......)))))...)))..((((.....)))).....)))).
++(((((..((((((......))))))........(((.....))).....))))).
++.(((.(.(((((........))))).......((((.....))))...).)))..
++.................((((....))))...((((.....))))..........
++((((((..........................................)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(.(..((......(........)))((((.....))))).))))))).
++((((((.((.(((......))).)).(....)((((.....))))...)))))).
++.......((((((......))))))(((....((((.....))))....)))...
++.(((((.((.........))(........)..((((.....))))...)))))..
++.(((((((..(((((..((........))))))).......))).....))))..
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((.(((...(..((......))..)......))).)))..)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((.(((...((((....))))..........))).)))..)))))).
++.......((((((......)))))).((.....................))....
++.(((((.((((((......)))))).......((((.....))))...)))))..
++(((((((((((((......)))))).......((((.....))))))..))))).
++(((((..(((...((((....))))...))..(((.......))).)..))))).
++(((((...(((((......)))))........((((.....))))....))))).
++(.(((...(((((......)))))........((((.....))))....))).).
++(((((..(((((........))))).......((((.....))))....))))).
++.......((((((......))))))(((....((((.....))))....)))...
++...((((.((((........))))...)))).((((.....))))..........
++......((((............(..........)..............))))...
++((((((.((((((......))))))....((....).....)......)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((......(((..((((....)))))))((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))........((((.....))))...)))))).
++...(((.((((((......)))))).......((((.....))))...)))....
++.........................(((....(..((....)).)....)))...
++....(((((((((.(...)))))))..)))..((((.....))))..........
++((((((.(.((((((..((((....))))))))).(.....).)...))))))).
++((((((.((((((......)))))).......((.((....))))...)))))).
++((((((..(((((......)))))........(((.......)))...)))))).
++((((((.(.((((......))))......(...(((.....))).)).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++....(((.(((((......)))))...)))..((((.....))))..........
++.(.(.(.((((((......)))))).......((((.....))))).).).....
++(((((...((((........))))..(.....((((.....))))...)))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((((((((((......))))))..))...((.((....))))....))))).
++(((((((.(((((......)))))......))((((.....))))....))))).
++.(((((..(((((......)))))..(.....((((.....)))).).)))))..
++..(((.(.......)...)))....((.....((((.....)))).....))...
++..........((((((..(((....))))))))).....................
++((((....(((((......)))))..(.....((((.....))))...).)))).
++((((((...........((((....))))...((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((...((((......))))......(..((((.....)))))..)))))).
++(((((((((((((......)))))).....).((((.....))))...)))))).
++.(((((.((((..........)))).......((((.....))))...)))))..
++.(((((.((((((......)))))).......((.((....))))...)))))..
++((((((.....(((...((((....)))).)))(((.....)))....)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......))))).(....).((((.....))))...)))))).
++(((((((.(((((......)))))........((((.....)))))..)))))).
++((((((.((((((......))))))((....))...............)))))).
++.((((((((((((......))))))..))).))).....................
++.((((((((.........)))...........((((.....))))...)))))..
++.((((((((((((......))))))..)))).((((.....))))......))..
++(((((..((((((......)))))).......((((.....))))....))))).
++((((((..(((((......)))))...)....((((.....))))....))))).
++(..(((((((((........)))))..)))).((((.....))))........).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((.......((((....))))..............)))..)))))).
++.........................(((....((((.....))))....)))...
++.((((.(.......)...))))..........(((.......)))..........
++.(((((..(((((......)))))........((((.....))))...)))))..
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((.....((((.....(.((........))).)...))).....)))))).
++(((((((((((((.(...)))))))..).....((.......))....)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.((((((((((((......))))))..)))).)).....................
++..(.(((((((((......))))))..)))).((((.....))))..........
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))........((((.....))))...)))))).
++((((...((((((......)))))).....(.((((.....))))....))))).
++(((((((((((((......)))))).......((((.....))))))..))))).
++(((((...((.(((.(.((((....)))).)........))).))....))))).
++........(((((......))))).((.....((((.....)))).....))...
++........(((((......)))))........(((.......)))..........
++..((((.((((((......)))))).......((((.....))))...))))...
++(((((((((((((......))))))..))((....((....)).))...))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(.((((......)))).........((((.....)))).).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.(((((.((((.(......).)))).(....)((((.....))))...)))))..
++.............((((....))))(((....((((.....))))....)))...
++((((((.((((((......))))))........(((.....)))....)))))).
++((((((.((((((......)))))).(.....((((.....))))..))))))).
++((((((.((..(((..((..(........)..)).....)))..))..)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.(((((..(((((......)))))........((((.....))))...)))))..
++.((((..((((((......)))))).......((((.....))))....))))..
++....(((((((((......))))))..)))..((((.....))))..........
++((((((.....(((......(.((.(....).)))....)))......)))))).
++((((((..(((((......))))..)......((((.....))))..).))))).
++((((((((((((........)))))..)))..((((.....)))).....)))).
++(((((...((((........))))..(.....((((.....))))..).))))).
++(((((..((((((......))))))(......((((.....)))))...))))).
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.((((((.((((........))))...)))..((((.....)))).....)))..
++.......((((....((....))...)).).)((((.....))))..........
++((((((.((((((......)))))).(.....((((.....))))..))))))).
++((((((..((((.((...)))))).....((.............))..)))))).
++((((((..........................................)))))).
++((((.............((((....))))...((((.....)))).....)))).
++((((((..(((((......)))))........((((.....))))...)))))).
++.......((((((......)))))).......((((.....))))..........
++.(((((..((....(((....)))....))..((((.....))))...)))))..
++((((((........(((....)))........((((.....))))...)))))).
++((((((.((((((......))))).....((..(((.....)))))).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......(..((....)).)...)))))).
++((((((.(((.(((.((((((....))))........)).))))))..)))))).
++....((((((((..(...).)))))..)))..((((.....))))..........
++.........((....)).........((....((((.....))))....))....
++.(((((..((((........)))).....(..((((.....)))))..)))))..
++((((((((.................................))).....))))).
++(((((...(((((......)))))........((((.....))))....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++((....(((.........(((....)))....((((.....))))....))))).
++(((((((((((((......))))))..))...((((.....))))....))))).
++.(....)((((((......))))))(((....((((.....))))....)))...
++....(((((.(((......))).))..)))..((((.....))))..........
++.(((((.((((((......)))))).......((((.....))))...)))))..
++(((((((((.........)))...........((((.....))))...)))))).
++((((((..((........(((....)))))..((((.....))))...)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++.((((((((((((......))))))..))...(((.......)))....))))..
++.........(....(((....)))........((((.....)))).....)....
++(.......(..((.....(.(....).)...))..).....).............
++(((((((.(((..........)))........((.........)))..)))))).
++((((((.((((((......))))))(....).((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(...(((...((((....))))...........)))....))))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++.(((((((((((........)))).................))))).....))..
++.(.....((((((......))))))....)..(((.......)))..........
++..(((((((((((......)))))).....))((((.....))))....)))...
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((..((((((......))))))........(((.....))).....))))).
++(((((.((((((.(.....))))))..)....((((.....))))....))))).
++(((((.(.(((((......)))))......).((((.....))))....))))).
++((((((.((((((((..((((....))))))))).........)))..)))))).
++.((((..((((((......)))))).......((((.....))))....))))..
++.((((..(((....))).))))...(((....((((.....))))....)))...
++((((((...(.(((......((......)).........)))).....)))))).
++(((((((((((((......))))))..)....((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..........................((((.....))))...)))))).
++((((((...........((((....))))...((((.....))))...)))))).
++.((.(((((((((......))))))..)))..)).....................
++.(((((.((((((......))))))(......((((.....)))))..)))))..
++..(((.............)))...........((((.....))))..........
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))........((((.....))))...)))))).
++((((((.(......(..........)......)(((.....)))....)))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++(((((((((((((......)))))).......((((.....))))))..))))).
++................................(................).....
++.(((((........(..............)..((((.....))))...)))))..
++.......((((((......)))))).......((((.....))))..........
++(((((..((((((......)))))).......((((.....))))....))))).
++((((((.((((((......))))))...)...((((.....))))....))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.((((((......)))))........((((.....)))).).)))))).
++....((((((((........)))))..)))..((((.....))))..........
++.(((...(((((........)))))......))).....................
++.((.((.(((.((((..((((....)))).....)....))).)))..)).))..
++((((((.......(((......))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......................)))))).
++((((((.((.((........)).)).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.......((((((......)))))).......((((.....))))..........
++.......((((((......))))))........(((.....)))...........
++.(((((.(((((........))))).......((((.....))))...)))))..
++((((....(((((......)))))..(.....((((.....))))..)..)))).
++((((((...........((((....))))...((((.....))))...)))))).
++((((((.(((((........))))).......((((.....))))..).))))).
++(((((..((((((......)))))........(((.......))).)..))))).
++(((((...(((((......)))))........((((.....))))....))))).
++........(((((......))))).(((.....(((.....))).....)))...
++....((((((((........)))))..)))..((((.....))))..........
++(((((............((((....))))...((((.....))))....))))).
++((((((.((((((......))))))..(.......)............)))))).
++((((((..((((........))))........((((.....))))...)))))).
++(((((((.(((((......)))))........((((.....)))))..)))))).
++((((((.((((((......))))))....((.............))..)))))).
++.(((((.((((((......)))))).......((((.....))))...)))))..
++....(((((((((......))))))..)))(.....)..................
++.......((((((......))))))................(.......).....
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(......(((....)))........((((.....)))).).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((.(...))))))).......((((.....))))...)))))).
++((((((.(((.((((.(.(.((......))..)).)...))).)))..)))))).
++.((((...((((........))))........((((.....))))....))))..
++...((((((((((......))))))..))))..(((.....)))...........
++.((((.............))))..........((((.....))))..........
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++((((((((..(((((..((((....))))))))).......))).....))))).
++(((((...(((((......)))))........(..((....)).)....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++.......((((((......))))))(((.(..((((.....)))))...)))...
++.(((((..(((((......)))))))......((((.....)))).....)))..
++.............((((....))))(((....((((.....))))....)))...
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))..(....).(((.....)))....)))))).
++((((...((((((......))))))..(....((((.....))))....))))).
++((((((.(((((........))))).......(((.......)))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++.....(.((((((......)))))).......((((.....))))..).......
++.(((((........(..((((....)))))...((.......))....)))))..
++....((((((((........)))))..))).........................
++((((((((..((((((...((....)).)))))).......)).....)))))).
++((((((.((((((......))))))....(..((((.....)))))..)))))).
++((((((..((((..(...).)))).....(..(((.......))))..)))))).
++((((((.((((((......)))))........((((.....)))).).)))))).
++((((((.((((((......))))))........(((.....)))....)))))).
++.......((((((......)))))).......((((.....))))..........
++.(((((..(((((......)))))........(((.......)))...)))))..
++(((((((.((.((((...(.(........)..)...)..))).))))..))))).
++(((((..........(.((((....)))).)..................))))).
++(((((..(((((.((...))))))).......((((.....))))....))))).
++(((((..((((((......))))))(((.........)..)).......))))).
++(((((......(.(((......)))..)....((((.....))))....))))).
++(......(((((........))))).......)(((.....)))...........
++.......((((((......))))))(((....((((.....))))....)))...
++.(((((......(.(((....))))(....)..(((.....)))....)))))..
++((((((.....(((.((((((....))))........)))))......)))))).
++(((((((((((((......))))))..)....((((.....))))...)))))).
++(((((((((((((......))))))..)))..(((.......))).....)))).
++(((((((((.........)))...........((((.....))))...)))))).
++((((((..((.(..(((....)))...)))...(((.....)))....)))))).
++....(((((.(((((..............))))).).....))))..........
++...(....).................((....((((.....))))....))....
++.((((((((((((......))))))..)))).)).....................
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((((........))))..(.....((((.....))))..))))))).
++(((((((.((((........))))........((((.....)))))..)))))).
++(((((...(((((......))))).)......(((.......))).....)))).
++.(((((.((((((......)))))).(.....((((.....))))..))))))..
++.......((((((......))))))(((....((((.....))))....)))...
++.....((......................................))........
++(((((...(((((......)))))........((((.....))))....))))).
++(((((..(((((........)))))(......((.........)))...))))).
++(((((..((((((......))))))(....).((((.....))))....))))).
++(((((((.(((((......)))))...))...((((.....))))....))))).
++((((((.(((.(((.........................))).)))..)))))).
++.(((((..........)((.............(((.......)))))..))))..
++...((((((((((......)))))).......((((.....))))))..))....
++.......((((((......))))))....(..((((.....))))......)...
++((((((.(((((........)))))........(((.....)))....)))))).
++((((((.((((((......)))))).(...).((((.....))))...)))))).
++((((((...(.......((((....))))...((((.....)))))..)))))).
++((((((..............(....)......((((.....))))...)))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++.(((((.((((((.(...))))))).......((((.....))))...)))))..
++.................((((....))))...((((.....))))..........
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((....(((......)))..........((((.....))))...)))))).
++((((((..............(........)..((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++(((((((((((((......))))))..)))...(((.....)))......)))).
++........(((((......))))).((.....((((.....)))).....))...
++.(((((..(........((((....)))))..((((.....))))...)))))..
++.(((((.((((((......)))))).......(((.......)))...)))))..
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((((((((((......))))))..))...((((.....))))....))))).
++((((((..(((((......)))))(((....))).((....)).....)))))).
++((((((.(.........((...........))...............))))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++...((((.(((((......)))))...)))).(((.......)))..........
++.(((((..(((((......)))))........(((.......)))...)))))..
++.((((..(((.(((...........(....)........))).))..).))))..
++((((((.((((((......))))))....(..((((.....)))))..)))))).
++((((((.(((.(((.........................))).)))..)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++.................((...........))............((......)).
++....(((((((((......))))))..)))..((((.....))))..........
++......((((........(((....)))....((((.....))))...))))...
++((((((.....(.....((((....))))...((((.....)))))..)))))).
++(((((((((((((......))))))..)....(((.......)))...)))))).
++((((((.((((((......)))))).(..((.............)).))))))).
++((((((..(((((......)))))........((((.....)))))...))))).
++(((((...(((((.(...))))))........(((.......)))....))))).
++.......((((((......)))))).......((((.....))))..........
++........(((((......))))).(((.(..((((.....)))))...)))...
++....((((((((........)))))..)))..((((.....))))..........
++((((((((((((........))))).....))((((.....))))....))))).
++((((((..(((((......)))))........(((.......)))...)))))).
++((((((.....((((..((((....))))))))..((....)).....)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++.......(((((..(...).))))).....(.((((.....))))....).....
++....((((((((........)))))..)))...((..........))........
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.((((((.(...))))))........((((.....)))).).)))))).
++((((((.((((((......))))))(....).(...)...........)))))).
++((((((..((((........))))........((((.....))))...)))))).
++((((((.((((((......))))).....(..((((.....)))))).)))))).
++.((((..(((.(((.........(..(....))......))).)))...))))..
++........(((((......))))).(((....((((.....))))....)))...
++.(.....((((((......))))))....)......(....).............
++((((((.(((((........))))).(.....((((.....)))).).)))))).
++(((((((((((((.(...))))))).......((((.....))))))..))))).
++(((((.......((....(((....)))....((((.....))))..))))))).
++(((((..((((((......)))))).(....)((((.....))))....))))).
++(((((..(((((........))))).......((((.....))))....))))).
++.(((....(((((......)))))........((((.....)))).....)))..
++.((((((((((((......))))))..)))..((((.....)))).....)))..
++.........................(((....((((.....))))....)))...
++((((....((.(((...((((....))))..........))).)).....)))).
++((((((...........((((....))))...((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++.............................((.((((.....)))).......)).
++.(((((..((...((((....))))...))..((((.....))))...)))))..
++.(((((.((((((......))))))....(..((((.....)))))..)))))..
++((((((....((((((..(((....))))))))).((....)).....)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++(((((((.(((((......)))))........((((.....)))))..)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++.......((((((......))))))(((....((((.....))))....)))...
++.......((((((......)))))).......((((.....))))..........
++.(..(((.......((....))........))((((.....))))....)..)..
++(((((..((((((......))).....................)))...))))).
++(((((...(((((.(...))))))........((((.....))))....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((..(((((........))))).......((((.....))))....))))).
++(((((((((((((......))))))..))...((((.....))))....))))).
++..(....((((((.(...))))))).....).....(....).............
++........(((((......)))))........((((.....))))..........
++((((((..((.(((.(.((((....)))).)........))).))...)))))).
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++((((((.((((((......))))))........(((.....)))....)))))).
++((((((.....(((((.((((....)))).).....)..)))......)))))).
++(((((((((((((......))))))..)....((((.....))))...)))))).
++.......((((((......))))))((.....((((.....)))).....))...
++.......((((((......)))))).......((((.....))))..........
++..((.......(((....(.............)......)))........))...
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((...((((((......))))))..(....((((.....))))....))))).
++((((((.((((((......)))))).......(((.(....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++.(((.((((((((......))))))..))..))).....................
++.......((((((......))))))((.......................))...
++....(((((((((......))))))..)))..((((.....))))..........
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((((.(((((......)))))...))...((((.....))))....))))).
++(((((............................................))))).
++.........((((......))))(.(((....((((.....))))....))).).
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.((((...(......)..))))....((....((((.....))))....))....
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((.(((.........(......)........))).)))..)))))).
++((((((.((((((......))))))....(..(((.......))))..)))))).
++((((((.((((((......))))))....(..((((.....)))))..)))))).
++.(((((.(((((........))))).......((.((....))))...)))))..
++.((((..(((((........))))).......((((.....))))....))))..
++....(((((((((......))))))..)))..((((.....))))..........
++((((((......((...((((....))))..........)).......)))))).
++((((((((((((........)))))..)....((((.....))))...)))))).
++(((((((.(((((......)))))...)))..((((.....)))).....)))).
++(((((((((.........))).((........))((.....)).....)))))).
++((((((.(((.((((..((((....)))).....)....))).))))..))))).
++((.....))((((......)))).........((((.....))))..........
++.(((((.((((((.(...))))))).......((((.....))))...)))))..
++(((((..((((..........))))((....((...))...))......))))).
++(((((((.((.((......))...)).))...((((.....))))....))))).
++(((((((((((((......)))))).....))((((.....))))....))))).
++(((((((.(((((......)))))........((((.....)))))..)))))).
++((((...((((((......)))))).......((((.....)))).....)))).
++....(((((((((......))))))..)))..((((.....))))..........
++(...(((.(((((......)))))...)))..((((.....))))......)...
++.((((((((((((......)))))).......((((.....))))))..))))..
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.((((((......)))))........(.((.....)).).).)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((......((((........)))).(((.....(((.....))).....))))).
++((((((.(((.((....((((....)))).(....)....)).)))..)))))).
++....(((((.(......)))).)).(((....((((.....))))....)))...
++...((((.((((........))))...)))).((((.....))))..........
++.(((((.((((..........)))).......((((.....))))...)))))..
++((((((.((((((......))))))....((..(((.....)))))..)))))).
++((((((.(((((........)))))(...................)..)))))).
++(((((((..(.(........)...).......((((.....))))))..))))).
++(((((......(((.........(......)........))).......))))).
++..(((...((....))..)))..(.(((....(((.......)))....))).).
++.......((((((......)))))).......((((.....))))..........
++....(((((((((.(...)))))))..))).........................
++(((((...((..................))..((((.....))))....))))).
++((((((...((((......)))).........((((.....))))...)))))).
++(((((((((((((......)))))).....).((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......))))))...))..((((.....)))).....)))).
++.((((..((.....(((....))).....)).((((.....))))....))))..
++..(.....(((((......)))))...)....((((.....))))..........
++..((((.....((..(....(.((........)))...).))......))))...
++((((((((((((........))))).......(((.......))))..)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((((......))))).(......)(((.....)))....)))))).
++((((((.(((((........))))........((((.....)))).).)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++.(((((.((((((......)))))).......(((.(....))))...)))))..
++........(((((......))))).(((....((((.....))))....)))...
++((((((.((((((......)))))).......((((.....))))...)))))).
++(((((((((((((......)))))).......((((.....))))))..))))).
++(((((..(((.(.((..((.((......)))).....)..)).)))...))))).
++(((((...((((........)))).....(..((((.....)))))...))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++....(((((((((......))))))..))).........................
++.((((((.(((((......)))))...)))..((((.....)))).....)))..
++...(((((((((........)))))..)))).((((.....))))..........
++((((((.....(((.((((((....))))........)).))).....)))))).
++((((((((((((........)))))..)....(....)..........)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((....)).(.((....)).)(..((((.....)))))..)))))).
++((((((...........((((....))))...(((.......)))...)))))).
++....(((((((((......))))))..))).........................
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.......(((((........))))).......((((.....))))..........
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((..((............))........((((.....))))...)))))).
++((((((....((((((..(((....))))))))).((....)).....)))))).
++((((((.((((((.(...))))))).......(((.......)))...)))))).
++.......................(.(((....((((.....))))....))).).
++....(((((((((......))))))..)))(.((((.....))))....).....
++.(((((.(.(..(((...))).).........((((.....)))).).)))))..
++(((((..(.(((........)))..........((((....))..)).)))))).
++(((((...(((((......)))))........((((.....))))....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((..((((((......))))))..(.......).............))))).
++(((((((((((((......))))))..))...((((.....))))....))))).
++(..((((((((((......))))))..)))).)....(..........)......
++....(((((.((((((..(((....))))))))).).....))))..........
++.((.((.(((.(((....(.(........)..)......))).)))..)).))..
++((((((.((((..........)))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..((.(((.........................))).))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++.......((.(((......))).))(((....((((.....))))....)))...
++...((((((((((......))))))..)))).((((.....))))..........
++(((((((((((((......))))))..)))).((((.....))))......))).
++((((.((.((((........))))........((((.....))))))...)))).
++((((((...........((((....))))...((((.....))))...)))))).
++((((((.((((((......))))))(....).((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++.(((((((((((........)))))..))...((((.....))))....))))..
++....(((((((((......))))))..)))...(((.....)))...........
++.((((.............))))..........(.((.....)).)..........
++(.((((.((((((......)))))).......((((.....))))...)))).).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((((..((((......))))....))...((((.....))))....))))).
++(((((((((((((......)))))).....))((((.....))))....))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.(((((.(((((........))))).......((((.....))))...)))))..
++.((((((.(((((......)))))...)))).)).....................
++....((..(((((.(...))))))))((....((((.....))))....))....
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.(((.(((...((((....))))..........))).)))..)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......(((.......)))...)))))).
++.......................(...(....((((.....))))....)...).
++.((((...(((((......)))))........((((.....))))....))))..
++.......((((((......))))))((.....((((.....)))).....))...
++((((((..((.((((..((((....))))).........))).))...)))))).
++((((((.((((((......))))))...))..((((.....)))).....)))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.....(((((..(((....))))))))...............)))))).
++(((((((.(((((......)))))(((....)))...........))..))))).
++...((((((((((......))))))..)))).((((.....))))..........
++.(((((.(((((........))))).......((((.....))))...)))))..
++.............(((.((.............((((.....)))))).)))....
++(((((.(.((((........))))...)....(((.......)))....))))).
++(((((...((...((((....))))...))..((((.....))))....))))).
++(((((((((.........))).))......(.((((.....))))....))))).
++((((((.((((((......)))))).(.....((((.....))))..))))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++..............(...).............((((.....))))..........
++.(((((.(.........((((....))))...((((.....)))).).)))))..
++((((((..((((........))))........((((.....))))...)))))).
++((((((.((((((......)))))........((((.....))))..))))))).
++((((((.((.((........)).)).......((((.....))))...)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++((((((.((((((......))))).((...(.....)...))....).)))))).
++...((((((((((......))))))..))))....((....))............
++.......((((((......)))))).(.....((((.....))))......)...
++.(((((.(((((........)))))((....))((.......))....)))))..
++((((((.((((((......)))))).......((((.....))))...)))))).
++(((((((((((((......))))))..)))..((((.....)))).....)))).
++(((((((((((((......)))))).......(((.......)))))..))))).
++(((((..((((((......))))).(....).((((.....)))))...))))).
++(((((...(((((......)))))........((((.....))))....))))).
++....(((((.((((((...((....)).)))))).).....))))..........
++(...(((..(((........)))....)))).((((.....))))..........
++..(.(((((((((......))))))..))))....((....))..(......)..
++((((((...........((((....))))...................)))))).
++((((((...........((((....))))...((((.....))))...)))))).
++((((((((((((........)))))..)))..((((.....)))).....)))).
++((((((....((........)).......(..((((.....)))))..)))))).
++...((.(..((((......))))....(....((((.....))))....).))).
++.........................(((....((((.....))))....)))...
++.....((((((((......))))))..))...((((.....))))..........
++((((((.......(...((((....))))..)((((.....))))...)))))).
++((((((.(((((........))))).(.....((((.....)))).).)))))).
++((((((..(((((......)))))........((((.....))))...)))))).
++(((((((((((((......)))))).......((((.....)))))..)))))).
++((((...((((((......)))))).(.....((((.....))))...).)))).
++.(((((.((((((......)))))).......((((.....))))...)))))..
++....(((((((((......))))))..)))..(((.......)))..........
++....(((((((((......))))))..))).....(...............)...
++((((((..((((........))))........((((.....))))...)))))).
++(((((.((..(......((...........)).....)..)).......))))).
++(((((...(((((......)))))..(.....(((.......)))..).))))).
++(((((..((((((......))))))(....).((((.....))))....))))).
++(((((..((((((......))))))........(((.....))).....))))).
++.((((((((((((......))))))..)))..((((.....)))).....)))..
++........(((((......)))))..(.....((((.....))))...)......
++((((((.(.(((........)))..((..............)))....)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((.((....))))...)))))).
++((((((.....(.....((((....))))....(((.....))).)..)))))).
++(((((((((((((......))))))..)....((((.....))))...)))))).
++.........(((........)))..(((....((((.....))))....)))...
++.(((((.((((((......)))))).......((((.....))))...)))))..
++.((((..(((((........)))))........(((.....))).....))))..
++((((((.((((((......))))))....((..(((.....)))))..)))))).
++((((((...((((......))))......(..((((.....)))))..)))))).
++((((((.........(.(((......))).).((((.....))))...)))))).
++((((((.((((((......)))))).(....)((((.....))))...)))))).
++(((((((((((..........))))..)))..((((.....)))).....)))).
++.......((((((......)))))).......((((.....))))..........
++.(((((.((((((......)))))((......))............).)))))..
++.(((((.((((((......)))))).......((((.....))))...)))))..
++(((((.(((.........)))...........((((.....))))....))))).
++(((((..(((((........))))).......((((.....))))....))))).
++(((((..((((((......)))))).......((((.....))))....))))).
++(((((((((((((......))))))..))((....((....)).))...))))).
++((((((((((((........)))))..)...)((((.....))))....))))).
++....(((.(((((......)))))...)))..((((.....))))..........
++......(((...((((.((((....))))..((...)).....))))..)))...
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.(((((........))))).......((((.....))))...)))))).
++((((((.(((.(((.(.((((....)))).)........))).)))..)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.........((((......)))).........((((.....))))..........
++.......(((((........)))))(((....((((.....))))....)))...
++.......(((((........))))).......((((.....))))..........
++(((((((((((((......))))))..)))).((.(.....).))......))).
++(((((((((((((......))))))..)....((((.....))))...)))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++((((((..(((....)))(((....)))....((((.....))))...)))))).
++((((((...........((((....))))...((((.....))))...)))))).
++...((((.(((((......)))))...)))).((((.....))))..........
++....((((((((........)))))..))).........................
++(((((...(((((......))))).....(..((((.....)))))...))))).
++(((((..((((((......))))))(....).((((.....))))....))))).
++(((((.(((((((......))))))..)....((((.....))))....))))).
++(((((............((((....))))...((((.....))))....))))).
++((((((.((((((......)))))).......((((.....))))...)))))).
++.(((((.((((((.....
\ No newline at end of file
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/score_prediction b/./score_prediction
index 334ec01..a968b8b 100755
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/score_prediction and b/./score_prediction differ
diff --git a/./test.seq b/./test.seq
new file mode 100644
index 0000000..407c74a
--- /dev/null
+++ b/./test.seq
@@ -0,0 +1 @@
+GGAAACGCACUCAACGCAAGCUUCUGCUAGCGAAAGAGCUUUGACGUGUACGUCUGCUCACGAGAGUGCGAAAGAAACAACAACAACAAC
diff --git a/./tmp b/./tmp
new file mode 100644
index 0000000..c598d3a
--- /dev/null
+++ b/./tmp
@@ -0,0 +1,708 @@
+base_pair_AA
+base_pair_AC
+base_pair_AG
+base_pair_AU
+base_pair_CC
+base_pair_CG
+base_pair_CU
+base_pair_GG
+base_pair_GU
+base_pair_UU
+terminal_mismatch_AAAA
+terminal_mismatch_AAAC
+terminal_mismatch_AAAG
+terminal_mismatch_AAAU
+terminal_mismatch_AACA
+terminal_mismatch_AACC
+terminal_mismatch_AACG
+terminal_mismatch_AACU
+terminal_mismatch_AAGA
+terminal_mismatch_AAGC
+terminal_mismatch_AAGG
+terminal_mismatch_AAGU
+terminal_mismatch_AAUA
+terminal_mismatch_AAUC
+terminal_mismatch_AAUG
+terminal_mismatch_AAUU
+terminal_mismatch_ACAA
+terminal_mismatch_ACAC
+terminal_mismatch_ACAG
+terminal_mismatch_ACAU
+terminal_mismatch_ACCA
+terminal_mismatch_ACCC
+terminal_mismatch_ACCG
+terminal_mismatch_ACCU
+terminal_mismatch_ACGA
+terminal_mismatch_ACGC
+terminal_mismatch_ACGG
+terminal_mismatch_ACGU
+terminal_mismatch_ACUA
+terminal_mismatch_ACUC
+terminal_mismatch_ACUG
+terminal_mismatch_ACUU
+terminal_mismatch_AGAA
+terminal_mismatch_AGAC
+terminal_mismatch_AGAG
+terminal_mismatch_AGAU
+terminal_mismatch_AGCA
+terminal_mismatch_AGCC
+terminal_mismatch_AGCG
+terminal_mismatch_AGCU
+terminal_mismatch_AGGA
+terminal_mismatch_AGGC
+terminal_mismatch_AGGG
+terminal_mismatch_AGGU
+terminal_mismatch_AGUA
+terminal_mismatch_AGUC
+terminal_mismatch_AGUG
+terminal_mismatch_AGUU
+terminal_mismatch_AUAA
+terminal_mismatch_AUAC
+terminal_mismatch_AUAG
+terminal_mismatch_AUAU
+terminal_mismatch_AUCA
+terminal_mismatch_AUCC
+terminal_mismatch_AUCG
+terminal_mismatch_AUCU
+terminal_mismatch_AUGA
+terminal_mismatch_AUGC
+terminal_mismatch_AUGG
+terminal_mismatch_AUGU
+terminal_mismatch_AUUA
+terminal_mismatch_AUUC
+terminal_mismatch_AUUG
+terminal_mismatch_AUUU
+terminal_mismatch_CAAA
+terminal_mismatch_CAAC
+terminal_mismatch_CAAG
+terminal_mismatch_CAAU
+terminal_mismatch_CACA
+terminal_mismatch_CACC
+terminal_mismatch_CACG
+terminal_mismatch_CACU
+terminal_mismatch_CAGA
+terminal_mismatch_CAGC
+terminal_mismatch_CAGG
+terminal_mismatch_CAGU
+terminal_mismatch_CAUA
+terminal_mismatch_CAUC
+terminal_mismatch_CAUG
+terminal_mismatch_CAUU
+terminal_mismatch_CCAA
+terminal_mismatch_CCAC
+terminal_mismatch_CCAG
+terminal_mismatch_CCAU
+terminal_mismatch_CCCA
+terminal_mismatch_CCCC
+terminal_mismatch_CCCG
+terminal_mismatch_CCCU
+terminal_mismatch_CCGA
+terminal_mismatch_CCGC
+terminal_mismatch_CCGG
+terminal_mismatch_CCGU
+terminal_mismatch_CCUA
+terminal_mismatch_CCUC
+terminal_mismatch_CCUG
+terminal_mismatch_CCUU
+terminal_mismatch_CGAA
+terminal_mismatch_CGAC
+terminal_mismatch_CGAG
+terminal_mismatch_CGAU
+terminal_mismatch_CGCA
+terminal_mismatch_CGCC
+terminal_mismatch_CGCG
+terminal_mismatch_CGCU
+terminal_mismatch_CGGA
+terminal_mismatch_CGGC
+terminal_mismatch_CGGG
+terminal_mismatch_CGGU
+terminal_mismatch_CGUA
+terminal_mismatch_CGUC
+terminal_mismatch_CGUG
+terminal_mismatch_CGUU
+terminal_mismatch_CUAA
+terminal_mismatch_CUAC
+terminal_mismatch_CUAG
+terminal_mismatch_CUAU
+terminal_mismatch_CUCA
+terminal_mismatch_CUCC
+terminal_mismatch_CUCG
+terminal_mismatch_CUCU
+terminal_mismatch_CUGA
+terminal_mismatch_CUGC
+terminal_mismatch_CUGG
+terminal_mismatch_CUGU
+terminal_mismatch_CUUA
+terminal_mismatch_CUUC
+terminal_mismatch_CUUG
+terminal_mismatch_CUUU
+terminal_mismatch_GAAA
+terminal_mismatch_GAAC
+terminal_mismatch_GAAG
+terminal_mismatch_GAAU
+terminal_mismatch_GACA
+terminal_mismatch_GACC
+terminal_mismatch_GACG
+terminal_mismatch_GACU
+terminal_mismatch_GAGA
+terminal_mismatch_GAGC
+terminal_mismatch_GAGG
+terminal_mismatch_GAGU
+terminal_mismatch_GAUA
+terminal_mismatch_GAUC
+terminal_mismatch_GAUG
+terminal_mismatch_GAUU
+terminal_mismatch_GCAA
+terminal_mismatch_GCAC
+terminal_mismatch_GCAG
+terminal_mismatch_GCAU
+terminal_mismatch_GCCA
+terminal_mismatch_GCCC
+terminal_mismatch_GCCG
+terminal_mismatch_GCCU
+terminal_mismatch_GCGA
+terminal_mismatch_GCGC
+terminal_mismatch_GCGG
+terminal_mismatch_GCGU
+terminal_mismatch_GCUA
+terminal_mismatch_GCUC
+terminal_mismatch_GCUG
+terminal_mismatch_GCUU
+terminal_mismatch_GGAA
+terminal_mismatch_GGAC
+terminal_mismatch_GGAG
+terminal_mismatch_GGAU
+terminal_mismatch_GGCA
+terminal_mismatch_GGCC
+terminal_mismatch_GGCG
+terminal_mismatch_GGCU
+terminal_mismatch_GGGA
+terminal_mismatch_GGGC
+terminal_mismatch_GGGG
+terminal_mismatch_GGGU
+terminal_mismatch_GGUA
+terminal_mismatch_GGUC
+terminal_mismatch_GGUG
+terminal_mismatch_GGUU
+terminal_mismatch_GUAA
+terminal_mismatch_GUAC
+terminal_mismatch_GUAG
+terminal_mismatch_GUAU
+terminal_mismatch_GUCA
+terminal_mismatch_GUCC
+terminal_mismatch_GUCG
+terminal_mismatch_GUCU
+terminal_mismatch_GUGA
+terminal_mismatch_GUGC
+terminal_mismatch_GUGG
+terminal_mismatch_GUGU
+terminal_mismatch_GUUA
+terminal_mismatch_GUUC
+terminal_mismatch_GUUG
+terminal_mismatch_GUUU
+terminal_mismatch_UAAA
+terminal_mismatch_UAAC
+terminal_mismatch_UAAG
+terminal_mismatch_UAAU
+terminal_mismatch_UACA
+terminal_mismatch_UACC
+terminal_mismatch_UACG
+terminal_mismatch_UACU
+terminal_mismatch_UAGA
+terminal_mismatch_UAGC
+terminal_mismatch_UAGG
+terminal_mismatch_UAGU
+terminal_mismatch_UAUA
+terminal_mismatch_UAUC
+terminal_mismatch_UAUG
+terminal_mismatch_UAUU
+terminal_mismatch_UCAA
+terminal_mismatch_UCAC
+terminal_mismatch_UCAG
+terminal_mismatch_UCAU
+terminal_mismatch_UCCA
+terminal_mismatch_UCCC
+terminal_mismatch_UCCG
+terminal_mismatch_UCCU
+terminal_mismatch_UCGA
+terminal_mismatch_UCGC
+terminal_mismatch_UCGG
+terminal_mismatch_UCGU
+terminal_mismatch_UCUA
+terminal_mismatch_UCUC
+terminal_mismatch_UCUG
+terminal_mismatch_UCUU
+terminal_mismatch_UGAA
+terminal_mismatch_UGAC
+terminal_mismatch_UGAG
+terminal_mismatch_UGAU
+terminal_mismatch_UGCA
+terminal_mismatch_UGCC
+terminal_mismatch_UGCG
+terminal_mismatch_UGCU
+terminal_mismatch_UGGA
+terminal_mismatch_UGGC
+terminal_mismatch_UGGG
+terminal_mismatch_UGGU
+terminal_mismatch_UGUA
+terminal_mismatch_UGUC
+terminal_mismatch_UGUG
+terminal_mismatch_UGUU
+terminal_mismatch_UUAA
+terminal_mismatch_UUAC
+terminal_mismatch_UUAG
+terminal_mismatch_UUAU
+terminal_mismatch_UUCA
+terminal_mismatch_UUCC
+terminal_mismatch_UUCG
+terminal_mismatch_UUCU
+terminal_mismatch_UUGA
+terminal_mismatch_UUGC
+terminal_mismatch_UUGG
+terminal_mismatch_UUGU
+terminal_mismatch_UUUA
+terminal_mismatch_UUUC
+terminal_mismatch_UUUG
+terminal_mismatch_UUUU
+hairpin_length_at_least_0
+hairpin_length_at_least_1
+hairpin_length_at_least_2
+hairpin_length_at_least_3
+hairpin_length_at_least_4
+hairpin_length_at_least_5
+hairpin_length_at_least_6
+hairpin_length_at_least_7
+hairpin_length_at_least_8
+hairpin_length_at_least_9
+hairpin_length_at_least_10
+hairpin_length_at_least_11
+hairpin_length_at_least_12
+hairpin_length_at_least_13
+hairpin_length_at_least_14
+hairpin_length_at_least_15
+hairpin_length_at_least_16
+hairpin_length_at_least_17
+hairpin_length_at_least_18
+hairpin_length_at_least_19
+hairpin_length_at_least_20
+hairpin_length_at_least_21
+hairpin_length_at_least_22
+hairpin_length_at_least_23
+hairpin_length_at_least_24
+hairpin_length_at_least_25
+hairpin_length_at_least_26
+hairpin_length_at_least_27
+hairpin_length_at_least_28
+hairpin_length_at_least_29
+hairpin_length_at_least_30
+internal_explicit_1_1
+internal_explicit_1_2
+internal_explicit_1_3
+internal_explicit_1_4
+internal_explicit_2_2
+internal_explicit_2_3
+internal_explicit_2_4
+internal_explicit_3_3
+internal_explicit_3_4
+internal_explicit_4_4
+bulge_length_at_least_1
+bulge_length_at_least_2
+bulge_length_at_least_3
+bulge_length_at_least_4
+bulge_length_at_least_5
+bulge_length_at_least_6
+bulge_length_at_least_7
+bulge_length_at_least_8
+bulge_length_at_least_9
+bulge_length_at_least_10
+bulge_length_at_least_11
+bulge_length_at_least_12
+bulge_length_at_least_13
+bulge_length_at_least_14
+bulge_length_at_least_15
+bulge_length_at_least_16
+bulge_length_at_least_17
+bulge_length_at_least_18
+bulge_length_at_least_19
+bulge_length_at_least_20
+bulge_length_at_least_21
+bulge_length_at_least_22
+bulge_length_at_least_23
+bulge_length_at_least_24
+bulge_length_at_least_25
+bulge_length_at_least_26
+bulge_length_at_least_27
+bulge_length_at_least_28
+bulge_length_at_least_29
+bulge_length_at_least_30
+internal_length_at_least_2
+internal_length_at_least_3
+internal_length_at_least_4
+internal_length_at_least_5
+internal_length_at_least_6
+internal_length_at_least_7
+internal_length_at_least_8
+internal_length_at_least_9
+internal_length_at_least_10
+internal_length_at_least_11
+internal_length_at_least_12
+internal_length_at_least_13
+internal_length_at_least_14
+internal_length_at_least_15
+internal_length_at_least_16
+internal_length_at_least_17
+internal_length_at_least_18
+internal_length_at_least_19
+internal_length_at_least_20
+internal_length_at_least_21
+internal_length_at_least_22
+internal_length_at_least_23
+internal_length_at_least_24
+internal_length_at_least_25
+internal_length_at_least_26
+internal_length_at_least_27
+internal_length_at_least_28
+internal_length_at_least_29
+internal_length_at_least_30
+internal_symmetric_length_at_least_1
+internal_symmetric_length_at_least_2
+internal_symmetric_length_at_least_3
+internal_symmetric_length_at_least_4
+internal_symmetric_length_at_least_5
+internal_symmetric_length_at_least_6
+internal_symmetric_length_at_least_7
+internal_symmetric_length_at_least_8
+internal_symmetric_length_at_least_9
+internal_symmetric_length_at_least_10
+internal_symmetric_length_at_least_11
+internal_symmetric_length_at_least_12
+internal_symmetric_length_at_least_13
+internal_symmetric_length_at_least_14
+internal_symmetric_length_at_least_15
+internal_asymmetry_at_least_1
+internal_asymmetry_at_least_2
+internal_asymmetry_at_least_3
+internal_asymmetry_at_least_4
+internal_asymmetry_at_least_5
+internal_asymmetry_at_least_6
+internal_asymmetry_at_least_7
+internal_asymmetry_at_least_8
+internal_asymmetry_at_least_9
+internal_asymmetry_at_least_10
+internal_asymmetry_at_least_11
+internal_asymmetry_at_least_12
+internal_asymmetry_at_least_13
+internal_asymmetry_at_least_14
+internal_asymmetry_at_least_15
+internal_asymmetry_at_least_16
+internal_asymmetry_at_least_17
+internal_asymmetry_at_least_18
+internal_asymmetry_at_least_19
+internal_asymmetry_at_least_20
+internal_asymmetry_at_least_21
+internal_asymmetry_at_least_22
+internal_asymmetry_at_least_23
+internal_asymmetry_at_least_24
+internal_asymmetry_at_least_25
+internal_asymmetry_at_least_26
+internal_asymmetry_at_least_27
+internal_asymmetry_at_least_28
+bulge_0x1_nucleotides_A
+bulge_0x1_nucleotides_C
+bulge_0x1_nucleotides_G
+bulge_0x1_nucleotides_U
+internal_1x1_nucleotides_AA
+internal_1x1_nucleotides_AC
+internal_1x1_nucleotides_AG
+internal_1x1_nucleotides_AU
+internal_1x1_nucleotides_CC
+internal_1x1_nucleotides_CG
+internal_1x1_nucleotides_CU
+internal_1x1_nucleotides_GG
+internal_1x1_nucleotides_GU
+internal_1x1_nucleotides_UU
+helix_stacking_AAAA
+helix_stacking_AAAC
+helix_stacking_AAAG
+helix_stacking_AAAU
+helix_stacking_AACA
+helix_stacking_AACC
+helix_stacking_AACG
+helix_stacking_AACU
+helix_stacking_AAGA
+helix_stacking_AAGC
+helix_stacking_AAGG
+helix_stacking_AAGU
+helix_stacking_AAUA
+helix_stacking_AAUC
+helix_stacking_AAUG
+helix_stacking_AAUU
+helix_stacking_ACAC
+helix_stacking_ACAG
+helix_stacking_ACAU
+helix_stacking_ACCA
+helix_stacking_ACCC
+helix_stacking_ACCG
+helix_stacking_ACCU
+helix_stacking_ACGA
+helix_stacking_ACGC
+helix_stacking_ACGG
+helix_stacking_ACGU
+helix_stacking_ACUA
+helix_stacking_ACUC
+helix_stacking_ACUG
+helix_stacking_ACUU
+helix_stacking_AGAC
+helix_stacking_AGAG
+helix_stacking_AGAU
+helix_stacking_AGCC
+helix_stacking_AGCG
+helix_stacking_AGCU
+helix_stacking_AGGA
+helix_stacking_AGGC
+helix_stacking_AGGG
+helix_stacking_AGGU
+helix_stacking_AGUA
+helix_stacking_AGUC
+helix_stacking_AGUG
+helix_stacking_AGUU
+helix_stacking_AUAC
+helix_stacking_AUAG
+helix_stacking_AUAU
+helix_stacking_AUCC
+helix_stacking_AUCG
+helix_stacking_AUCU
+helix_stacking_AUGC
+helix_stacking_AUGG
+helix_stacking_AUGU
+helix_stacking_AUUA
+helix_stacking_AUUC
+helix_stacking_AUUG
+helix_stacking_AUUU
+helix_stacking_CAAC
+helix_stacking_CAAG
+helix_stacking_CAAU
+helix_stacking_CACC
+helix_stacking_CACG
+helix_stacking_CACU
+helix_stacking_CAGC
+helix_stacking_CAGG
+helix_stacking_CAGU
+helix_stacking_CAUC
+helix_stacking_CAUG
+helix_stacking_CAUU
+helix_stacking_CCAG
+helix_stacking_CCAU
+helix_stacking_CCCC
+helix_stacking_CCCG
+helix_stacking_CCCU
+helix_stacking_CCGC
+helix_stacking_CCGG
+helix_stacking_CCGU
+helix_stacking_CCUC
+helix_stacking_CCUG
+helix_stacking_CCUU
+helix_stacking_CGAG
+helix_stacking_CGAU
+helix_stacking_CGCG
+helix_stacking_CGCU
+helix_stacking_CGGC
+helix_stacking_CGGG
+helix_stacking_CGGU
+helix_stacking_CGUC
+helix_stacking_CGUG
+helix_stacking_CGUU
+helix_stacking_CUAG
+helix_stacking_CUAU
+helix_stacking_CUCG
+helix_stacking_CUCU
+helix_stacking_CUGG
+helix_stacking_CUGU
+helix_stacking_CUUC
+helix_stacking_CUUG
+helix_stacking_CUUU
+helix_stacking_GAAG
+helix_stacking_GAAU
+helix_stacking_GACG
+helix_stacking_GACU
+helix_stacking_GAGG
+helix_stacking_GAGU
+helix_stacking_GAUG
+helix_stacking_GAUU
+helix_stacking_GCAU
+helix_stacking_GCCG
+helix_stacking_GCCU
+helix_stacking_GCGG
+helix_stacking_GCGU
+helix_stacking_GCUG
+helix_stacking_GCUU
+helix_stacking_GGAU
+helix_stacking_GGCU
+helix_stacking_GGGG
+helix_stacking_GGGU
+helix_stacking_GGUG
+helix_stacking_GGUU
+helix_stacking_GUAU
+helix_stacking_GUCU
+helix_stacking_GUGU
+helix_stacking_GUUG
+helix_stacking_GUUU
+helix_stacking_UAAU
+helix_stacking_UACU
+helix_stacking_UAGU
+helix_stacking_UAUU
+helix_stacking_UCCU
+helix_stacking_UCGU
+helix_stacking_UCUU
+helix_stacking_UGGU
+helix_stacking_UGUU
+helix_stacking_UUUU
+helix_closing_AA
+helix_closing_AC
+helix_closing_AG
+helix_closing_AU
+helix_closing_CA
+helix_closing_CC
+helix_closing_CG
+helix_closing_CU
+helix_closing_GA
+helix_closing_GC
+helix_closing_GG
+helix_closing_GU
+helix_closing_UA
+helix_closing_UC
+helix_closing_UG
+helix_closing_UU
+multi_base
+multi_unpaired
+multi_paired
+dangle_left_AAA
+dangle_left_AAC
+dangle_left_AAG
+dangle_left_AAU
+dangle_left_ACA
+dangle_left_ACC
+dangle_left_ACG
+dangle_left_ACU
+dangle_left_AGA
+dangle_left_AGC
+dangle_left_AGG
+dangle_left_AGU
+dangle_left_AUA
+dangle_left_AUC
+dangle_left_AUG
+dangle_left_AUU
+dangle_left_CAA
+dangle_left_CAC
+dangle_left_CAG
+dangle_left_CAU
+dangle_left_CCA
+dangle_left_CCC
+dangle_left_CCG
+dangle_left_CCU
+dangle_left_CGA
+dangle_left_CGC
+dangle_left_CGG
+dangle_left_CGU
+dangle_left_CUA
+dangle_left_CUC
+dangle_left_CUG
+dangle_left_CUU
+dangle_left_GAA
+dangle_left_GAC
+dangle_left_GAG
+dangle_left_GAU
+dangle_left_GCA
+dangle_left_GCC
+dangle_left_GCG
+dangle_left_GCU
+dangle_left_GGA
+dangle_left_GGC
+dangle_left_GGG
+dangle_left_GGU
+dangle_left_GUA
+dangle_left_GUC
+dangle_left_GUG
+dangle_left_GUU
+dangle_left_UAA
+dangle_left_UAC
+dangle_left_UAG
+dangle_left_UAU
+dangle_left_UCA
+dangle_left_UCC
+dangle_left_UCG
+dangle_left_UCU
+dangle_left_UGA
+dangle_left_UGC
+dangle_left_UGG
+dangle_left_UGU
+dangle_left_UUA
+dangle_left_UUC
+dangle_left_UUG
+dangle_left_UUU
+dangle_right_AAA
+dangle_right_AAC
+dangle_right_AAG
+dangle_right_AAU
+dangle_right_ACA
+dangle_right_ACC
+dangle_right_ACG
+dangle_right_ACU
+dangle_right_AGA
+dangle_right_AGC
+dangle_right_AGG
+dangle_right_AGU
+dangle_right_AUA
+dangle_right_AUC
+dangle_right_AUG
+dangle_right_AUU
+dangle_right_CAA
+dangle_right_CAC
+dangle_right_CAG
+dangle_right_CAU
+dangle_right_CCA
+dangle_right_CCC
+dangle_right_CCG
+dangle_right_CCU
+dangle_right_CGA
+dangle_right_CGC
+dangle_right_CGG
+dangle_right_CGU
+dangle_right_CUA
+dangle_right_CUC
+dangle_right_CUG
+dangle_right_CUU
+dangle_right_GAA
+dangle_right_GAC
+dangle_right_GAG
+dangle_right_GAU
+dangle_right_GCA
+dangle_right_GCC
+dangle_right_GCG
+dangle_right_GCU
+dangle_right_GGA
+dangle_right_GGC
+dangle_right_GGG
+dangle_right_GGU
+dangle_right_GUA
+dangle_right_GUC
+dangle_right_GUG
+dangle_right_GUU
+dangle_right_UAA
+dangle_right_UAC
+dangle_right_UAG
+dangle_right_UAU
+dangle_right_UCA
+dangle_right_UCC
+dangle_right_UCG
+dangle_right_UCU
+dangle_right_UGA
+dangle_right_UGC
+dangle_right_UGG
+dangle_right_UGU
+dangle_right_UUA
+dangle_right_UUC
+dangle_right_UUG
+dangle_right_UUU
+external_unpaired
+external_paired
diff --git a/./tmp.seq b/./tmp.seq
new file mode 100644
index 0000000..a11de9e
--- /dev/null
+++ b/./tmp.seq
@@ -0,0 +1 @@
+AUUCUGCUUAUAGGGUUAUUAGAUCAUAUCUCUGUUCGGCCGAGCGUCUGAUCUAGGCGA
diff --git a/./tmp_v2 b/./tmp_v2
new file mode 100644
index 0000000..c598d3a
--- /dev/null
+++ b/./tmp_v2
@@ -0,0 +1,708 @@
+base_pair_AA
+base_pair_AC
+base_pair_AG
+base_pair_AU
+base_pair_CC
+base_pair_CG
+base_pair_CU
+base_pair_GG
+base_pair_GU
+base_pair_UU
+terminal_mismatch_AAAA
+terminal_mismatch_AAAC
+terminal_mismatch_AAAG
+terminal_mismatch_AAAU
+terminal_mismatch_AACA
+terminal_mismatch_AACC
+terminal_mismatch_AACG
+terminal_mismatch_AACU
+terminal_mismatch_AAGA
+terminal_mismatch_AAGC
+terminal_mismatch_AAGG
+terminal_mismatch_AAGU
+terminal_mismatch_AAUA
+terminal_mismatch_AAUC
+terminal_mismatch_AAUG
+terminal_mismatch_AAUU
+terminal_mismatch_ACAA
+terminal_mismatch_ACAC
+terminal_mismatch_ACAG
+terminal_mismatch_ACAU
+terminal_mismatch_ACCA
+terminal_mismatch_ACCC
+terminal_mismatch_ACCG
+terminal_mismatch_ACCU
+terminal_mismatch_ACGA
+terminal_mismatch_ACGC
+terminal_mismatch_ACGG
+terminal_mismatch_ACGU
+terminal_mismatch_ACUA
+terminal_mismatch_ACUC
+terminal_mismatch_ACUG
+terminal_mismatch_ACUU
+terminal_mismatch_AGAA
+terminal_mismatch_AGAC
+terminal_mismatch_AGAG
+terminal_mismatch_AGAU
+terminal_mismatch_AGCA
+terminal_mismatch_AGCC
+terminal_mismatch_AGCG
+terminal_mismatch_AGCU
+terminal_mismatch_AGGA
+terminal_mismatch_AGGC
+terminal_mismatch_AGGG
+terminal_mismatch_AGGU
+terminal_mismatch_AGUA
+terminal_mismatch_AGUC
+terminal_mismatch_AGUG
+terminal_mismatch_AGUU
+terminal_mismatch_AUAA
+terminal_mismatch_AUAC
+terminal_mismatch_AUAG
+terminal_mismatch_AUAU
+terminal_mismatch_AUCA
+terminal_mismatch_AUCC
+terminal_mismatch_AUCG
+terminal_mismatch_AUCU
+terminal_mismatch_AUGA
+terminal_mismatch_AUGC
+terminal_mismatch_AUGG
+terminal_mismatch_AUGU
+terminal_mismatch_AUUA
+terminal_mismatch_AUUC
+terminal_mismatch_AUUG
+terminal_mismatch_AUUU
+terminal_mismatch_CAAA
+terminal_mismatch_CAAC
+terminal_mismatch_CAAG
+terminal_mismatch_CAAU
+terminal_mismatch_CACA
+terminal_mismatch_CACC
+terminal_mismatch_CACG
+terminal_mismatch_CACU
+terminal_mismatch_CAGA
+terminal_mismatch_CAGC
+terminal_mismatch_CAGG
+terminal_mismatch_CAGU
+terminal_mismatch_CAUA
+terminal_mismatch_CAUC
+terminal_mismatch_CAUG
+terminal_mismatch_CAUU
+terminal_mismatch_CCAA
+terminal_mismatch_CCAC
+terminal_mismatch_CCAG
+terminal_mismatch_CCAU
+terminal_mismatch_CCCA
+terminal_mismatch_CCCC
+terminal_mismatch_CCCG
+terminal_mismatch_CCCU
+terminal_mismatch_CCGA
+terminal_mismatch_CCGC
+terminal_mismatch_CCGG
+terminal_mismatch_CCGU
+terminal_mismatch_CCUA
+terminal_mismatch_CCUC
+terminal_mismatch_CCUG
+terminal_mismatch_CCUU
+terminal_mismatch_CGAA
+terminal_mismatch_CGAC
+terminal_mismatch_CGAG
+terminal_mismatch_CGAU
+terminal_mismatch_CGCA
+terminal_mismatch_CGCC
+terminal_mismatch_CGCG
+terminal_mismatch_CGCU
+terminal_mismatch_CGGA
+terminal_mismatch_CGGC
+terminal_mismatch_CGGG
+terminal_mismatch_CGGU
+terminal_mismatch_CGUA
+terminal_mismatch_CGUC
+terminal_mismatch_CGUG
+terminal_mismatch_CGUU
+terminal_mismatch_CUAA
+terminal_mismatch_CUAC
+terminal_mismatch_CUAG
+terminal_mismatch_CUAU
+terminal_mismatch_CUCA
+terminal_mismatch_CUCC
+terminal_mismatch_CUCG
+terminal_mismatch_CUCU
+terminal_mismatch_CUGA
+terminal_mismatch_CUGC
+terminal_mismatch_CUGG
+terminal_mismatch_CUGU
+terminal_mismatch_CUUA
+terminal_mismatch_CUUC
+terminal_mismatch_CUUG
+terminal_mismatch_CUUU
+terminal_mismatch_GAAA
+terminal_mismatch_GAAC
+terminal_mismatch_GAAG
+terminal_mismatch_GAAU
+terminal_mismatch_GACA
+terminal_mismatch_GACC
+terminal_mismatch_GACG
+terminal_mismatch_GACU
+terminal_mismatch_GAGA
+terminal_mismatch_GAGC
+terminal_mismatch_GAGG
+terminal_mismatch_GAGU
+terminal_mismatch_GAUA
+terminal_mismatch_GAUC
+terminal_mismatch_GAUG
+terminal_mismatch_GAUU
+terminal_mismatch_GCAA
+terminal_mismatch_GCAC
+terminal_mismatch_GCAG
+terminal_mismatch_GCAU
+terminal_mismatch_GCCA
+terminal_mismatch_GCCC
+terminal_mismatch_GCCG
+terminal_mismatch_GCCU
+terminal_mismatch_GCGA
+terminal_mismatch_GCGC
+terminal_mismatch_GCGG
+terminal_mismatch_GCGU
+terminal_mismatch_GCUA
+terminal_mismatch_GCUC
+terminal_mismatch_GCUG
+terminal_mismatch_GCUU
+terminal_mismatch_GGAA
+terminal_mismatch_GGAC
+terminal_mismatch_GGAG
+terminal_mismatch_GGAU
+terminal_mismatch_GGCA
+terminal_mismatch_GGCC
+terminal_mismatch_GGCG
+terminal_mismatch_GGCU
+terminal_mismatch_GGGA
+terminal_mismatch_GGGC
+terminal_mismatch_GGGG
+terminal_mismatch_GGGU
+terminal_mismatch_GGUA
+terminal_mismatch_GGUC
+terminal_mismatch_GGUG
+terminal_mismatch_GGUU
+terminal_mismatch_GUAA
+terminal_mismatch_GUAC
+terminal_mismatch_GUAG
+terminal_mismatch_GUAU
+terminal_mismatch_GUCA
+terminal_mismatch_GUCC
+terminal_mismatch_GUCG
+terminal_mismatch_GUCU
+terminal_mismatch_GUGA
+terminal_mismatch_GUGC
+terminal_mismatch_GUGG
+terminal_mismatch_GUGU
+terminal_mismatch_GUUA
+terminal_mismatch_GUUC
+terminal_mismatch_GUUG
+terminal_mismatch_GUUU
+terminal_mismatch_UAAA
+terminal_mismatch_UAAC
+terminal_mismatch_UAAG
+terminal_mismatch_UAAU
+terminal_mismatch_UACA
+terminal_mismatch_UACC
+terminal_mismatch_UACG
+terminal_mismatch_UACU
+terminal_mismatch_UAGA
+terminal_mismatch_UAGC
+terminal_mismatch_UAGG
+terminal_mismatch_UAGU
+terminal_mismatch_UAUA
+terminal_mismatch_UAUC
+terminal_mismatch_UAUG
+terminal_mismatch_UAUU
+terminal_mismatch_UCAA
+terminal_mismatch_UCAC
+terminal_mismatch_UCAG
+terminal_mismatch_UCAU
+terminal_mismatch_UCCA
+terminal_mismatch_UCCC
+terminal_mismatch_UCCG
+terminal_mismatch_UCCU
+terminal_mismatch_UCGA
+terminal_mismatch_UCGC
+terminal_mismatch_UCGG
+terminal_mismatch_UCGU
+terminal_mismatch_UCUA
+terminal_mismatch_UCUC
+terminal_mismatch_UCUG
+terminal_mismatch_UCUU
+terminal_mismatch_UGAA
+terminal_mismatch_UGAC
+terminal_mismatch_UGAG
+terminal_mismatch_UGAU
+terminal_mismatch_UGCA
+terminal_mismatch_UGCC
+terminal_mismatch_UGCG
+terminal_mismatch_UGCU
+terminal_mismatch_UGGA
+terminal_mismatch_UGGC
+terminal_mismatch_UGGG
+terminal_mismatch_UGGU
+terminal_mismatch_UGUA
+terminal_mismatch_UGUC
+terminal_mismatch_UGUG
+terminal_mismatch_UGUU
+terminal_mismatch_UUAA
+terminal_mismatch_UUAC
+terminal_mismatch_UUAG
+terminal_mismatch_UUAU
+terminal_mismatch_UUCA
+terminal_mismatch_UUCC
+terminal_mismatch_UUCG
+terminal_mismatch_UUCU
+terminal_mismatch_UUGA
+terminal_mismatch_UUGC
+terminal_mismatch_UUGG
+terminal_mismatch_UUGU
+terminal_mismatch_UUUA
+terminal_mismatch_UUUC
+terminal_mismatch_UUUG
+terminal_mismatch_UUUU
+hairpin_length_at_least_0
+hairpin_length_at_least_1
+hairpin_length_at_least_2
+hairpin_length_at_least_3
+hairpin_length_at_least_4
+hairpin_length_at_least_5
+hairpin_length_at_least_6
+hairpin_length_at_least_7
+hairpin_length_at_least_8
+hairpin_length_at_least_9
+hairpin_length_at_least_10
+hairpin_length_at_least_11
+hairpin_length_at_least_12
+hairpin_length_at_least_13
+hairpin_length_at_least_14
+hairpin_length_at_least_15
+hairpin_length_at_least_16
+hairpin_length_at_least_17
+hairpin_length_at_least_18
+hairpin_length_at_least_19
+hairpin_length_at_least_20
+hairpin_length_at_least_21
+hairpin_length_at_least_22
+hairpin_length_at_least_23
+hairpin_length_at_least_24
+hairpin_length_at_least_25
+hairpin_length_at_least_26
+hairpin_length_at_least_27
+hairpin_length_at_least_28
+hairpin_length_at_least_29
+hairpin_length_at_least_30
+internal_explicit_1_1
+internal_explicit_1_2
+internal_explicit_1_3
+internal_explicit_1_4
+internal_explicit_2_2
+internal_explicit_2_3
+internal_explicit_2_4
+internal_explicit_3_3
+internal_explicit_3_4
+internal_explicit_4_4
+bulge_length_at_least_1
+bulge_length_at_least_2
+bulge_length_at_least_3
+bulge_length_at_least_4
+bulge_length_at_least_5
+bulge_length_at_least_6
+bulge_length_at_least_7
+bulge_length_at_least_8
+bulge_length_at_least_9
+bulge_length_at_least_10
+bulge_length_at_least_11
+bulge_length_at_least_12
+bulge_length_at_least_13
+bulge_length_at_least_14
+bulge_length_at_least_15
+bulge_length_at_least_16
+bulge_length_at_least_17
+bulge_length_at_least_18
+bulge_length_at_least_19
+bulge_length_at_least_20
+bulge_length_at_least_21
+bulge_length_at_least_22
+bulge_length_at_least_23
+bulge_length_at_least_24
+bulge_length_at_least_25
+bulge_length_at_least_26
+bulge_length_at_least_27
+bulge_length_at_least_28
+bulge_length_at_least_29
+bulge_length_at_least_30
+internal_length_at_least_2
+internal_length_at_least_3
+internal_length_at_least_4
+internal_length_at_least_5
+internal_length_at_least_6
+internal_length_at_least_7
+internal_length_at_least_8
+internal_length_at_least_9
+internal_length_at_least_10
+internal_length_at_least_11
+internal_length_at_least_12
+internal_length_at_least_13
+internal_length_at_least_14
+internal_length_at_least_15
+internal_length_at_least_16
+internal_length_at_least_17
+internal_length_at_least_18
+internal_length_at_least_19
+internal_length_at_least_20
+internal_length_at_least_21
+internal_length_at_least_22
+internal_length_at_least_23
+internal_length_at_least_24
+internal_length_at_least_25
+internal_length_at_least_26
+internal_length_at_least_27
+internal_length_at_least_28
+internal_length_at_least_29
+internal_length_at_least_30
+internal_symmetric_length_at_least_1
+internal_symmetric_length_at_least_2
+internal_symmetric_length_at_least_3
+internal_symmetric_length_at_least_4
+internal_symmetric_length_at_least_5
+internal_symmetric_length_at_least_6
+internal_symmetric_length_at_least_7
+internal_symmetric_length_at_least_8
+internal_symmetric_length_at_least_9
+internal_symmetric_length_at_least_10
+internal_symmetric_length_at_least_11
+internal_symmetric_length_at_least_12
+internal_symmetric_length_at_least_13
+internal_symmetric_length_at_least_14
+internal_symmetric_length_at_least_15
+internal_asymmetry_at_least_1
+internal_asymmetry_at_least_2
+internal_asymmetry_at_least_3
+internal_asymmetry_at_least_4
+internal_asymmetry_at_least_5
+internal_asymmetry_at_least_6
+internal_asymmetry_at_least_7
+internal_asymmetry_at_least_8
+internal_asymmetry_at_least_9
+internal_asymmetry_at_least_10
+internal_asymmetry_at_least_11
+internal_asymmetry_at_least_12
+internal_asymmetry_at_least_13
+internal_asymmetry_at_least_14
+internal_asymmetry_at_least_15
+internal_asymmetry_at_least_16
+internal_asymmetry_at_least_17
+internal_asymmetry_at_least_18
+internal_asymmetry_at_least_19
+internal_asymmetry_at_least_20
+internal_asymmetry_at_least_21
+internal_asymmetry_at_least_22
+internal_asymmetry_at_least_23
+internal_asymmetry_at_least_24
+internal_asymmetry_at_least_25
+internal_asymmetry_at_least_26
+internal_asymmetry_at_least_27
+internal_asymmetry_at_least_28
+bulge_0x1_nucleotides_A
+bulge_0x1_nucleotides_C
+bulge_0x1_nucleotides_G
+bulge_0x1_nucleotides_U
+internal_1x1_nucleotides_AA
+internal_1x1_nucleotides_AC
+internal_1x1_nucleotides_AG
+internal_1x1_nucleotides_AU
+internal_1x1_nucleotides_CC
+internal_1x1_nucleotides_CG
+internal_1x1_nucleotides_CU
+internal_1x1_nucleotides_GG
+internal_1x1_nucleotides_GU
+internal_1x1_nucleotides_UU
+helix_stacking_AAAA
+helix_stacking_AAAC
+helix_stacking_AAAG
+helix_stacking_AAAU
+helix_stacking_AACA
+helix_stacking_AACC
+helix_stacking_AACG
+helix_stacking_AACU
+helix_stacking_AAGA
+helix_stacking_AAGC
+helix_stacking_AAGG
+helix_stacking_AAGU
+helix_stacking_AAUA
+helix_stacking_AAUC
+helix_stacking_AAUG
+helix_stacking_AAUU
+helix_stacking_ACAC
+helix_stacking_ACAG
+helix_stacking_ACAU
+helix_stacking_ACCA
+helix_stacking_ACCC
+helix_stacking_ACCG
+helix_stacking_ACCU
+helix_stacking_ACGA
+helix_stacking_ACGC
+helix_stacking_ACGG
+helix_stacking_ACGU
+helix_stacking_ACUA
+helix_stacking_ACUC
+helix_stacking_ACUG
+helix_stacking_ACUU
+helix_stacking_AGAC
+helix_stacking_AGAG
+helix_stacking_AGAU
+helix_stacking_AGCC
+helix_stacking_AGCG
+helix_stacking_AGCU
+helix_stacking_AGGA
+helix_stacking_AGGC
+helix_stacking_AGGG
+helix_stacking_AGGU
+helix_stacking_AGUA
+helix_stacking_AGUC
+helix_stacking_AGUG
+helix_stacking_AGUU
+helix_stacking_AUAC
+helix_stacking_AUAG
+helix_stacking_AUAU
+helix_stacking_AUCC
+helix_stacking_AUCG
+helix_stacking_AUCU
+helix_stacking_AUGC
+helix_stacking_AUGG
+helix_stacking_AUGU
+helix_stacking_AUUA
+helix_stacking_AUUC
+helix_stacking_AUUG
+helix_stacking_AUUU
+helix_stacking_CAAC
+helix_stacking_CAAG
+helix_stacking_CAAU
+helix_stacking_CACC
+helix_stacking_CACG
+helix_stacking_CACU
+helix_stacking_CAGC
+helix_stacking_CAGG
+helix_stacking_CAGU
+helix_stacking_CAUC
+helix_stacking_CAUG
+helix_stacking_CAUU
+helix_stacking_CCAG
+helix_stacking_CCAU
+helix_stacking_CCCC
+helix_stacking_CCCG
+helix_stacking_CCCU
+helix_stacking_CCGC
+helix_stacking_CCGG
+helix_stacking_CCGU
+helix_stacking_CCUC
+helix_stacking_CCUG
+helix_stacking_CCUU
+helix_stacking_CGAG
+helix_stacking_CGAU
+helix_stacking_CGCG
+helix_stacking_CGCU
+helix_stacking_CGGC
+helix_stacking_CGGG
+helix_stacking_CGGU
+helix_stacking_CGUC
+helix_stacking_CGUG
+helix_stacking_CGUU
+helix_stacking_CUAG
+helix_stacking_CUAU
+helix_stacking_CUCG
+helix_stacking_CUCU
+helix_stacking_CUGG
+helix_stacking_CUGU
+helix_stacking_CUUC
+helix_stacking_CUUG
+helix_stacking_CUUU
+helix_stacking_GAAG
+helix_stacking_GAAU
+helix_stacking_GACG
+helix_stacking_GACU
+helix_stacking_GAGG
+helix_stacking_GAGU
+helix_stacking_GAUG
+helix_stacking_GAUU
+helix_stacking_GCAU
+helix_stacking_GCCG
+helix_stacking_GCCU
+helix_stacking_GCGG
+helix_stacking_GCGU
+helix_stacking_GCUG
+helix_stacking_GCUU
+helix_stacking_GGAU
+helix_stacking_GGCU
+helix_stacking_GGGG
+helix_stacking_GGGU
+helix_stacking_GGUG
+helix_stacking_GGUU
+helix_stacking_GUAU
+helix_stacking_GUCU
+helix_stacking_GUGU
+helix_stacking_GUUG
+helix_stacking_GUUU
+helix_stacking_UAAU
+helix_stacking_UACU
+helix_stacking_UAGU
+helix_stacking_UAUU
+helix_stacking_UCCU
+helix_stacking_UCGU
+helix_stacking_UCUU
+helix_stacking_UGGU
+helix_stacking_UGUU
+helix_stacking_UUUU
+helix_closing_AA
+helix_closing_AC
+helix_closing_AG
+helix_closing_AU
+helix_closing_CA
+helix_closing_CC
+helix_closing_CG
+helix_closing_CU
+helix_closing_GA
+helix_closing_GC
+helix_closing_GG
+helix_closing_GU
+helix_closing_UA
+helix_closing_UC
+helix_closing_UG
+helix_closing_UU
+multi_base
+multi_unpaired
+multi_paired
+dangle_left_AAA
+dangle_left_AAC
+dangle_left_AAG
+dangle_left_AAU
+dangle_left_ACA
+dangle_left_ACC
+dangle_left_ACG
+dangle_left_ACU
+dangle_left_AGA
+dangle_left_AGC
+dangle_left_AGG
+dangle_left_AGU
+dangle_left_AUA
+dangle_left_AUC
+dangle_left_AUG
+dangle_left_AUU
+dangle_left_CAA
+dangle_left_CAC
+dangle_left_CAG
+dangle_left_CAU
+dangle_left_CCA
+dangle_left_CCC
+dangle_left_CCG
+dangle_left_CCU
+dangle_left_CGA
+dangle_left_CGC
+dangle_left_CGG
+dangle_left_CGU
+dangle_left_CUA
+dangle_left_CUC
+dangle_left_CUG
+dangle_left_CUU
+dangle_left_GAA
+dangle_left_GAC
+dangle_left_GAG
+dangle_left_GAU
+dangle_left_GCA
+dangle_left_GCC
+dangle_left_GCG
+dangle_left_GCU
+dangle_left_GGA
+dangle_left_GGC
+dangle_left_GGG
+dangle_left_GGU
+dangle_left_GUA
+dangle_left_GUC
+dangle_left_GUG
+dangle_left_GUU
+dangle_left_UAA
+dangle_left_UAC
+dangle_left_UAG
+dangle_left_UAU
+dangle_left_UCA
+dangle_left_UCC
+dangle_left_UCG
+dangle_left_UCU
+dangle_left_UGA
+dangle_left_UGC
+dangle_left_UGG
+dangle_left_UGU
+dangle_left_UUA
+dangle_left_UUC
+dangle_left_UUG
+dangle_left_UUU
+dangle_right_AAA
+dangle_right_AAC
+dangle_right_AAG
+dangle_right_AAU
+dangle_right_ACA
+dangle_right_ACC
+dangle_right_ACG
+dangle_right_ACU
+dangle_right_AGA
+dangle_right_AGC
+dangle_right_AGG
+dangle_right_AGU
+dangle_right_AUA
+dangle_right_AUC
+dangle_right_AUG
+dangle_right_AUU
+dangle_right_CAA
+dangle_right_CAC
+dangle_right_CAG
+dangle_right_CAU
+dangle_right_CCA
+dangle_right_CCC
+dangle_right_CCG
+dangle_right_CCU
+dangle_right_CGA
+dangle_right_CGC
+dangle_right_CGG
+dangle_right_CGU
+dangle_right_CUA
+dangle_right_CUC
+dangle_right_CUG
+dangle_right_CUU
+dangle_right_GAA
+dangle_right_GAC
+dangle_right_GAG
+dangle_right_GAU
+dangle_right_GCA
+dangle_right_GCC
+dangle_right_GCG
+dangle_right_GCU
+dangle_right_GGA
+dangle_right_GGC
+dangle_right_GGG
+dangle_right_GGU
+dangle_right_GUA
+dangle_right_GUC
+dangle_right_GUG
+dangle_right_GUU
+dangle_right_UAA
+dangle_right_UAC
+dangle_right_UAG
+dangle_right_UAU
+dangle_right_UCA
+dangle_right_UCC
+dangle_right_UCG
+dangle_right_UCU
+dangle_right_UGA
+dangle_right_UGC
+dangle_right_UGG
+dangle_right_UGU
+dangle_right_UUA
+dangle_right_UUC
+dangle_right_UUG
+dangle_right_UUU
+external_unpaired
+external_paired
