diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.hpp b/./ComputationEngine.hpp
index 4166df6..68d656c 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.hpp
+++ b/./ComputationEngine.hpp
@@ -18,6 +18,7 @@
 #include "DistributedComputation.hpp"
 #include "FileDescription.hpp"
 #include <vector>
+#include <cstdlib>
 
 //////////////////////////////////////////////////////////////////////
 // struct SharedInfo
@@ -37,6 +38,7 @@ struct SharedInfo
     bool use_nonsmooth;
     bool use_loss;
     RealT gamma;
+    RealT sigma;
     RealT log_base;
 //    std::vector<int> evidence_cpd_id;
     RealT evidence_data_scale;
@@ -76,7 +78,10 @@ enum ProcessingType
     COMPUTE_GRADIENT_SE,
     CHECK_ZEROS_IN_DATA,
     COMPUTE_HV,
-    PREDICT
+    PREDICT,
+    SAMPLE,
+    TEST_ENERGIES,
+    REVI,
 };
 
 struct NonSharedInfo
@@ -125,6 +130,9 @@ public:
     void ComputeGammaMLEFunctionAndGradient(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared, bool need_gradient);
     void ComputeHessianVectorProduct(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
     void Predict(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+    void Sample(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+    void RunREVI(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
+    void TestEnergies(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
     void CheckZerosInData(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
     void ComputeGammaMLEScalingFactor(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared);
     void ComputeFunctionAndGradientSE(std::vector<RealT> &result, const SharedInfo<RealT> &shared, const NonSharedInfo &nonshared, bool need_gradient);
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.ipp b/./ComputationEngine.ipp
index 742d4c0..6903662 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationEngine.ipp
+++ b/./ComputationEngine.ipp
@@ -89,6 +89,15 @@ void ComputationEngine<RealT>::DoComputation(std::vector<RealT> &result,
         case PREDICT:
             Predict(result, shared, nonshared);
             break;
+        case SAMPLE:
+            Sample(result, shared, nonshared);
+            break;
+        case REVI:
+            RunREVI(result, shared, nonshared);
+            break;
+        case TEST_ENERGIES:
+            TestEnergies(result,shared,nonshared);
+            break;
         default: 
             Assert(false, "Unknown command type.");
             break;
@@ -1043,7 +1052,7 @@ void ComputationEngine<RealT>::ComputeFunctionAndGradientSE(std::vector<RealT> &
                 }
 
                 int index_k = parameter_manager.GetLogicalIndex(
-                    inference_engine.GetLogScoreEvidence(0, i, j, dataset_id));
+                    inference_engine.GetLogScoreEvidence(0, i, j, dataset_id)); // i: seq, j: pr or unpaired, ds=0
                 int index_theta = parameter_manager.GetLogicalIndex(
                     inference_engine.GetLogScoreEvidence(1, i, j, dataset_id));
 
@@ -1210,6 +1219,268 @@ void ComputationEngine<RealT>::ComputeHessianVectorProduct(std::vector<RealT> &r
     
     result = (result - result2) / (RealT(2) * EPSILON);
 }
+//////////////////////////////////////////////////////////////////////
+// ComputationEngine::TestEnergies()
+//
+// Print energies for a single sequence.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationEngine<RealT>::TestEnergies(std::vector<RealT> &result, 
+                                       const SharedInfo<RealT> &shared,
+                                       const NonSharedInfo &nonshared)
+{
+    result.clear();
+
+    // load sequence, with constraints if necessary
+    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
+    inference_engine.LoadSequence(sstruct);
+    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
+
+    // load parameters
+    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
+    inference_engine.LoadValues(w * shared.log_base);
+
+    inference_engine.UpdateEvidenceStructures();
+
+    // perform inference
+    SStruct *solution;
+
+    inference_engine.ComputeViterbi();
+
+    if (options.GetBoolValue("use_evidence")){
+        inference_engine.GetViterbiFeaturesESS();
+    }
+    else{
+            inference_engine.GetViterbiFeatures();
+    }
+
+    std::cout << "Viterbi score for \"" << descriptions[nonshared.index].input_filename << "\": " 
+            << inference_engine.GetViterbiScore() << std::endl;
+
+    solution = new SStruct(sstruct);
+    solution->SetMapping(inference_engine.PredictPairingsViterbi());
+
+    WriteProgressMessage("");
+    solution->WriteParens(std::cout);
+
+    delete solution;
+}
+
+//////////////////////////////////////////////////////////////////////
+// ComputationEngine::REVI()
+//
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationEngine<RealT>::RunREVI(std::vector<RealT> &result, 
+                                       const SharedInfo<RealT> &shared,
+                                       const NonSharedInfo &nonshared)
+{
+    result.clear();
+
+
+    // perform inference (repurposing chem mapping potentials as pairwise potentials)
+
+    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
+    inference_engine.LoadSequence(sstruct);
+    inference_engine.InitializeREVIVec();
+
+    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
+    // load parameters
+
+    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
+    inference_engine.LoadValues(w * shared.log_base);
+
+    int L = sstruct.GetLength();
+    int n_samples = 1000;
+    int n_iters = 100;
+    double last_loss_0 = 100000000;
+    double last_loss_1 = 100000000;
+    double last_loss_2 = 100000000;
+    double step_size = 0.1;
+
+    RealT sigma = shared.sigma;
+
+    for (int k=1; k<=n_iters; k++){
+
+    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
+    inference_engine.LoadValues(w * shared.log_base);
+
+    inference_engine.ComputeInsideESS();
+
+    std::vector<RealT> unp_i(L,0.0);
+    std::vector<RealT> pr_i(L,0.0);
+
+    std::vector<std::vector<RealT> > p_j_unp_given_i_unp;
+    std::vector<std::vector<RealT> > p_j_paired_given_i_paired;
+
+    for (int i=0; i< L; i++)
+    {    
+        std::vector<RealT> vec(L,0.0);
+        p_j_unp_given_i_unp.push_back(vec);
+        p_j_paired_given_i_paired.push_back(vec);
+    }
+
+    for (int sample_ind = 0; sample_ind < n_samples; sample_ind++)
+    { 
+
+    int seed = rand();
+    inference_engine.InitRand(seed);
+    std::vector<int> map = inference_engine.PredictPairingsStochasticTracebackESS();
+
+    // count occurences from samples
+    for (int i=0; i< L; i++)
+        {
+            if (map[i+1] == 0){
+                unp_i[i] += 1;
+
+                for (int j=0; j<L; j++){
+                    if (map[j+1] == 0)
+                    {
+                        p_j_unp_given_i_unp[i][j] += 1;
+                    }
+                }
+        }
+        else{ // base is paired
+            pr_i[i] += 1;
+             for (int j=0; j<L; j++){
+                        if (map[j+1] != 0)
+                        {
+                            p_j_paired_given_i_paired[i][j] += 1;
+                        }
+                    }   
+        }
+    }
+
+}
+    // normalize probability counts for p_unpaired vector
+
+    for (int i=0; i< L; i++)
+        {
+            if (unp_i[i] > 0){
+
+                for (int j=0; j<L; j++){
+                    p_j_unp_given_i_unp[i][j] /= unp_i[i]; 
+                }
+            }
+            unp_i[i] /= n_samples;
+    }
+
+    // normalize probability counts for p_paired vector
+    for (int i=0; i< L; i++)
+        {
+            if (pr_i[i] > 0){
+
+                for (int j=0; j<L; j++){
+                    p_j_paired_given_i_paired[i][j] /= pr_i[i]; 
+                }
+            }
+            pr_i[i] /= n_samples;
+    }
+
+    std::vector<RealT> error = inference_engine.GetREVIError(unp_i);
+    std::vector<std::vector< double> > currREVIvec_up = inference_engine.GetREVIvec_up();
+    std::vector<std::vector< double> > currREVIvec_pr = inference_engine.GetREVIvec_pr();
+
+    std::vector<RealT> update_unp(L,0.0);
+    std::vector<RealT> update_pr(L,0.0);
+
+    // get p_i, p_i_given_j
+    // write gradient
+
+    double curr_loss = 0.0;
+
+    // get gradient for unpaired potentials
+    for (int j=0; j< L; j++){
+
+     for (int i=0; i< L; i++)
+        {    
+        update_unp[j] += sigma*step_size*error[i]*unp_i[i]*(unp_i[j] - p_j_unp_given_i_unp[i][j]);
+        update_pr[j] += sigma*step_size*error[i]*pr_i[i]*(pr_i[j] - p_j_paired_given_i_paired[i][j]);
+
+            }
+        update_unp[j] += -2*step_size*currREVIvec_up[0][j];
+        update_pr[j] += -2*step_size*currREVIvec_pr[0][j]; //UPDATE to be curr REVI vec for paired
+
+        }
+
+    for (int i=0; i< L; i++)
+        {   
+        curr_loss += pow(currREVIvec_up[0][i],2) + sigma*pow(error[i],2) + pow(currREVIvec_pr[0][i],2); // UPDATE to be curr REVI vec for paired
+        }     
+
+
+    if ((abs(last_loss_2 - curr_loss) < 0.1) || k==n_iters){
+        // We're done, sample and print structures one more time
+
+    SStruct *solution;
+
+    if (options.GetStringValue("output_bpseq_destination") != "")
+    {
+        solution = new SStruct(sstruct);
+        //solution->SetMapping(inference_engine.PredictPairingsViterbi());
+
+        const std::string filename = MakeOutputFilename(descriptions[nonshared.index].input_filename,
+                                                        options.GetStringValue("output_bpseq_destination"),
+                                                        options.GetRealValue("gamma") < 0,
+                                                        shared.gamma);
+        std::ofstream outfile(filename.c_str());
+        if (outfile.fail()) Error("Unable to open output bpseq file '%s' for writing.", filename.c_str());
+        solution->WriteBPPSEQ(outfile, inference_engine.GetREVIvec_up());
+        outfile.close();
+        delete solution;
+    }
+
+    if (options.GetStringValue("output_posteriors_destination") != "")
+    {
+        const std::string filename = MakeOutputFilename(descriptions[nonshared.index].input_filename,
+                                                        options.GetStringValue("output_posteriors_destination"),
+                                                        options.GetRealValue("gamma") < 0,
+                                                        shared.gamma);
+
+        inference_engine.ComputeOutsideESS();
+        inference_engine.ComputePosteriorESS();
+
+        RealT *posterior = inference_engine.GetPosterior(options.GetRealValue("output_posteriors_cutoff"));
+        SparseMatrix<RealT> sparse(posterior, sstruct.GetLength()+1, RealT(0));
+        delete [] posterior;
+        std::ofstream outfile(filename.c_str());
+        if (outfile.fail()) Error("Unable to open output posteriors file '%s' for writing.", filename.c_str());
+        sparse.PrintSparseBPSEQ(outfile, sstruct.GetSequences()[0]);
+        outfile.close();
+    }
+
+        for (int sample_ind = 0; sample_ind < 100; sample_ind++)
+            { 
+            solution = new SStruct(sstruct);
+            int seed = rand();
+            inference_engine.InitRand(seed);
+
+            solution->SetMapping(inference_engine.PredictPairingsStochasticTracebackESS());
+            solution->WriteParensOnly(std::cout);
+            delete solution;
+            }
+
+        break;
+    } else {
+        // continue
+        std::cerr << k << " " << curr_loss << std::endl;
+        std::cerr << "p_i " << unp_i << std::endl; 
+        std::cerr << "err " << error << std::endl;
+        last_loss_2 = last_loss_1;
+        last_loss_1 = last_loss_0;
+        last_loss_0 = curr_loss;
+
+        step_size /= 2;
+
+        inference_engine.UpdateREVIVec(update_unp, update_pr);
+    
+    }
+
+
+}
+}
 
 //////////////////////////////////////////////////////////////////////
 // ComputationEngine::Predict()
@@ -1244,6 +1515,8 @@ void ComputationEngine<RealT>::Predict(std::vector<RealT> &result,
         // Basically, add a ComputeViterbiESS and then call it to support this.
 
         inference_engine.ComputeViterbi();
+        inference_engine.ComputeViterbiFeatureCounts();
+
         if (options.GetBoolValue("partition_function_only"))
         {
             std::cout << "Viterbi score for \"" << descriptions[nonshared.index].input_filename << "\": " 
@@ -1344,6 +1617,66 @@ void ComputationEngine<RealT>::Predict(std::vector<RealT> &result,
     
     delete solution;
 }
+//////////////////////////////////////////////////////////////////////
+// ComputationEngine::Sample()
+//
+// Sample structures from predicted ensemble.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationEngine<RealT>::Sample(std::vector<RealT> &result, 
+                                       const SharedInfo<RealT> &shared,
+                                       const NonSharedInfo &nonshared)
+{
+    result.clear();
+    
+    // load sequence, with constraints if necessary
+    const SStruct &sstruct = descriptions[nonshared.index].sstruct;
+    inference_engine.LoadSequence(sstruct);
+    if (options.GetBoolValue("use_constraints")) inference_engine.UseConstraints(sstruct.GetMapping());
+
+    // load parameters
+    const std::vector<RealT> w(shared.w, shared.w + parameter_manager.GetNumLogicalParameters());
+    inference_engine.LoadValues(w * shared.log_base);
+
+    inference_engine.UpdateEvidenceStructures();
+
+    // perform inference
+    SStruct *solution;
+
+    int N = options.GetIntValue("nsamples");
+
+    //inference_engine.ComputePosterior(); // do we need this
+
+    if (options.GetBoolValue("use_evidence"))
+    {
+        inference_engine.ComputeInsideESS();
+
+    for (int sample_ind = 0; sample_ind < N; sample_ind++) { 
+
+    solution = new SStruct(sstruct);
+    inference_engine.InitRand(sample_ind);
+
+    solution->SetMapping(inference_engine.PredictPairingsStochasticTracebackESS());
+    solution->WriteParensOnly(std::cout);
+    delete solution;
+    }
+
+    } else {
+        inference_engine.ComputeInside();
+    
+    for (int sample_ind = 0; sample_ind < N; sample_ind++) { 
+
+    solution = new SStruct(sstruct);
+    inference_engine.InitRand(sample_ind);
+
+    solution->SetMapping(inference_engine.PredictPairingsStochasticTraceback());
+    solution->WriteParensOnly(std::cout);
+    delete solution;
+    }
+    }
+
+}
 
 //////////////////////////////////////////////////////////////////////
 // ComputationEngine::MakeOutputFilename()
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.hpp b/./ComputationWrapper.hpp
index 1fe451b..13862ef 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.hpp
+++ b/./ComputationWrapper.hpp
@@ -52,6 +52,8 @@ public:
     RealT ComputeSolutionNormBound(const std::vector<int> &units, const std::vector<RealT> &C, RealT log_base);
     RealT ComputeGradientNormBound(const std::vector<int> &units, const std::vector<RealT> &C, RealT log_base);
     void Predict(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
+    void Sample(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
+    void RunREVI(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base, RealT sigma);
     RealT ComputeLoss(const std::vector<int> &units, const std::vector<RealT> &w, RealT log_base);
     RealT ComputeFunction(const std::vector<int> &units, const std::vector<RealT> &w, bool toggle_use_nonsmooth, bool toggle_use_loss, RealT log_base, RealT hyperparam_data);
     std::vector<RealT> ComputeGradient(const std::vector<int> &units, const std::vector<RealT> &w, bool toggle_use_nonsmooth, bool toggle_use_loss, RealT log_base, RealT hyperparam_data);
@@ -68,6 +70,7 @@ public:
     
     // for debugging
     void SanityCheckGradient(const std::vector<int> &units, const std::vector<RealT> &w);
+    void TestEnergies(const std::vector<int> &units, const std::vector<RealT> &w, RealT gamma, RealT log_base);
 
     // getters
     const Options &GetOptions() const { return computation_engine.GetOptions(); }
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.ipp b/./ComputationWrapper.ipp
index 4a1fa43..f6d803b 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/ComputationWrapper.ipp
+++ b/./ComputationWrapper.ipp
@@ -888,6 +888,118 @@ void ComputationWrapper<RealT>::Predict(const std::vector<int> &units,
     computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
 }
 
+//////////////////////////////////////////////////////////////////////
+// ComputationWrapper::Sample()
+//
+// Run sampling algorithm on each of the work units.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationWrapper<RealT>::Sample(const std::vector<int> &units,
+                                        const std::vector<RealT> &w,
+                                        RealT gamma,
+                                        RealT log_base)
+{
+    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
+    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
+
+    if (GetOptions().GetBoolValue("verbose_output"))
+    {
+        std::cerr << "Performing predictions with gamma=" << double(gamma) << "..." << std::endl;
+    }
+        
+    std::vector<RealT> ret;
+
+    shared_info.command = SAMPLE;
+    for (size_t i = 0; i < w.size(); i++)
+    {
+        shared_info.w[i] = w[i];
+    }
+    shared_info.gamma = gamma;
+    shared_info.log_base = log_base;
+    
+    nonshared_info.resize(units.size());
+    for (size_t i = 0; i < units.size(); i++)
+    {
+        nonshared_info[i].index = units[i];
+    }
+    
+    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
+}
+//////////////////////////////////////////////////////////////////////
+// ComputationWrapper::RunREVI()
+//
+// Run REVI on each of the work units.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationWrapper<RealT>::RunREVI(const std::vector<int> &units,
+                                        const std::vector<RealT> &w,
+                                        RealT gamma,
+                                        RealT log_base,
+                                        RealT sigma)
+{
+    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
+    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
+
+    if (GetOptions().GetBoolValue("verbose_output"))
+    {
+        std::cerr << "Performing predictions with gamma=" << double(gamma) << "..." << std::endl;
+    }
+        
+    std::vector<RealT> ret;
+
+    shared_info.command = REVI;
+    for (size_t i = 0; i < w.size(); i++)
+    {
+        shared_info.w[i] = w[i];
+    }
+    shared_info.gamma = gamma;
+    shared_info.log_base = log_base;
+    shared_info.sigma = sigma;
+    
+    nonshared_info.resize(units.size());
+    for (size_t i = 0; i < units.size(); i++)
+    {
+        nonshared_info[i].index = units[i];
+    }
+    
+    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
+}
+//////////////////////////////////////////////////////////////////////
+// ComputationWrapper::TestEnergies()
+//
+// Run energy test.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void ComputationWrapper<RealT>::TestEnergies(const std::vector<int> &units,
+                                        const std::vector<RealT> &w,
+                                        RealT gamma,
+                                        RealT log_base)
+{
+    Assert(computation_engine.IsMasterNode(), "Routine should only be called by master process.");
+    if (int(w.size()) > SHARED_PARAMETER_SIZE) Error("SHARED_PARAMETER_SIZE in Config.hpp too small; increase to at least %d.", int(w.size()));
+
+        
+    std::vector<RealT> ret;
+
+    shared_info.command = TEST_ENERGIES;
+    for (size_t i = 0; i < w.size(); i++)
+    {
+        shared_info.w[i] = w[i];
+    }
+    shared_info.gamma = gamma;
+    shared_info.log_base = log_base;
+    
+    nonshared_info.resize(units.size());
+    for (size_t i = 0; i < units.size(); i++)
+    {
+        nonshared_info[i].index = units[i];
+    }
+    
+    computation_engine.DistributeComputation(ret, shared_info, nonshared_info);
+}
 //////////////////////////////////////////////////////////////////////
 // ComputationWrapper::SanityCheckGradient()
 //
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Config.hpp b/./Config.hpp
index ea7a70a..775bccf 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Config.hpp
+++ b/./Config.hpp
@@ -179,6 +179,9 @@ const double MM_SMOOTHING = 1.0;
 #define PARAMS_EXTERNAL_LENGTH                     1
 #define PARAMS_EVIDENCE                            1  
 
+// Compile for using REVI or not
+#define USE_REVI									1
+
 /*
 #define PARAMS_BASE_PAIR                           1
 #define PARAMS_BASE_PAIR_DIST                      0
@@ -210,7 +213,7 @@ const double MM_SMOOTHING = 1.0;
 // (F) Miscellaneous model constants
 //////////////////////////////////////////////////////////////////////
 
-const int C_MIN_HAIRPIN_LENGTH = 0;
+const int C_MIN_HAIRPIN_LENGTH = 3;
 const int C_MAX_SINGLE_LENGTH = 30;
 
 const int D_MAX_HAIRPIN_LENGTH = 30;
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.cpp b/./Contrafold.cpp
index 992cf78..b574b23 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.cpp
+++ b/./Contrafold.cpp
@@ -17,6 +17,8 @@
 
 // constants
 const double GAMMA_DEFAULT = 6;
+const double KAPPA_DEFAULT = 1.0;
+const double SIGMA_DEFAULT = 1.0;
 const double REGULARIZATION_DEFAULT = 0;
 const int TRAIN_MAX_ITER_DEFAULT = 1000;
 const double HYPERPARAM_DATA_DEFAULT = 1;
@@ -30,12 +32,21 @@ void MakeFileDescriptions(const Options &options, const std::vector<std::string>
 template<class RealT>
 void RunGradientSanityCheck(const Options &options, const std::vector<FileDescription> &descriptions);
 
+template<class RealT>
+void RunEnergyTest(const Options &options, const std::vector<FileDescription> &descriptions);
+
 template<class RealT>
 void RunTrainingMode(const Options &options, const std::vector<FileDescription> &descriptions);
 
 template<class RealT>
 void RunPredictionMode(const Options &options, const std::vector<FileDescription> &descriptions);
 
+template<class RealT>
+void RunSampleMode(const Options &options, const std::vector<FileDescription> &descriptions);
+
+template<class RealT>
+void RunREVIMode(const Options &options, const std::vector<FileDescription> &descriptions);
+
 // default parameters
 #include "Defaults.ipp"
 
@@ -70,10 +81,20 @@ int main(int argc, char **argv)
     {
         RunGradientSanityCheck<double>(options, descriptions);
     }
+    else if (options.GetBoolValue("test_energies"))
+    {
+        RunEnergyTest<double>(options, descriptions);
+    }
     else if (options.GetStringValue("training_mode") != "")
     {
         RunTrainingMode<double>(options, descriptions);
     }
+    else if (options.GetBoolValue("run_sample_mode")){
+        RunSampleMode<double>(options, descriptions);
+    }
+    else if (options.GetBoolValue("run_revi_mode")){
+        RunREVIMode<double>(options, descriptions);
+    }
     else
     {
         RunPredictionMode<float>(options, descriptions);
@@ -93,7 +114,7 @@ int main(int argc, char **argv)
 void Usage(const Options &options)
 {
     std::cerr << std::endl
-              << "Usage: contrafold [predict|train|em-train] [OPTION]... INFILE(s)" << std::endl 
+              << "Usage: contrafold [predict|sample|train|em-train] [OPTION]... INFILE(s)" << std::endl 
               << std::endl
               << "       where [OPTION]...   is a list of zero or more optional arguments" << std::endl
               << "             INFILE(s)     is the name of the input BPSEQ, plain text, or FASTA file(s)" << std::endl 
@@ -122,9 +143,17 @@ void Usage(const Options &options)
               << "                           write posterior pairing probabilities to file or directory" << std::endl
               << "  --partition              compute the partition function or Viterbi score only" << std::endl
               << std::endl
+              << "Additional arguments for 'sample' mode:" <<std::endl
+              << "  --nsamples N             number of samples (default 100)" << std::endl
+              << "  --kappa k                weight to place on chemical mapping data (default 1.0)" << std::endl
+              << std::endl
+              << "Additional arguments for 'revi' mode:" <<std::endl
+              << "  --sigma S                weight to place on data vs. energy model" << std::endl
+              << std::endl
               << "Additional arguments for training (many input files may be specified):" << std::endl
               << "  --examplefile            read list of input files from provided text file (instead of as arguments)" << std::endl
               << "  --sanity                 perform gradient sanity check" << std::endl
+              << "  --test_energies          print energies.  Requires sequence and constraint string" << std::endl
               << "  --holdout F              use fraction F of training data for holdout cross-validation" << std::endl
               << "  --regularize C           perform BFGS training, using a single regularization coefficient C" << std::endl
               << "  --maxiter N              for single regularization coefficient the max number of iterations" << std::endl
@@ -168,6 +197,8 @@ void ParseArguments(int argc,
 {
     // register default options
     options.SetStringValue("training_mode", "");
+    options.SetBoolValue("run_sample_mode",false);
+    options.SetBoolValue("run_revi_mode",false);
 
     options.SetBoolValue("verbose_output", false);
     options.SetRealValue("log_base", 1.0);
@@ -179,6 +210,8 @@ void ParseArguments(int argc,
     options.SetBoolValue("centroid_estimator", false);
     options.SetBoolValue("use_evidence", false);
     options.SetRealValue("gamma", GAMMA_DEFAULT);
+    options.SetRealValue("kappa", KAPPA_DEFAULT);
+    options.SetRealValue("sigma", KAPPA_DEFAULT);
     options.SetStringValue("output_parens_destination", "");
     options.SetStringValue("output_bpseq_destination", "");
     options.SetRealValue("output_posteriors_cutoff", 0);
@@ -186,6 +219,7 @@ void ParseArguments(int argc,
     options.SetBoolValue("partition_function_only", false);
 
     options.SetBoolValue("gradient_sanity_check", false);
+    options.SetBoolValue("test_energies", false);
     options.SetRealValue("holdout_ratio", 0);
     options.SetRealValue("regularization_coefficient", REGULARIZATION_DEFAULT);
 
@@ -198,6 +232,7 @@ void ParseArguments(int argc,
     options.SetRealValue("s0", 0.0001);
     options.SetRealValue("s1", 0);
     options.SetRealValue("hyperparam_data",HYPERPARAM_DATA_DEFAULT);
+    options.SetIntValue("nsamples",100);
 
     // check for sufficient arguments
     if (argc < 2) Usage(options);
@@ -216,9 +251,17 @@ void ParseArguments(int argc,
     {
         options.SetStringValue("training_mode", "em-sgd");
     }
+    else if (!strcmp(argv[1], "sample"))
+    {
+        options.SetBoolValue("run_sample_mode",true);
+    }
+    else if (!strcmp(argv[1], "revi"))
+    {
+        options.SetBoolValue("run_revi_mode",true);
+    }
     else if (strcmp(argv[1], "predict"))
     {
-        Error("CONTRAfold must be run in either 'predict' or 'train' mode.");
+        Error("CONTRAfold must be run in either 'predict', 'train', or 'sample' mode.");
     }
 
     // go through remaining arguments
@@ -281,6 +324,22 @@ void ParseArguments(int argc,
                     Error("Unable to parse value after --gamma.");
                 options.SetRealValue("gamma", value);
             }
+            else if (!strcmp(argv[argno], "--kappa"))
+            {
+                if (argno == argc - 1) Error("Must specify chemical mapping reweighting parameter KAPPA after --kappa.");
+                double value;
+                if (!ConvertToNumber(argv[++argno], value))
+                    Error("Unable to parse value after --kappa.");
+                options.SetRealValue("kappa", value);
+            }
+            else if (!strcmp(argv[argno], "--sigma"))
+            {
+                if (argno == argc - 1) Error("Must specify data reweighting parameter SIGMA after --sigma.");
+                double value;
+                if (!ConvertToNumber(argv[++argno], value))
+                    Error("Unable to parse value after --sigma.");
+                options.SetRealValue("sigma", value);
+            }
             else if (!strcmp(argv[argno], "--parens"))
             {
                 if (argno == argc - 1) Error("Must specify output file or directory name after --parens.");
@@ -316,6 +375,10 @@ void ParseArguments(int argc,
             {
                 options.SetBoolValue("gradient_sanity_check", true);
             }
+            else if (!strcmp(argv[argno], "--test_energies"))
+            {
+                options.SetBoolValue("test_energies", true);
+            }
             else if (!strcmp(argv[argno], "--holdout"))
             {
                 if (argno == argc - 1) Error("Must specify holdout ratio F after --holdout.");
@@ -346,6 +409,16 @@ void ParseArguments(int argc,
                     Error("Max number of iterations should not be negative.");
                 options.SetIntValue("train_max_iter", value);
             }
+            else if (!strcmp(argv[argno], "--nsamples"))
+            {
+                if (argno == argc - 1) Error("Must specify number of samples after --nsamples.");
+                int value;
+                if (!ConvertToNumber(argv[++argno], value))
+                    Error("Unable to parse max number of iterations after --nsamples.");
+                if (value < 0)
+                    Error("Number of samples should not be negative.");
+                options.SetIntValue("nsamples", value);
+            }
             else if (!strcmp(argv[argno], "--hyperparam_data"))
             {
                 if (argno == argc - 1) Error("Must specify a value after --hyperparam_data.");
@@ -537,6 +610,83 @@ void MakeFileDescriptions(const Options &options,
     std::sort(descriptions.begin(), descriptions.end());
 
 }
+/////////////////////////////////////////////////////////////////
+// RunEnergyTest()
+//
+// Print energies for test sequence.
+/////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void RunEnergyTest(const Options &options,
+                            const std::vector<FileDescription> &descriptions)
+{
+    // The architecture of the code is somewhat complicated here, so
+    // here's a quick explanation:
+    // 
+    //    ParameterManager: associates each parameter of the model
+    //                      with a name and manages hyperparameter
+    //                      groups
+    //                     
+    //    InferenceEngine: performs application-specific
+    //                     (loss-augmented) inference
+    //
+    //    ComputationEngine: makes all necessary calls to dynamic
+    //                       programming routines for processing
+    //                       individual sequences and interfaces with
+    //                       distributed computation module
+    //
+    //    ComputationWrapper: provides a high-level interface for
+    //                        performing computations on groups of
+    //                        sequences
+    //
+    //    OuterOptimizationWrapper / InnerOptimizationWrapper:
+    //                        interface between computation routines
+    //                        and optimization routines
+    
+   ParameterManager<RealT> parameter_manager;
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),
+        options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+    inference_engine.RegisterParameters(parameter_manager);
+    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+    ComputationWrapper<RealT> computation_wrapper(computation_engine);
+    
+    // decide whether I'm a compute node or master node
+    if (computation_engine.IsComputeNode())
+    {
+        computation_engine.RunAsComputeNode();
+        return;
+    }
+
+    const std::string output_parens_destination = options.GetStringValue("output_parens_destination");
+    const std::string output_bpseq_destination = options.GetStringValue("output_bpseq_destination");
+    const std::string output_posteriors_destination = options.GetStringValue("output_posteriors_destination");
+
+    // load parameters
+    std::vector<RealT> w;
+
+    if (options.GetStringValue("parameter_filename") != "")
+    {
+        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
+    }
+    else
+    {
+#if PROFILE
+        w = GetDefaultProfileValues<RealT>();
+#else
+        if (options.GetBoolValue("allow_noncomplementary"))
+            w = GetDefaultNoncomplementaryValues<RealT>();
+        else
+            w = GetDefaultComplementaryValues<RealT>();
+#endif
+    }
+
+    
+        // create output directories for output files, if needed
+
+    computation_wrapper.TestEnergies(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"));
+    
+    computation_engine.StopComputeNodes();
+}
 
 /////////////////////////////////////////////////////////////////
 // RunGradientSanityCheck()
@@ -572,7 +722,8 @@ void RunGradientSanityCheck(const Options &options,
     //                        and optimization routines
     
     ParameterManager<RealT> parameter_manager;
-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),
+        options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
     inference_engine.RegisterParameters(parameter_manager);
     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
     ComputationWrapper<RealT> computation_wrapper(computation_engine);
@@ -614,7 +765,7 @@ void RunTrainingMode(const Options &options,
                      const std::vector<FileDescription> &descriptions)
 {
     ParameterManager<RealT> parameter_manager;
-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
     inference_engine.RegisterParameters(parameter_manager);
     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
     ComputationWrapper<RealT> computation_wrapper(computation_engine);
@@ -708,7 +859,7 @@ void RunPredictionMode(const Options &options,
                        const std::vector<FileDescription> &descriptions)
 {
     ParameterManager<RealT> parameter_manager;
-    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"));
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
     inference_engine.RegisterParameters(parameter_manager);
     ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
     ComputationWrapper<RealT> computation_wrapper(computation_engine);
@@ -793,3 +944,102 @@ void RunPredictionMode(const Options &options,
     }
     computation_engine.StopComputeNodes();
 }
+
+/////////////////////////////////////////////////////////////////
+// RunSampleMode()
+//
+// Run CONTRAfold in sample mode.
+/////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void RunSampleMode(const Options &options,
+                       const std::vector<FileDescription> &descriptions)
+{
+    ParameterManager<RealT> parameter_manager;
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+    inference_engine.RegisterParameters(parameter_manager);
+    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+    ComputationWrapper<RealT> computation_wrapper(computation_engine);
+    
+    // decide whether I'm a compute node or master node
+    if (computation_engine.IsComputeNode())
+    {
+        computation_engine.RunAsComputeNode();
+        return;
+    }
+
+    // const std::string output_parens_destination = options.GetStringValue("output_parens_destination");
+    // const std::string output_bpseq_destination = options.GetStringValue("output_bpseq_destination");
+    // const std::string output_posteriors_destination = options.GetStringValue("output_posteriors_destination");
+
+    // load parameters
+    std::vector<RealT> w;
+
+    if (options.GetStringValue("parameter_filename") != "")
+    {
+        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
+    }
+    else
+    {
+#if PROFILE
+        w = GetDefaultProfileValues<RealT>();
+#else
+        if (options.GetBoolValue("allow_noncomplementary"))
+            w = GetDefaultNoncomplementaryValues<RealT>();
+        else
+            w = GetDefaultComplementaryValues<RealT>();
+#endif
+    }
+
+        
+    computation_wrapper.Sample(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"));
+    
+    computation_engine.StopComputeNodes();
+}
+
+/////////////////////////////////////////////////////////////////
+// RunREVIMode()
+//
+// Run REVI.
+/////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void RunREVIMode(const Options &options,
+                       const std::vector<FileDescription> &descriptions)
+{
+    ParameterManager<RealT> parameter_manager;
+    InferenceEngine<RealT> inference_engine(options.GetBoolValue("allow_noncomplementary"),options.GetIntValue("num_data_sources"), options.GetRealValue("kappa"));
+    inference_engine.RegisterParameters(parameter_manager);
+    ComputationEngine<RealT> computation_engine(options, descriptions, inference_engine, parameter_manager);
+    ComputationWrapper<RealT> computation_wrapper(computation_engine);
+    
+    // decide whether I'm a compute node or master node
+    if (computation_engine.IsComputeNode())
+    {
+        computation_engine.RunAsComputeNode();
+        return;
+    }
+
+    // load parameters
+    std::vector<RealT> w;
+
+    if (options.GetStringValue("parameter_filename") != "")
+    {
+        parameter_manager.ReadFromFile(options.GetStringValue("parameter_filename"), w);
+    }
+    else
+    {
+#if PROFILE
+        w = GetDefaultProfileValues<RealT>();
+#else
+        if (options.GetBoolValue("allow_noncomplementary"))
+            w = GetDefaultNoncomplementaryValues<RealT>();
+        else
+            w = GetDefaultComplementaryValues<RealT>();
+#endif
+    }
+
+    computation_wrapper.RunREVI(computation_wrapper.GetAllUnits(), w, options.GetRealValue("gamma"), options.GetRealValue("log_base"), options.GetRealValue("sigma"));
+    
+    computation_engine.StopComputeNodes();
+}
\ No newline at end of file
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.o b/./Contrafold.o
index 00a11ca..3f458d0 100644
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/Contrafold.o and b/./Contrafold.o differ
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.hpp b/./InferenceEngine.hpp
index 4818ec2..1f0295d 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.hpp
+++ b/./InferenceEngine.hpp
@@ -13,6 +13,7 @@
 #include "ParameterManager.hpp"
 #include "Utilities.hpp"
 #include "LogSpace.hpp"
+#include "rand.h"
 
 //////////////////////////////////////////////////////////////////////
 // class InferenceEngine
@@ -23,12 +24,14 @@ class InferenceEngine
 {
     static const double DATA_LOW_THRESH = 1e-7;  // used for the data so that log is not -Inf
 
+    const double kappa;
     const bool allow_noncomplementary;
     unsigned char char_mapping[256];
     int is_complementary[M+1][M+1];
     bool cache_initialized;
     ParameterManager<RealT> *parameter_manager;
-    
+    Die* die;
+
     int num_data_sources;
     // dimensions
     int L, SIZE;
@@ -307,7 +310,7 @@ class InferenceEngine
 public:
 
     // constructor and destructor
-    InferenceEngine(bool allow_noncomplementary, const int num_data_sources);
+    InferenceEngine(bool allow_noncomplementary, const int num_data_sources, const double kappa);
     ~InferenceEngine();
 
     // register params with the parameter manager
@@ -331,6 +334,9 @@ public:
     std::vector<int> PredictPairingsViterbi() const;
     std::vector<RealT> ComputeViterbiFeatureCounts();
 
+    void GetViterbiFeatures();
+    void GetViterbiFeaturesESS();
+
     // MEA inference
     void ComputeInside();
     RealT ComputeLogPartitionCoefficient() const;
@@ -340,6 +346,11 @@ public:
     std::vector<int> PredictPairingsPosterior(const RealT gamma) const;
     std::vector<int> PredictPairingsPosteriorCentroid(const RealT gamma) const;
     RealT *GetPosterior(const RealT posterior_cutoff) const;
+
+    // stoch traceback
+    void InitRand(unsigned int seed);
+    std::vector<int> PredictPairingsStochasticTraceback() const;
+    std::vector<int> PredictPairingsStochasticTracebackESS() const;
     
     // EM inference
     void ComputeInsideESS();
@@ -349,6 +360,13 @@ public:
     RealT ComputeLogPartitionCoefficientESS() const;
     std::vector<RealT> ComputeESS();    
 
+    //REVI
+    void UpdateREVIVec(std::vector<RealT> perturb_unpaired, std::vector<RealT> perturb_paired);
+    void InitializeREVIVec();
+    std::vector<RealT> GetREVIError(std::vector<RealT> p_i);
+    std::vector<std::vector<double> > GetREVIvec_up();
+    std::vector<std::vector<double> > GetREVIvec_pr();
+
     // Learning Evidence CPD
     RealT ComputeGammaMLESum(std::vector<int> ev_cpd_id, bool ignorePairing, bool usePosterior, int which_data);
     std::vector<RealT> ComputeGammaMLESS(std::vector<int> ev_cpd_id, bool ignoreZeros, bool useMLE, int which_data);

#HKWS: GOT HERE

diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.ipp b/./InferenceEngine.ipp
index def37bb..a32fb22 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/InferenceEngine.ipp
+++ b/./InferenceEngine.ipp
@@ -42,7 +42,7 @@ RealT InferenceEngine<RealT>::ScoreUnpairedPositionEvidence(int i) const
 {
    RealT sum = 0;
    for (int n = 0; n < num_data_sources; n++)
-       sum = sum + score_unpaired_position[n][i-1];
+       sum = sum + kappa*score_unpaired_position[n][i-1]; // FLAG: put scalar here
    return sum;
 }
 #else
@@ -59,7 +59,7 @@ RealT InferenceEngine<RealT>::ScorePairedPositionEvidence(int i) const
 {
    RealT sum = 0;
    for (int n = 0; n < num_data_sources; n++)
-       sum = sum + score_paired_position[n][i-1];
+       sum = sum + kappa*score_paired_position[n][i-1]; // FLAG: put scalar here
    return sum;
 }
 #else
@@ -307,11 +307,12 @@ bool InferenceEngine<RealT>::IsComplementary(int i, int j) const
 //////////////////////////////////////////////////////////////////////
 
 template<class RealT>
-InferenceEngine<RealT>::InferenceEngine(bool allow_noncomplementary, const int num_data_sources) :
+InferenceEngine<RealT>::InferenceEngine(bool allow_noncomplementary, const int num_data_sources, const double kappa) :
     allow_noncomplementary(allow_noncomplementary),
     cache_initialized(false),
     parameter_manager(NULL),
     num_data_sources(num_data_sources),
+    kappa(kappa),
     L(0),
     SIZE(0)
 #if PROFILE
@@ -946,6 +947,79 @@ double InferenceEngine<RealT>::LogGammaProb(RealT data, int which_data, int isUn
     return (k-1)*log(data) - data/theta - lgamma(k) - k*log(theta);
 }
 
+template<class RealT>
+void InferenceEngine<RealT>::UpdateREVIVec(std::vector<RealT> perturb_unpaired, std::vector<RealT> perturb_paired)
+{
+    int which_data = 0; // update if we ever want to do more than one
+
+    for (int i = 0; i < L; i++)
+    {
+        score_unpaired_position[which_data][i] += perturb_unpaired[i];
+        //score_paired_position[which_data][i] += perturb_paired[i];
+    }
+
+    std::cerr << "u_v " << score_unpaired_position[0] << std::endl;
+    std::cerr << "p_v " << score_paired_position[0] << std::endl;
+
+}
+
+template<class RealT>
+std::vector<std::vector<double> > InferenceEngine<RealT>::GetREVIvec_up()
+{
+    return score_unpaired_position;
+}
+
+template<class RealT>
+std::vector<std::vector<double> > InferenceEngine<RealT>::GetREVIvec_pr()
+{
+    return score_paired_position;
+}
+
+template<class RealT>
+std::vector<RealT> InferenceEngine<RealT>::GetREVIError(std::vector<RealT> p_i)
+{
+    int which_data = 0;
+    std::vector<RealT> error;
+
+     for (int i = 0; i < L; i++)
+     {
+
+        // analytical posterior
+    //     RealT pos_paired = 0;
+    //     // get paired posterior
+    //     for (int l = 1; l <= L; l++)
+    //     {
+    //             int offset1 = i <= l ? i : l;
+    //             int offset2 = i > l ? i : l;
+    //             if (i != l)
+    //                 pos_paired += posterior[offset[offset1]+offset2];
+    //     }
+    //     // if (i==1){
+    //     //     std::cerr << "pos_paired " << pos_paired << std::endl;
+    //     // }
+
+    // HWS: reintroduce when using reactivities instead of probabilities
+
+    // RealT k_pr = exp(log_score_evidence[which_data][0][s[i+1]][0].first);
+    // RealT theta_pr = exp(log_score_evidence[which_data][1][s[i+1]][0].first);
+    // RealT k_unp = exp(log_score_evidence[which_data][0][s[i+1]][1].first);
+    // RealT theta_unp = exp(log_score_evidence[which_data][1][s[i+1]][1].first);
+
+        // predict reactivity under this model
+        //RealT rhat = k_pr*theta_pr*(1-p_i[i]) + k_unp*theta_unp*p_i[i];
+        //score_unpaired_position_raw: where raw reacitivty data is stored
+
+        // fitting to raw diff in p(unp values)
+        RealT err = (p_i[i] - score_unpaired_position_raw[which_data][i]);
+
+        error.push_back(err);
+}
+    std::cerr << "sc_up_p_raw " << score_unpaired_position_raw[which_data] << std::endl;
+    return error;
+    
+}
+
+  
 
 //////////////////////////////////////////////////////////////////////
 // InferenceEngine::LoadSequence()
@@ -966,7 +1040,6 @@ void InferenceEngine<RealT>::LoadSequence(const SStruct &sstruct)
     SIZE2 = (L+1)*(L+1);
 #endif
 
-    
     // allocate memory
     s.resize(L+1);
 #if PROFILE
@@ -1120,8 +1193,23 @@ void InferenceEngine<RealT>::LoadSequence(const SStruct &sstruct)
     score_paired_position = 1-sstruct.GetPairedPotentials();  // probability of paired = 1 - probability of unpaired (NOTE: currently PairedPotentials returns the probability of unpaired, so need the "1-" in front
 #endif
 
+
 }
 
+template<class RealT>
+void InferenceEngine<RealT>::InitializeREVIVec()
+{    
+    score_unpaired_position[0].clear();
+    score_paired_position[0].clear();
+    for (int i = 0; i < num_data_sources; i++)
+    {
+        for (int j = 0; j < L; j++)
+    {
+    score_unpaired_position[i].push_back(RealT(0));
+    score_paired_position[i].push_back(RealT(0));
+    }
+}
+}
 
 template<class RealT>
 void InferenceEngine<RealT>::UpdateEvidenceStructures()
@@ -1148,6 +1236,7 @@ void InferenceEngine<RealT>::UpdateEvidenceStructures(int which_data)
     }
 }
 
+
 //////////////////////////////////////////////////////////////////////
 // InferenceEngine::InitializeCache()
 //
@@ -3929,9 +4018,8 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
 {
     std::queue<triple<int *,int,int> > traceback_queue;
     traceback_queue.push(make_triple(&F5t[0], 0, L));
-
     ClearCounts();
-    
+
     while (!traceback_queue.empty())
     {
         triple<int *,int,int> t = traceback_queue.front();
@@ -3947,6 +4035,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
         
         switch (traceback.first)
         {
+
 #if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
             case TB_FN_HAIRPIN: 
                 CountHairpin(i,j,RealT(1));
@@ -3956,6 +4045,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
                 const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
                 CountSingle(i,j,p,q,RealT(1));
+
                 traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
             }
             break;
@@ -3965,6 +4055,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 CountJunctionA(i,j,RealT(1));
                 CountMultiPaired(RealT(1));
                 CountMultiBase(RealT(1));
+
                 traceback_queue.push(make_triple(&FM1t[0], i, k));
                 traceback_queue.push(make_triple(&FMt[0], k, j));
             }
@@ -3973,6 +4064,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
             {
                 CountBasePair(i+1,j,RealT(1));
                 CountHelixStacking(i,j+1,RealT(1));
+
                 traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
             }
             break;
@@ -4001,9 +4093,11 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
             }
             break;
+
 #else
             case TB_FC_HAIRPIN: 
                 CountHairpin(i,j,RealT(1));
+
                 break;
             case TB_FC_SINGLE: 
             {
@@ -4018,6 +4112,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 else
                 {
                     CountSingle(i,j,p,q,RealT(1));
+
                 }
                 
                 traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
@@ -4029,6 +4124,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 CountJunctionA(i,j,RealT(1));
                 CountMultiPaired(RealT(1));
                 CountMultiBase(RealT(1));
+
                 traceback_queue.push(make_triple(&FM1t[0], i, k));
                 traceback_queue.push(make_triple(&FMt[0], k, j));
             }
@@ -4039,12 +4135,14 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 CountJunctionA(j,i,RealT(1));
                 CountMultiPaired(RealT(1));
                 CountBasePair(i+1,j,RealT(1));
+
                 traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
             }
             break;
             case TB_FM1_UNPAIRED:
             {
                 CountMultiUnpaired(i+1,RealT(1));
+
                 traceback_queue.push(make_triple(&FM1t[0], i+1, j));
             }
             break;
@@ -4058,6 +4156,7 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
             case TB_FM_UNPAIRED:
             {
                 CountMultiUnpaired(j,RealT(1));
+
                 traceback_queue.push(make_triple(&FMt[0], i, j-1));
             }
             break;
@@ -4068,25 +4167,706 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeViterbiFeatureCounts()
                 break;
             case TB_F5_UNPAIRED:
                 CountExternalUnpaired(j,RealT(1));
+
+                traceback_queue.push(make_triple(&F5t[0], 0, j-1));
+                break;
+            case TB_F5_BIFURCATION:
+            {
+                const int k = traceback.second;
+                CountExternalPaired(RealT(1));
+                CountBasePair(k+1,j,RealT(1));
+                CountJunctionA(j,k,RealT(1));
+                traceback_queue.push(make_triple(&F5t[0], 0, k));
+                traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
+
+
+            }
+            break;
+            default:
+                Assert(false, "Bad traceback.");
+        }
+    }
+
+    FinalizeCounts();
+    return GetCounts();
+}
+
+//////////////////////////////////////////////////////////////////////
+// InferenceEngine::GetViterbiFeatures()
+// 
+// Use feature counts from Viterbi decoding.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void InferenceEngine<RealT>::GetViterbiFeatures()
+{
+    std::queue<triple<int *,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(&F5t[0], 0, L));
+
+    std::vector<triple<int, int, int> > multiloops;
+    ClearCounts();
+
+    std::map<int, RealT> eos_cb_map;
+    for (int k = -1; k <= L; k++){
+        eos_cb_map[k] = 0;
+    }
+
+    while (!traceback_queue.empty())
+    {
+        triple<int *,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int *V = t.first;
+        const int i = t.second;
+        const int j = t.third;
+        
+        std::pair<int,int> traceback = DecodeTraceback (V == &F5t[0] ? V[j] : V[offset[i]+j]);
+        
+        //std::cout << (V == FCt ? "FC " : V == FMt ? "FM " : V == FM1t ? "FM1 " : "F5 ");
+        //std::cout << i << " " << j << ": " << traceback.first << " " << traceback.second << std::endl;
+        
+        switch (traceback.first)
+        {
+
+    // HWS: we're not using these params
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case TB_FN_HAIRPIN: 
+                CountHairpin(i,j,RealT(1));
+                break;
+            case TB_FN_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                CountSingle(i,j,p,q,RealT(1));
+
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FN_BIFURCATION:
+            {
+                const int k = traceback.second;
+                CountJunctionA(i,j,RealT(1));
+                CountMultiPaired(RealT(1));
+                CountMultiBase(RealT(1));
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FE_STACKING: 
+            {
+                CountBasePair(i+1,j,RealT(1));
+                CountHelixStacking(i,j+1,RealT(1));
+
+                traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
+            }
+            break;
+            case TB_FE_FN: 
+            {
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_FN:
+            {
+                CountIsolated(RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_HELIX:
+            {
+                const int m = traceback.second;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i+m-1, j-m+1));
+            }
+            break;
+            case TB_FC_FE:
+            {
+                const int m = D_MAX_HELIX_LENGTH;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
+            }
+            break;
+
+    //HWS: our param sections start here
+#else
+            case TB_FC_HAIRPIN: 
+                //CountHairpin(i,j,RealT(1));
+                //////////////////////////////////////////////////////////////////////
+                // InferenceEngine::ScoreHairpin()
+                // InferenceEngine::CountHairpin()
+                //
+                // Returns the score for a hairpin spanning positions i to j.
+                //
+                // In an RNA structure, this would look like
+                //
+                //                           ...
+                //                       /         \. 
+                //                   x[i+2]       x[j-1]
+                //                      |            |
+                //                   x[i+1]        x[j]
+                // position i -------->  o          o  <----- position j
+                //                      x[i] -- x[j+1]
+                //                        |        |
+                //                     x[i-1] -- x[j+2]
+                //
+                //////////////////////////////////////////////////////////////////////
+
+                //HWS: subtracting off 1 to get zero-indexing for eos_cb
+
+                //std::cerr << "Hairpin " << i-1 << " " << ScoreHairpin(i,j) << std::endl;
+                eos_cb_map[i-1] += ScoreHairpin(i,j);
+
+                break;
+            case TB_FC_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+
+                if (p == i && q == j)
+                {
+                    // CountBasePair(i+1,j,RealT(1));
+                    // CountHelixStacking(i,j+1,RealT(1));
+
+                //HWS: subtracting off 1 (from i+1) to get zero-indexing for eos_cb
+
+
+                //std::cerr << "BasePair " << i << " " << ScoreBasePair(i+1,j) << std::endl;
+                eos_cb_map[i] += ScoreBasePair(i+1,j);
+
+
+                // ScoreHelixStacking(i,j): score for a helix stacking pair of the form:
+                //
+                //       |         |
+                //    s[i+1] == s[j-1]
+                //       |         |
+                //     s[i] ==== s[j]
+                //       |         |
+                //HWS: subtracting off 1 (from i) to get zero-indexing for eos_cb
+
+                //std::cerr << "HelixStacking " << i-1 << " " << ScoreHelixStacking(i,j+1) << std::endl;
+                eos_cb_map[i-1] += ScoreHelixStacking(i,j+1);
+
+                }
+                else
+                {
+                    //CountSingle(i,j,p,q,RealT(1));
+                    //here we need to break this down because they sum a bunch of things to make ScoreSingle
+                    // here we need to subtract off the second base pair from ScoreSingle
+                // std::cerr << "Single " << i-1 << " " << ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q) << std::endl;
+                // std::cerr << "ScoreBasePair " << p << " " << ScoreBasePair(p+1,q) << std::endl;
+
+                eos_cb_map[i-1] += ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q);
+                eos_cb_map[p] += ScoreBasePair(p+1, q);
+
+                }
+                
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FC_BIFURCATION:
+            {
+                const int k = traceback.second;
+                // CountJunctionA(i,j,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountMultiBase(RealT(1));
+
+                // This is where we first recognize we're in a new multiloop. Store the things at i
+                multiloops.push_back(make_triple(i,j,0));
+                // std::cerr << "New multiloop! " << i << ":" << j << std::endl;
+
+                // std::cerr << "FCBifurc:JunctionA " << i << " " << ScoreJunctionA(i,j) << std::endl;
+                // std::cerr << "FCBifurc:MultiPaired " << i << " " << ScoreMultiPaired() << std::endl;
+                // std::cerr << "FCBifurc:MultiBase " << i << " " << ScoreMultiBase() << std::endl;
+
+                eos_cb_map[i] += ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+#endif
+            case TB_FM1_PAIRED:
+            {
+                // CountJunctionA(j,i,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountBasePair(i+1,j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i < multiloops[ind].second){
+                        if (i - multiloops[ind].first < min_dist){
+                            min_dist = i - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+
+                // These all go in the multiloop ind
+                //std::cerr << "Paired:JunctionA " << curr_multiloop_ind << " " << ScoreJunctionA(j,i) << std::endl;
+                //std::cerr << "Paired:MultiPaired " << curr_multiloop_ind << " " << ScoreMultiPaired() << std::endl;
+                
+                eos_cb_map[curr_multiloop_ind] += ScoreJunctionA(j,i) + ScoreMultiPaired();
+
+                //This just goes with the next base pair
+                //std::cerr << "Paired:BasePair " << i << " " << ScoreBasePair(i+1, j) << std::endl;
+                eos_cb_map[i] += ScoreBasePair(i+1, j);
+
+                traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
+            }
+            break;
+            case TB_FM1_UNPAIRED:
+            {
+                // CountMultiUnpaired(i+1,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i+1 < multiloops[ind].second){
+                        if (i+1 - multiloops[ind].first < min_dist){
+                            min_dist = i+1 - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(i+1) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpaired(i+1);
+
+                traceback_queue.push(make_triple(&FM1t[0], i+1, j));
+            }
+            break;
+            case TB_FM_BIFURCATION:
+            {
+                const int k = traceback.second;
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FM_UNPAIRED:
+            {
+                // CountMultiUnpaired(j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < j < multiloops[ind].second){
+                        if (j - multiloops[ind].first < min_dist){
+                            min_dist = j - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(j) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpaired(j);
+
+                traceback_queue.push(make_triple(&FMt[0], i, j-1));
+            }
+            break;
+            case TB_FM_FM1: 
+                traceback_queue.push(make_triple(&FM1t[0], i, j));
+                break;
+            case TB_F5_ZERO:
+                break;
+            case TB_F5_UNPAIRED:
+                CountExternalUnpaired(j,RealT(1));
+
+                // HWS: a score for unpaired things in the external loop, dump into the -1 eos_cb
+
+                //std::cerr << "ExternalUnpaired -1 " << ScoreExternalUnpaired(j) << std::endl;
+                eos_cb_map[-1] += ScoreExternalUnpaired(j);
+
+                traceback_queue.push(make_triple(&F5t[0], 0, j-1));
+                break;
+            case TB_F5_BIFURCATION:
+            {
+                const int k = traceback.second;
+                // CountExternalPaired(RealT(1));
+                // CountBasePair(k+1,j,RealT(1));
+                // CountJunctionA(j,k,RealT(1));
+                traceback_queue.push(make_triple(&F5t[0], 0, k));
+                traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
+
+                //HWS: this is base pairs facing external loop. Hard-coding to print -1 as thinking these 
+                //should get summed in to the -1 "external loop " eos_cb category
+                
+                //std::cerr << "F5Bifurc:ExternalPaired -1 " << ScoreExternalPaired() << std::endl;
+                //std::cerr << "F5Bifurc:JunctionA -1 " << ScoreJunctionA(j,k) << std::endl;
+                eos_cb_map[-1] += ScoreExternalPaired()+ScoreJunctionA(j,k);
+
+                // HWS: another base pair, print (k+1) - 1 to zero-index
+                //std::cerr << "F5Bifurc:BasePair " << k << " " << ScoreBasePair(k+1, j) << std::endl;
+                eos_cb_map[k] += ScoreBasePair(k+1, j);
+
+            }
+            break;
+            default:
+                Assert(false, "Bad traceback.");
+        }
+    }
+    RealT local_sum = 0;
+    std::cerr << "EOS_CB: ";
+    for (std::pair<int, RealT> element : eos_cb_map) {
+        if (element.first == -1 || element.second != 0){
+        std::cerr << element.first << ", " << element.second << ", ";
+        local_sum += element.second;
+    }
+    }
+    std::cerr << std::endl;
+    std::cerr << "local sum " << local_sum << std::endl;
+
+}
+
+//////////////////////////////////////////////////////////////////////
+// InferenceEngine::GetViterbiFeaturesESS()
+// 
+// Use feature counts from Viterbi decoding, using evidence-based energies.
+//////////////////////////////////////////////////////////////////////
+
+template<class RealT>
+void InferenceEngine<RealT>::GetViterbiFeaturesESS()
+{
+    std::queue<triple<int *,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(&F5t[0], 0, L));
+
+    std::vector<triple<int, int, int> > multiloops;
+    ClearCounts();
+
+    std::map<int, RealT> eos_cb_map;
+    for (int k = -1; k <= L; k++){
+        eos_cb_map[k] = 0;
+    }
+
+    while (!traceback_queue.empty())
+    {
+        triple<int *,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int *V = t.first;
+        const int i = t.second;
+        const int j = t.third;
+        
+        std::pair<int,int> traceback = DecodeTraceback (V == &F5t[0] ? V[j] : V[offset[i]+j]);
+        
+        //std::cout << (V == FCt ? "FC " : V == FMt ? "FM " : V == FM1t ? "FM1 " : "F5 ");
+        //std::cout << i << " " << j << ": " << traceback.first << " " << traceback.second << std::endl;
+        
+        switch (traceback.first)
+        {
+
+    // HWS: we're not using these params
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case TB_FN_HAIRPIN: 
+                CountHairpin(i,j,RealT(1));
+                break;
+            case TB_FN_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                CountSingle(i,j,p,q,RealT(1));
+
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FN_BIFURCATION:
+            {
+                const int k = traceback.second;
+                CountJunctionA(i,j,RealT(1));
+                CountMultiPaired(RealT(1));
+                CountMultiBase(RealT(1));
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FE_STACKING: 
+            {
+                CountBasePair(i+1,j,RealT(1));
+                CountHelixStacking(i,j+1,RealT(1));
+
+                traceback_queue.push(make_triple(&FEt[0], i+1, j-1));
+            }
+            break;
+            case TB_FE_FN: 
+            {
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_FN:
+            {
+                CountIsolated(RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i, j));
+            }
+            break;
+            case TB_FC_HELIX:
+            {
+                const int m = traceback.second;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FNt[0], i+m-1, j-m+1));
+            }
+            break;
+            case TB_FC_FE:
+            {
+                const int m = D_MAX_HELIX_LENGTH;
+                CountHelix(i-1,j+1,m,RealT(1));
+                traceback_queue.push(make_triple(&FEt[0], i+m-1, j-m+1));
+            }
+            break;
+
+    //HWS: our param sections start here
+#else
+            case TB_FC_HAIRPIN: 
+                //CountHairpin(i,j,RealT(1));
+                //////////////////////////////////////////////////////////////////////
+                // InferenceEngine::ScoreHairpin()
+                // InferenceEngine::CountHairpin()
+                //
+                // Returns the score for a hairpin spanning positions i to j.
+                //
+                // In an RNA structure, this would look like
+                //
+                //                           ...
+                //                       /         \. 
+                //                   x[i+2]       x[j-1]
+                //                      |            |
+                //                   x[i+1]        x[j]
+                // position i -------->  o          o  <----- position j
+                //                      x[i] -- x[j+1]
+                //                        |        |
+                //                     x[i-1] -- x[j+2]
+                //
+                //////////////////////////////////////////////////////////////////////
+
+                //HWS: subtracting off 1 to get zero-indexing for eos_cb
+
+                //std::cerr << "Hairpin " << i-1 << " " << ScoreHairpin(i,j) << std::endl;
+                eos_cb_map[i-1] += ScoreHairpinEvidence(i,j);
+
+                break;
+            case TB_FC_SINGLE: 
+            {
+                const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+
+                if (p == i && q == j)
+                {
+                    // CountBasePair(i+1,j,RealT(1));
+                    // CountHelixStacking(i,j+1,RealT(1));
+
+                //HWS: subtracting off 1 (from i+1) to get zero-indexing for eos_cb
+
+
+                //std::cerr << "BasePair " << i << " " << ScoreBasePair(i+1,j) << std::endl;
+                eos_cb_map[i] += ScoreBasePairEvidence(i+1,j);
+
+
+                // ScoreHelixStacking(i,j): score for a helix stacking pair of the form:
+                //
+                //       |         |
+                //    s[i+1] == s[j-1]
+                //       |         |
+                //     s[i] ==== s[j]
+                //       |         |
+                //HWS: subtracting off 1 (from i) to get zero-indexing for eos_cb
+
+                //std::cerr << "HelixStacking " << i-1 << " " << ScoreHelixStacking(i,j+1) << std::endl;
+                eos_cb_map[i-1] += ScoreHelixStacking(i,j+1);
+
+                }
+                else
+                {
+                    //CountSingle(i,j,p,q,RealT(1));
+                    //here we need to break this down because they sum a bunch of things to make ScoreSingle
+                    // here we need to subtract off the second base pair from ScoreSingle
+                // std::cerr << "Single " << i-1 << " " << ScoreSingle(i,j,p,q)-ScoreBasePair(p+1,q) << std::endl;
+                // std::cerr << "ScoreBasePair " << p << " " << ScoreBasePair(p+1,q) << std::endl;
+
+                eos_cb_map[i-1] += ScoreSingleEvidence(i,j,p,q)-ScoreBasePairEvidence(p+1,q);
+                eos_cb_map[p] += ScoreBasePairEvidence(p+1, q);
+
+                }
+                
+                traceback_queue.push(make_triple(&FCt[0], p+1, q-1));
+            }
+            break;
+            case TB_FC_BIFURCATION:
+            {
+                const int k = traceback.second;
+                // CountJunctionA(i,j,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountMultiBase(RealT(1));
+
+                // This is where we first recognize we're in a new multiloop. Store the things at i
+                multiloops.push_back(make_triple(i,j,0));
+                // std::cerr << "New multiloop! " << i << ":" << j << std::endl;
+
+                // std::cerr << "FCBifurc:JunctionA " << i << " " << ScoreJunctionA(i,j) << std::endl;
+                // std::cerr << "FCBifurc:MultiPaired " << i << " " << ScoreMultiPaired() << std::endl;
+                // std::cerr << "FCBifurc:MultiBase " << i << " " << ScoreMultiBase() << std::endl;
+
+                eos_cb_map[i] += ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+#endif
+            case TB_FM1_PAIRED:
+            {
+                // CountJunctionA(j,i,RealT(1));
+                // CountMultiPaired(RealT(1));
+                // CountBasePair(i+1,j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i < multiloops[ind].second){
+                        if (i - multiloops[ind].first < min_dist){
+                            min_dist = i - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+
+                // These all go in the multiloop ind
+                //std::cerr << "Paired:JunctionA " << curr_multiloop_ind << " " << ScoreJunctionA(j,i) << std::endl;
+                //std::cerr << "Paired:MultiPaired " << curr_multiloop_ind << " " << ScoreMultiPaired() << std::endl;
+                
+                eos_cb_map[curr_multiloop_ind] += ScoreJunctionA(j,i) + ScoreMultiPaired();
+
+                //This just goes with the next base pair
+                //std::cerr << "Paired:BasePair " << i << " " << ScoreBasePair(i+1, j) << std::endl;
+                eos_cb_map[i] += ScoreBasePairEvidence(i+1, j);
+
+                traceback_queue.push(make_triple(&FCt[0], i+1, j-1));
+            }
+            break;
+            case TB_FM1_UNPAIRED:
+            {
+                // CountMultiUnpaired(i+1,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < i+1 < multiloops[ind].second){
+                        if (i+1 - multiloops[ind].first < min_dist){
+                            min_dist = i+1 - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(i+1) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpairedEvidence(i+1);
+
+                traceback_queue.push(make_triple(&FM1t[0], i+1, j));
+            }
+            break;
+            case TB_FM_BIFURCATION:
+            {
+                const int k = traceback.second;
+                traceback_queue.push(make_triple(&FM1t[0], i, k));
+                traceback_queue.push(make_triple(&FMt[0], k, j));
+            }
+            break;
+            case TB_FM_UNPAIRED:
+            {
+                // CountMultiUnpaired(j,RealT(1));
+
+                // HWS: We're in a multiloop -- this gets the index of the 5' base 
+                // of the current multiloop and puts in curr_multiloop ind.
+
+                int min_dist = 100000;
+                int curr_multiloop_ind = -1;
+
+                for(int ind=0; ind < multiloops.size(); ind++){
+                    if (multiloops[ind].first < j < multiloops[ind].second){
+                        if (j - multiloops[ind].first < min_dist){
+                            min_dist = j - multiloops[ind].first;
+                            curr_multiloop_ind = multiloops[ind].first;
+                        }
+                    }
+                }
+                // HWS: a score for unpaired bases in multiloops, put in curr_multiloop ind
+
+                //std::cerr << "MultiUnpaired " << curr_multiloop_ind << " " << ScoreMultiUnpaired(j) << std::endl;
+                eos_cb_map[curr_multiloop_ind] += ScoreMultiUnpairedEvidence(j);
+
+                traceback_queue.push(make_triple(&FMt[0], i, j-1));
+            }
+            break;
+            case TB_FM_FM1: 
+                traceback_queue.push(make_triple(&FM1t[0], i, j));
+                break;
+            case TB_F5_ZERO:
+                break;
+            case TB_F5_UNPAIRED:
+                CountExternalUnpaired(j,RealT(1));
+
+                // HWS: a score for unpaired things in the external loop, dump into the -1 eos_cb
+
+                //std::cerr << "ExternalUnpaired -1 " << ScoreExternalUnpaired(j) << std::endl;
+                eos_cb_map[-1] += ScoreExternalUnpairedEvidence(j);
+
                 traceback_queue.push(make_triple(&F5t[0], 0, j-1));
                 break;
             case TB_F5_BIFURCATION:
             {
                 const int k = traceback.second;
-                CountExternalPaired(RealT(1));
-                CountBasePair(k+1,j,RealT(1));
-                CountJunctionA(j,k,RealT(1));
+                // CountExternalPaired(RealT(1));
+                // CountBasePair(k+1,j,RealT(1));
+                // CountJunctionA(j,k,RealT(1));
                 traceback_queue.push(make_triple(&F5t[0], 0, k));
                 traceback_queue.push(make_triple(&FCt[0], k+1, j-1));
+
+                //HWS: this is base pairs facing external loop. Hard-coding to print -1 as thinking these 
+                //should get summed in to the -1 "external loop " eos_cb category
+                
+                //std::cerr << "F5Bifurc:ExternalPaired -1 " << ScoreExternalPaired() << std::endl;
+                //std::cerr << "F5Bifurc:JunctionA -1 " << ScoreJunctionA(j,k) << std::endl;
+                eos_cb_map[-1] += ScoreExternalPaired()+ScoreJunctionA(j,k); //TODO: ScoreExternalPairedEvidence
+ 
+                // HWS: another base pair, print (k+1) - 1 to zero-index
+                //std::cerr << "F5Bifurc:BasePair " << k << " " << ScoreBasePair(k+1, j) << std::endl;
+                eos_cb_map[k] += ScoreBasePairEvidence(k+1, j);
+
             }
             break;
             default:
                 Assert(false, "Bad traceback.");
         }
     }
+    RealT local_sum = 0;
+    std::cerr << "EOS_CB: ";
+    for (std::pair<int, RealT> element : eos_cb_map) {
+        if (element.first == -1 || element.second != 0){
+        std::cerr << element.first << ", " << element.second << ", ";
+        local_sum += element.second;
+    }
+    }
+    std::cerr << std::endl;
+    std::cerr << "local sum " << local_sum << std::endl;
 
-    FinalizeCounts();
-    return GetCounts();
 }
 
 //////////////////////////////////////////////////////////////////////
@@ -5938,7 +6718,6 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
     //double starting_time = GetSystemTime();
 
     const RealT Z = ComputeLogPartitionCoefficientESS();
-
     
     for (int i = L; i >= 0; i--)
     {
@@ -5992,7 +6771,7 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
                 
                 if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
                     CountHairpinEvidence(i,j,Fast_Exp(outside + ScoreHairpinEvidence(i,j)));
-                
+
                 // compute SUM (i<=p<p+2<=q<=j, p-i+j-q>0 : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
                 
 #if !FAST_SINGLE_BRANCH_LOOPS
@@ -6128,8 +6907,12 @@ void InferenceEngine<RealT>::ComputePosteriorESS()
                 // compute ScoreHairpin(i,j)
                 
                 if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
+                {
                     CountHairpinEvidence(i,j,Fast_Exp(outside + ScoreHairpinEvidence(i,j)));
-                
+                                  //  std::cerr << ScoreHairpinEvidence(i,j) << std::endl; HWS
+
+                }
+
                 // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
                 
 #if !FAST_SINGLE_BRANCH_LOOPS
@@ -7716,8 +8499,8 @@ std::vector<RealT> InferenceEngine<RealT>::ComputeGammaMLESS(std::vector<int> ev
     RealT sum1 = 0;
     RealT sum2 = 0;
     int N = 0;
-    int i = ev_cpd_id[0];
-    int j = ev_cpd_id[1];
+    int i = ev_cpd_id[0]; // nucleotide type
+    int j = ev_cpd_id[1]; // paired or unpaired
 
     double score_up = 0;
 
@@ -7911,3 +8694,497 @@ int InferenceEngine<RealT>::AreZerosInSeq(int id_base, int which_data)
     return areZeros;
 }
 
+template<class RealT>
+void InferenceEngine<RealT>::InitRand(unsigned int seed)
+{
+    if (die) delete die;
+    die = new Die(seed);
+}
+
+// stochastic traceback algorithm
+template<class RealT>
+std::vector<int> InferenceEngine<RealT>::PredictPairingsStochasticTraceback() const
+{
+    enum { ST_FC, ST_F5, ST_FM, ST_FM1, ST_FE, ST_FN };
+
+    std::vector<int> solution(L+1,SStruct::UNPAIRED);
+    solution[0] = SStruct::UNKNOWN;
+
+    std::queue<triple<int,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(int(ST_F5), 0, L));
+
+    while (!traceback_queue.empty())
+    {
+        triple<int,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int i = t.second;
+        const int j = t.third;
+        int L2 = L; // ed to remove max bp dist
+
+        switch (t.first)
+        {
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case ST_FC:
+                break;
+            case ST_FE:
+                break;
+            case ST_FN:
+                break;
+#else
+            case ST_FC:
+            {
+                if (0 < i && j < L2 && allow_paired[offset[i]+j+1]) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+                
+                    // compute ScoreHairpin(i,j)
+                    if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
+                        roulette.add(EncodeTraceback(TB_FC_HAIRPIN,0), ScoreHairpin(i,j));
+                
+                    // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
+                    for (int p = i; p <= std::min(i+C_MAX_SINGLE_LENGTH,j); p++)
+                    {
+                        if (p > i && !allow_unpaired_position[p]) break;
+                        int q_min = std::max(p+2,p-i+j-C_MAX_SINGLE_LENGTH);
+                        for (int q = j; q >= q_min; q--)
+                        {
+                            if (q < j && !allow_unpaired_position[q+1]) break;
+                            if (!allow_paired[offset[p+1]+q]) continue;
+
+                            if (p == i && q == j)
+                            {
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                             ScoreBasePair(i+1,j) + ScoreHelixStacking(i,j+1) +
+                                             FCi[offset[p+1]+q-1]);
+                            }
+                            else
+                            {
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                             ScoreSingle(i,j,p,q) + FCi[offset[p+1]+q-1]);
+                            }
+                        }
+                    }
+
+                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j] + ScoreJunctionA(i,j) + a + c)
+                    for (int k=i+1; k < j; k++)
+                    {
+                        RealT FM2i = FM1i[offset[i]+k] + FMi[offset[k]+j];
+                        RealT val = FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+                        roulette.add(EncodeTraceback(TB_FC_BIFURCATION, k), val);
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FC_HAIRPIN: 
+                            break;
+                        case TB_FC_SINGLE: 
+                        {
+                            const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                            const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                            solution[p+1] = q;
+                            solution[q] = p+1;
+                            traceback_queue.push(make_triple(int(ST_FC), p+1, q-1));
+                        }
+                        break;
+                        case TB_FC_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                            traceback_queue.push(make_triple(int(ST_FM), k, j));
+                        }
+                        break;
+                    }
+                } //else { Assert(!, "unreachable"); }
+            } 
+            break;
+#endif
+
+            case ST_FM:
+                if (0 < i && i+2 <= j && j < L2) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j]) 
+                    for (int k=i+1; k < j; k++)
+                    {
+                        RealT FM2i = FM1i[offset[i]+k] + FMi[offset[k]+j];
+                        roulette.add(EncodeTraceback(TB_FM_BIFURCATION, k), FM2i);
+                    }
+
+                    // compute FM[i,j-1] + b
+                    if (allow_unpaired_position[j])
+                    {
+                        roulette.add(EncodeTraceback(TB_FM_UNPAIRED,0),
+                                     FMi[offset[i]+j-1] + ScoreMultiUnpaired(j));
+                    }
+
+                    // compute FM1[i,j]
+                    roulette.add(EncodeTraceback(TB_FM_FM1,0), FM1i[offset[i]+j]);
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FM_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                            traceback_queue.push(make_triple(int(ST_FM), k, j));
+                        }
+                        break;
+                        case TB_FM_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM), i, j-1));
+                        }
+                        break;
+                        case TB_FM_FM1: 
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM1), i, j));
+                        }
+                        break;
+                    }
+                
+                } //else { Assert(!, "unreachable"); }
+                break;
+
+            case ST_FM1:
+                if (0 < i && i+2 <= j && j < L2) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
+                    if (allow_paired[offset[i+1]+j])
+                    {
+                        RealT value = FCi[offset[i+1]+j-1] + ScoreJunctionA(j,i) +
+                            ScoreMultiPaired() + ScoreBasePair(i+1,j);
+                        roulette.add(EncodeTraceback(TB_FM1_PAIRED, 0), value);
+                    }
+                
+                    // compute FM1[i+1,j] + b
+                    if (allow_unpaired_position[i+1])
+                    {
+                        roulette.add(EncodeTraceback(TB_FM1_UNPAIRED,0),
+                                     FM1i[offset[i+1]+j] + ScoreMultiUnpaired(i+1));
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FM1_PAIRED:
+                        {
+                            solution[i+1] = j;
+                            solution[j] = i+1;
+                            traceback_queue.push(make_triple(int(ST_FC), i+1, j-1));
+                        }
+                        break;
+                        case TB_FM1_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM1), i+1, j));
+                        }
+                        break;
+                    }
+                } //else { Assert(!, "unreachable"); }
+                break;
+
+            case ST_F5:
+                if (j!=0)
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute F5[j-1] + ScoreExternalUnpaired()
+                    if (allow_unpaired_position[j])
+                    {
+                        roulette.add(EncodeTraceback(TB_F5_UNPAIRED,0),
+                                     F5i[j-1] + ScoreExternalUnpaired(j));
+                    }
+        
+                    // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
+                    int l = 0; // ed remove max bp dist
+                    for (int k = l; k < j; k++)
+                    {
+                        if (allow_paired[offset[k+1]+j])
+                        {
+                            RealT value = F5i[k] + FCi[offset[k+1]+j-1] + ScoreExternalPaired() +
+                                ScoreBasePair(k+1,j) + ScoreJunctionA(j,k);
+                            roulette.add(EncodeTraceback(TB_F5_BIFURCATION,k), value);
+                        }      
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_F5_ZERO:
+                            break;
+                        case TB_F5_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_F5), 0, j-1));
+                        }
+                        break;
+                        case TB_F5_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            solution[k+1] = j;
+                            solution[j] = k+1;
+                            traceback_queue.push(make_triple(int(ST_F5), 0, k));
+                            traceback_queue.push(make_triple(int(ST_FC), k+1, j-1));
+                        }
+                        break;
+                    }
+                }
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    return solution;
+}
+
+// stochastic traceback algorithm with chemical mapping data
+template<class RealT>
+std::vector<int> InferenceEngine<RealT>::PredictPairingsStochasticTracebackESS() const
+{
+    enum { ST_FC, ST_F5, ST_FM, ST_FM1, ST_FE, ST_FN };
+
+    std::vector<int> solution(L+1,SStruct::UNPAIRED);
+    solution[0] = SStruct::UNKNOWN;
+
+    std::queue<triple<int,int,int> > traceback_queue;
+    traceback_queue.push(make_triple(int(ST_F5), 0, L));
+
+    while (!traceback_queue.empty())
+    {
+        triple<int,int,int> t = traceback_queue.front();
+        traceback_queue.pop();
+        const int i = t.second;
+        const int j = t.third;
+        int L2 = L; // ed to remove max bp dist
+
+        switch (t.first)
+        {
+#if PARAMS_HELIX_LENGTH || PARAMS_ISOLATED_BASE_PAIR
+            case ST_FC:
+                break;
+            case ST_FE:
+                break;
+            case ST_FN:
+                break;
+#else
+            case ST_FC:
+            {
+                if (0 < i && j < L2 && allow_paired[offset[i]+j+1]) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+                
+                    // compute ScoreHairpin(i,j)
+                    if (allow_unpaired[offset[i]+j] && j-i >= C_MIN_HAIRPIN_LENGTH)
+                        roulette.add(EncodeTraceback(TB_FC_HAIRPIN,0), ScoreHairpinEvidence(i,j));
+                
+                    // compute SUM (i<=p<p+2<=q<=j : ScoreSingle(i,j,p,q) + FC[p+1,q-1])
+                    for (int p = i; p <= std::min(i+C_MAX_SINGLE_LENGTH,j); p++)
+                    {
+                        if (p > i && !allow_unpaired_position[p]) break;
+                        int q_min = std::max(p+2,p-i+j-C_MAX_SINGLE_LENGTH);
+                        for (int q = j; q >= q_min; q--)
+                        {
+                            if (q < j && !allow_unpaired_position[q+1]) break;
+                            if (!allow_paired[offset[p+1]+q]) continue;
+
+                            if (p == i && q == j)
+                            {
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                             ScoreBasePairEvidence(i+1,j) + ScoreHelixStacking(i,j+1) +
+                                             FCi_ess[offset[p+1]+q-1]);
+                            }
+                            else
+                            {
+                                roulette.add(EncodeTraceback(TB_FC_SINGLE,(p-i)*(C_MAX_SINGLE_LENGTH+1)+j-q),
+                                             ScoreSingleEvidence(i,j,p,q) + FCi_ess[offset[p+1]+q-1]);
+                            }
+                        }
+                    }
+
+                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j] + ScoreJunctionA(i,j) + a + c)
+                    for (int k=i+1; k < j; k++)
+                    {
+                        RealT FM2i = FM1i_ess[offset[i]+k] + FMi_ess[offset[k]+j];
+                        RealT val = FM2i + ScoreJunctionA(i,j) + ScoreMultiPaired() + ScoreMultiBase();
+                        roulette.add(EncodeTraceback(TB_FC_BIFURCATION, k), val);
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FC_HAIRPIN: 
+                            break;
+                        case TB_FC_SINGLE: 
+                        {
+                            const int p = i + traceback.second / (C_MAX_SINGLE_LENGTH+1);
+                            const int q = j - traceback.second % (C_MAX_SINGLE_LENGTH+1);
+                            solution[p+1] = q;
+                            solution[q] = p+1;
+                            traceback_queue.push(make_triple(int(ST_FC), p+1, q-1));
+                        }
+                        break;
+                        case TB_FC_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                            traceback_queue.push(make_triple(int(ST_FM), k, j));
+                        }
+                        break;
+                    }
+                } //else { Assert(!, "unreachable"); }
+            } 
+            break;
+#endif
+
+            case ST_FM:
+                if (0 < i && i+2 <= j && j < L2) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute SUM (i<k<j : FM1[i,k] + FM[k,j]) 
+                    for (int k=i+1; k < j; k++)
+                    {
+                        RealT FM2i = FM1i_ess[offset[i]+k] + FMi_ess[offset[k]+j];
+                        roulette.add(EncodeTraceback(TB_FM_BIFURCATION, k), FM2i);
+                    }
+
+                    // compute FM[i,j-1] + b
+                    if (allow_unpaired_position[j])
+                    {
+                        roulette.add(EncodeTraceback(TB_FM_UNPAIRED,0),
+                                     FMi_ess[offset[i]+j-1] + ScoreMultiUnpairedEvidence(j));
+                    }
+
+                    // compute FM1[i,j]
+                    roulette.add(EncodeTraceback(TB_FM_FM1,0), FM1i_ess[offset[i]+j]);
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FM_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            traceback_queue.push(make_triple(int(ST_FM1), i, k));
+                            traceback_queue.push(make_triple(int(ST_FM), k, j));
+                        }
+                        break;
+                        case TB_FM_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM), i, j-1));
+                        }
+                        break;
+                        case TB_FM_FM1: 
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM1), i, j));
+                        }
+                        break;
+                    }
+                
+                } //else { Assert(!, "unreachable"); }
+                break;
+
+            case ST_FM1:
+                if (0 < i && i+2 <= j && j < L2) // ???
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute FC[i+1,j-1] + ScoreJunctionA(j,i) + c + ScoreBP(i+1,j)
+                    if (allow_paired[offset[i+1]+j])
+                    {
+                        RealT value = FCi_ess[offset[i+1]+j-1] + ScoreJunctionA(j,i) +
+                            ScoreMultiPaired() + ScoreBasePairEvidence(i+1,j);
+                        roulette.add(EncodeTraceback(TB_FM1_PAIRED, 0), value);
+                    }
+                
+                    // compute FM1[i+1,j] + b
+                    if (allow_unpaired_position[i+1])
+                    {
+                        roulette.add(EncodeTraceback(TB_FM1_UNPAIRED,0),
+                                     FM1i_ess[offset[i+1]+j] + ScoreMultiUnpaired(i+1));
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_FM1_PAIRED:
+                        {
+                            solution[i+1] = j;
+                            solution[j] = i+1;
+                            traceback_queue.push(make_triple(int(ST_FC), i+1, j-1));
+                        }
+                        break;
+                        case TB_FM1_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_FM1), i+1, j));
+                        }
+                        break;
+                    }
+                } //else { Assert(!, "unreachable"); }
+                break;
+
+            case ST_F5:
+                if (j!=0)
+                {
+                    Roulette<int,RealT> roulette(*die);
+
+                    // compute F5[j-1] + ScoreExternalUnpaired()
+                    if (allow_unpaired_position[j])
+                    {
+                        roulette.add(EncodeTraceback(TB_F5_UNPAIRED,0),
+                                     F5i_ess[j-1] + ScoreExternalUnpairedEvidence(j));
+                    }
+        
+                    // compute SUM (0<=k<j : F5[k] + FC[k+1,j-1] + ScoreExternalPaired() + ScoreBP(k+1,j) + ScoreJunctionA(j,k))
+                    int l = 0; // ed remove max bp dist
+                    for (int k = l; k < j; k++)
+                    {
+                        if (allow_paired[offset[k+1]+j])
+                        {
+                            RealT value = F5i_ess[k] + FCi_ess[offset[k+1]+j-1] + ScoreExternalPaired() +
+                                ScoreBasePairEvidence(k+1,j) + ScoreJunctionA(j,k);
+                            roulette.add(EncodeTraceback(TB_F5_BIFURCATION,k), value);
+                        }      
+                    }
+
+                    // choose
+                    std::pair<int,int> traceback = DecodeTraceback(roulette.choose());
+                    switch (traceback.first)
+                    {
+                        case TB_F5_ZERO:
+                            break;
+                        case TB_F5_UNPAIRED:
+                        {
+                            traceback_queue.push(make_triple(int(ST_F5), 0, j-1));
+                        }
+                        break;
+                        case TB_F5_BIFURCATION:
+                        {
+                            const int k = traceback.second;
+                            solution[k+1] = j;
+                            solution[j] = k+1;
+                            traceback_queue.push(make_triple(int(ST_F5), 0, k));
+                            traceback_queue.push(make_triple(int(ST_FC), k+1, j-1));
+                        }
+                        break;
+                    }
+                }
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    return solution;
+}
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.cpp b/./SStruct.cpp
index 77e7edc..14619ef 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.cpp
+++ b/./SStruct.cpp
@@ -804,6 +804,22 @@ void SStruct::WriteBPSEQ(std::ostream &outfile, const int seq) const
         outfile << i << ' ' << sequences[seq][i] << ' ' << mapping[i] << std::endl;
 }
 
+//////////////////////////////////////////////////////////////////////
+// SStruct::WriteBPPSEQ()
+//
+// Write sequence in BPPSEQ format.  The BPSEQ format can only handle
+// single sequences, so it will only print out the sequence "seq".
+//////////////////////////////////////////////////////////////////////
+
+void SStruct::WriteBPPSEQ(std::ostream &outfile, std::vector<std::vector<double> > potential, const int seq)
+{
+    if (seq < 0 || seq >= int(sequences.size())) Error("Reference to invalid sequence.");
+    Assert(sequences[seq].length() == mapping.size(), "Inconsistent lengths.");
+    
+    for (size_t i = 1; i < mapping.size(); i++)
+        outfile << i << ' ' << sequences[seq][i] << " e1 " << potential[seq][i-1] << std::endl;
+}
+
 //////////////////////////////////////////////////////////////////////
 // SStruct::WriteParens()
 //
@@ -828,6 +844,29 @@ void SStruct::WriteParens(std::ostream &outfile) const
     outfile << ConvertMappingToParens(mapping).substr(1) << std::endl;
 }
 
+//////////////////////////////////////////////////////////////////////
+// SStruct::WriteParensOnly()
+//
+// Write sequence in parenthesized format.  This routine assumes that
+// the structure does not contain pseudoknots.  All sequences are
+// printed.
+//////////////////////////////////////////////////////////////////////
+
+void SStruct::WriteParensOnly(std::ostream &outfile) const
+{
+    if (ContainsPseudoknots()) Error("Cannot write structure containing pseudoknots using parenthesized format.");
+    
+    // print sequences
+    // for (size_t k = 0; k < sequences.size(); k++)
+    // {
+    //     outfile << ">" << names[k] << std::endl;
+    //     outfile << sequences[k].substr(1) << std::endl;
+    // }
+
+    // print structure
+    //outfile << ">structure" << std::endl;
+    outfile << ConvertMappingToParens(mapping).substr(1) << std::endl;
+}
 //////////////////////////////////////////////////////////////////////
 // SStruct::ComputePercentIdentity()
 //
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.hpp b/./SStruct.hpp
index 969b761..f2fa204 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.hpp
+++ b/./SStruct.hpp
@@ -16,6 +16,7 @@
 #include <vector>
 #include <string>
 #include <sstream>
+#include "Config.hpp"
 #include "Utilities.hpp"
 
 //////////////////////////////////////////////////////////////////////
@@ -87,6 +88,9 @@ public:
     // output in various formats
     void WriteBPSEQ(std::ostream &outfile, const int seq = 0) const;
     void WriteParens(std::ostream &outfile) const;
+    void WriteParensOnly(std::ostream &outfile) const;
+    void WriteBPPSEQ(std::ostream &outfile, std::vector<std::vector<double> > potential, const int seq = 0);
+
 
     // compute alignment percent identity
     double ComputePercentIdentity() const;
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.o b/./SStruct.o
index 1063744..bd04391 100644
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/SStruct.o and b/./SStruct.o differ
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/ScorePrediction.o b/./ScorePrediction.o
index 3d04098..14c63e8 100644
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/ScorePrediction.o and b/./ScorePrediction.o differ
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/Utilities.hpp b/./Utilities.hpp
index 7a6708d..af7ed86 100644
--- a/Users/hwayment/das/software/cse_versions/cse-clean/src/Utilities.hpp
+++ b/./Utilities.hpp
@@ -12,6 +12,7 @@
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
+#include <list>
 #include <climits>
 #include <fstream>
 #include <iomanip>
diff --git a/Users/hwayment/das/software/cse_versions/cse-clean/src/contrafold b/./contrafold
index d833057..c530cc9 100755
Binary files a/Users/hwayment/das/software/cse_versions/cse-clean/src/contrafold and b/./contrafold differ

diff --git a/./rand.h b/./rand.h
new file mode 100644
index 0000000..d47d2c3
--- /dev/null
+++ b/./rand.h
@@ -0,0 +1,62 @@
+#ifndef __INC_RAND_H__
+#define __INC_RAND_H__
+
+#include <cstdlib>
+class Die
+{
+public:
+  Die(unsigned int seed)
+  {
+    srand(seed);
+  }
+
+  double operator()()
+  {
+    return rand()/(RAND_MAX+1.0);
+  }
+};
+
+template < class T, class RealT >
+class Roulette
+{
+public:
+    Roulette(Die &die)
+        : t_(), max_(NEG_INF), die_(die)
+    { }
+
+    void add(T t, RealT v)
+    {
+        t_.push_back(std::make_pair(t, v));
+        max_ = std::max(max_, v);
+    }
+
+    T choose() const
+    {
+        RealT sum = 0.0;
+        std::list<std::pair<T,RealT> > u;
+        typename std::list< std::pair<T,RealT> >::const_iterator x;
+        for (x=t_.begin(); x!=t_.end(); ++x)
+        {
+            u.push_back(std::make_pair(x->first, Fast_Exp(x->second - max_)));
+            sum += u.back().second;
+        }
+
+        Assert(sum>0.0, "sum not > 0");
+        RealT r = die_()*sum;
+        RealT s = 0.0;
+        for (x=u.begin(); x!=u.end(); ++x)
+        {
+            s += x->second;
+            if (r<s) return x->first;
+        }
+        return u.back().first;
+    }
+
+    unsigned int size() const { return t_.size(); }
+
+private:
+    std::list<std::pair<T,RealT> > t_;
+    RealT max_;
+    Die& die_;
+};
+#endif  //  __INC_RAND_H__
\ No newline at end of file

